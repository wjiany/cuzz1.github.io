<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[堆排序]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[今天看到一篇面经，算法题是手写堆排序，《算法》已经放下很就了，想试试能不能写出来，然而并没有，所以记录一下 自顶到底构造堆这是一道lintcode上面的题目堆化 描述 给出一个整数数组，堆化操作就是把它变成一个最小堆数组。 对于堆数组A，A[0]是堆的根，并对于每个A[i]，A [i 2 + 1]是A[i]的左儿子并且A[i 2 + 2]是A[i]的右儿子。 您在真实的面试中是否遇到过这个题？ 是 题目纠错 说明 什么是堆？ 堆是一种数据结构，它通常有三种方法：push， pop 和 top。其中，“push”添加新的元素进入堆，“pop”删除堆中最小/最大元素，“top”返回堆中最小/最大元素。 什么是堆化？ 把一个无序整数数组变成一个堆数组。如果是最小堆，每个元素A[i]，我们将得到A[i 2 + 1] &gt;= A[i]和A[i 2 + 2] &gt;= A[i] 如果有很多种堆化的结果？ 返回其中任何一个。 样例 给出 [3,2,1,4,5]，返回[1,2,3,4,5] 或者任何一个合法的堆数组 挑战 O(n)的时间复杂度完成堆化 构造一个堆只需要从左到右遍历数组，每次只要保证所遍历到的位子能满足堆的条件 12345678910111213141516171819202122232425public class Solution &#123; /* * @param A: Given an integer array * @return: nothing */ public void heapify(int[] A) &#123; for (int i = 0; i &lt; A.length; i++) &#123; swim(A, i); &#125; &#125; // 上浮 private void swim(int[] A, int i) &#123; while(i &gt; 0 &amp;&amp; A[i] &lt; A[(i-1) / 2]) &#123; swap(A, i, (i-1) / 2); i = (i-1) / 2; &#125; &#125; private void swap(int[] A, int i, int j) &#123; int temp = A[i]; A[i] = A[j]; A[j] = temp; &#125;&#125; 自底到顶构造堆而堆排序采用的是自底到顶构造堆，每次把第一个元素和最后一个元素交换，交换之后把第一个元素下沉，同时堆数组减一，下面是代码 1234567891011121314151617181920212223242526272829303132333435363738394041public class Heap &#123; private static void heapSort(int[] array) &#123; int len = array.length - 1; for (int i = (len - 1) / 2; i &gt;= 0; i--) &#123; sink(array, i, len); &#125; printArr(array); while (len &gt;= 0) &#123; swap(array, 0, len); sink(array, 0, --len); &#125; &#125; private static void sink(int[] array, int i, int len) &#123; while (i * 2 + 1 &lt;= len) &#123; int j = i * 2 + 1; if (j + 1 &lt;= len &amp;&amp; array[j+1] &gt; array[j]) j++; if (array[i] &gt; array[j]) break; swap(array, i, j); i = j; &#125; &#125; private static void swap(int[] array, int i, int j) &#123; int temp = array[i]; array[i] = array[j]; array[j] = temp; &#125; public static void main(String[] args) &#123; int[] array = &#123;2, 3, 1, 6, 4, 5, 2, 1&#125;; heapSort(array); printArr(array); &#125; private static void printArr(int[] array) &#123; Arrays.stream(array).forEach(a -&gt; System.out.print(a + " ")); System.out.println(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>堆排序</tag>
        <tag>lintcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell入门]]></title>
    <url>%2F2018%2F10%2F04%2FShell%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Shell是操作系统（内核）与用户之间的桥梁 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell Shell编程之Hello World编写一个hello world shell一般使用.sh作为后缀 123456#!/bin/bash # 使用/bin/sh来解释执行 # auto echo hello world! # 解释这个脚本是干什么的# by authors cuzz # 作者和时间一些信息echo "hello world!" 给脚本添加执行权限 1&gt; chmod +x hello.sh Shell编程之变量Shell变量可以分为两类：局部变量和环境变量 12345678#!/bin/bash# define path variables# by authors cuzzname=cuzz # 等号两边不能有空格echo "my name is $name" # 使用$引用 基本变量 1234567echo $PWD # 当前路径echo $0 # 脚本名echo $1 # 第一个参数echo $2 # 第二个参数echo $? # 判断上一个命令是否正确echo $* # 所有参数echo $# # 参数的个数 Shell编程之if条件语句比较大小 12345678910111213#!/bin/bash# if test# by authors cuzznum=100# 计算使用两个小括号if (($num &gt; 10)); then echo "this num greater than 10."else echo "this num littler than 10."fi 逻辑运算符 运算符 说明 举例 -eq 检测两个数是否相等，相等返回 true。 [ \$a -eq $b ] 返回 false。 -ne 检测两个数是否不相等，不相等返回 true。 [ \$a -ne $b ] 返回 true。 -gt 检测左边的数是否大于右边的，如果是，则返回 true。 [ \$a -gt $b ] 返回 false。 -lt 检测左边的数是否小于右边的，如果是，则返回 true。 [ \$a -lt $b ] 返回 true。 -ge 检测左边的数是否大于等于右边的，如果是，则返回 true。 [ \$a -ge $b ] 返回 false。 -le 检测左边的数是否小于等于右边的，如果是，则返回 true。 [ \$a -le $b ] 返回 true。 目录 操作符 说明 举例 -d file 检测文件是否是目录，如果是，则返回 true。 [ -d $file ] 返回 false。 -f file 检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。 [ -f $file ] 返回 true。 -p file 检测文件是否是有名管道，如果是，则返回 true。 [ -p $file ] 返回 false。 -e file 检测文件（包括目录）是否存在，如果是，则返回 true。 [ -e $file ] 返回 true。 创建文件 12345678910111213#!/bin/bash# if test# by authors cuzzDIR=cuzzif [ ! -d $DIR ]; then # 都有空格 mkdir $DIR echo "this $DIR create success."else echo "this dir is exit."fi 测试文件是否存在 123456789101112#!/bin/bash# if test# by authors cuzzfile=test.txtif [ ! -e $file ]; then echo "OK" &gt;&gt; $file # &gt;&gt;是追加内容 &gt;是覆盖内容else cat $filefi mysql备份 12345678910111213141516171819202122232425262728293031323334353637#!/bin/bash# auto backup mysql db# by authors cuzz# define backup pathBAK_DIR=/data/backup/`date +%Y%m%d` # 反引号可以把里面当作命令来解析 # mysqlMYSQLDB=testMYSQLUSER=rootMYSQLPW=123456MYSQLCMD=/usr/bin/mysqldump # 备份命令# 判断是否是rootif [ $UID -ne 0 ]; then echo "Only root can execute Shell." exitfiif [ ! -d $BAK_DIR ]; then mkdir -p $BAK_DIR # -p 父目录不存在就创建 echo "The $BAK_DIR create success."else echo "This $BAK_DIR is exist."fi# mysql backup command$MYSQLCMD -u$MYSQLUSER -p$MYSQLPW -d $MYSQLDB &gt;$BAK_DIR/$MYSQLDB.sqlif [ $? -eq 0 ]; then echo "backup success."else echo "backup fail."fi Shell编程之for循环基本语句 123456#!/bin/bashfor i in `seq 1 15`do echo "the number is $i."done 求和 12345678910#!/bin/bashsum=0for ((i=1; i&lt;=100; i++)) # 双括号用于运算相当与其他语言的单括号do sum=`expr $sum + $i` # expr用于计算doneecho "$sum" 打包，只能打包到最后一个，后面的会把前面的覆盖了 1234567#!/bin/bashfor file in `find ./ -name "*.sh"`do tar -czf all.tgz $filedone Shell编程之while循环使用 12345678#!/bin/bashi=0while [[ $i -lt 10 ]] # (( $i &lt; 10))是一样的do echo "$i" ((i++))done 结合read使用 123456#!/bin/bashwhile read line # 把读取的东西赋值给linedo echo $linedone &lt;/etc/hosts # 从哪里读取 Shell编程之数组Shell 数组用括号来表示，元素用”空格”符号分割开，语法格式如下： 12345678910111213my_array=(A B "C" D) # 定义数组array_name[0]=value0 # 使用下标来定义array_name[1]=value1array_name[2]=value2$&#123;array_name[0]&#125; # 读取第一个元素$&#123;my_array[*]&#125; # 读取所有元素 $&#123;my_array[@]&#125; # 读取所有元素$&#123;#my_array[*]&#125; # 读取数组长度$&#123;#my_array[@]&#125; # 读取数组长度 Shell编程之函数无返回值得函数 12345678sayHello()&#123; # 定义函数一 echo "hello"&#125;function sayHelloWorld()&#123; # 定义函数二 echo "hello world"&#125;sayhell # 使用函数 有返回值得，使用return只能返回0-255 123456789function sum()&#123; returnValue=$(( $1 + $2 )) return $returnValue&#125;sum 22 4echo $? 可以使用echo来传递参数 12345678910111213function length()&#123; str=$1 result=0 if [ "$str" != "" ] ; then result=$&#123;#str&#125; fi echo "$result"&#125;len=$(length "abc123") # 调用echo "The string's length is $len " Shell编程之sed命令把test.txt中的old修改为new，要使用-i才能插入 1&gt; sed -i &apos;s/old/new/s&apos; test.txt 在每行行前面添加一个cuzz 1&gt; sed -i sed &apos;s/^/&amp;cuzz/g&apos; test.txt 在每行的末尾添加一个cuzz 1&gt; sed -i &apos;s/$/&amp; cuzz/g&apos; test.txt 匹配某一行，在下方插入一行，找到cuzz这行在下方插入#### 1&gt; sed &apos;/cuzz/a #######&apos; test.txt 在之前添加一行，只要把a改成i 1&gt; sed &apos;/cuzz/i #######&apos; test.txt 打印 123&gt; sed -n &apos;/cuzz/p&apos; test.txt # 打印含有cuzz这一行&gt; sed -n &apos;1p&apos; test.txt # 打印第一行&gt; sed -n &apos;1,5p&apos; text.txt # 打印1到5行 查找最大和最小值 number.txt 123412 324 56 0034 -23 345345 349- 245 345 345 0989 0459 -25 命令 123456cat number.txt | sed 's/ /\n/g' | grep -v "^$" | sort -nr | sed -n '1p;$p'sed 's/ /\n/g' # 把所有空格换成换行grep -v "^$" # 去掉所有空格sort -nr # 降序排列sed -n '1p;$p # 找出第1行和最后一行 Shell编程之grep命令 -a ：将 binary 文件以 text 文件的方式搜寻数据 -c ：计算找到 ‘搜寻字符串’ 的次数 -i ：忽略大小写的不同，所以大小写视为相同 -n ：顺便输出行号 -v ：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行 –color=auto ：可以将找到的关键词部分加上颜色的显示 egrep 和grep -E 相同，可以使用正则表达式 Shell编程之awk命令123456789# 每行按空格或TAB分割cat test.txt | awk '&#123;print $1&#125;' # 行匹配语句 awk '' 只能用单引号# 指定分割awk -F #-F相当于内置变量FS, 指定分割字符cat test.txt | awk -F: '&#123;print $1&#125;' # 以分号分割# 指定添加某些内容cat test.txt | awk -F: '&#123;print "haha" $1&#125;' # 提前出来再添加haha Shell编程之find命令基本命令 123456find /dir -name "test.txt" # 在/dir目录下查找find . -name "test.txt" # 在当前目录下找 find . -maxdepth 1 -name "text.txt" # 只遍历一层find . -type f -name "text" # 指定类型find . -name "text" -mtime -1 # 指定时间find . -size +20M # 指定大小 查找并执行其他命令 1find . -name "text.txt" -exec rm -rf &#123;&#125; \; # 后面&#123;&#125; \是固定格式]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发（三）]]></title>
    <url>%2F2018%2F09%2F25%2FSpring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注解可以简化配置，提高效率 The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform. 属性赋值@value赋值使用@Value赋值 基本数值 可以写SPEL表达式 #{} 可以${}获取配置文件信息（在运行的环境变量中的值） 使用xml时候导入配置文件是 1&lt;context:property-placeholder location="classpath:person.properties"/&gt; 使用注解可以在配置类添加一个@PropertySource注解把配置文件中k/v保存到运行的环境中 使用${key}来获取 1234567891011121314/** * @Author: cuzz * @Date: 2018/9/24 18:43 * @Description: */@PropertySource(value = &#123;"classpath:/person.properties"&#125;)@Configurationpublic class MainConfigOfPropertyValue &#123; @Bean public Person person() &#123; return new Person(); &#125;&#125; 123456789101112@Datapublic class Person &#123; @Value("vhuj") private String name; @Value("#&#123;20-2&#125;") private Integer age; @Value("$&#123;person.nickName&#125;") private String nickName;&#125; 测试 1234567891011@Testpublic void test01() &#123; printBean(applicationContext); System.out.println("---------------------------"); Person person = (Person) applicationContext.getBean("person"); System.out.println(person); System.out.println("---------------------------");&#125; 输出 123---------------------------Person(name=vhuj, age=18, nickName=三三)--------------------------- 自动装配@Autowired@Qualifier@Primary自动转配： ​ Spring利用依赖注入（DI），完成对IOC容器中各个组件的依赖关系赋值 @Autowired自动注入: ​ a. 默认优先按照类型去容器中寻找对应的组件，如果找到去赋值 ​ b. 如果找到到相同类型的组件，再将属性名（BookDao bookdao）作为组件的id去容器中查找 ​ c. 接下来还可以使用@Qualifier(&quot;bookdao&quot;)明确指定需要装配的id ​ d. 默认是必须的，我们可以指定 @Autowired(required=false)，指定非必须 @Primary让Spring自动装配时首先装配 自动装配@Resource和@InjectSpring还支持使用@Resource (JSR250) 和@Inject (JSR330) 注解，这两个是java规范 @Resource和@Autowired一样实现自动装配功能，默认是按组件名称进行装配的 没有支持@Primary和@Autowird(required=false)的功能 自动装配其他地方的自动装配@Autowired：构造器、参数、方法属性等 标注到方法位子上@Bean+方法参数，参数从容器中获取 12345678910111213141516171819202122232425/** * @Author: cuzz * @Date: 2018/9/24 20:57 * @Description: */public class Boss &#123; // 属性 @Autowired private Car car; // 构造器 如果构造器只有一个有参构造器可以省略 @Autowired public Boss(@Autowired ar car) &#123; &#125; public Car getCar() &#123; return car; &#125; // set方法 @Autowired // 参数 public void setCar(@Autowired Car car) &#123; this.car = car; &#125;&#125; 自动装配Aware注入Spring底层注解自定义组件想要使用Spring容器底层的一些组件（ApplicationContext，BeanFactory 等等），自定义组件实现xxxAware，在创建对象的时候会调用接口规定的方法注入相关的组件 1234567891011/** * Marker superinterface indicating that a bean is eligible to be * notified by the Spring container of a particular framework object * through a callback-style method. Actual method signature is * determined by individual subinterfaces, but should typically * consist of just one void-returning method that accepts a single * argument. */public interface Aware &#123;&#125; 我们实现几个常见的Aware接口 12345678910111213141516171819202122232425/** * @Author: cuzz * @Date: 2018/9/25 10:18 * @Description: */@Componentpublic class Red implements BeanNameAware ,BeanFactoryAware, ApplicationContextAware &#123; private ApplicationContext applicationContext; @Override public void setBeanName(String name) &#123; System.out.println("当前Bean的名字: " + name); &#125; @Override public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123; System.out.println("当前的BeanFactory: " + beanFactory); &#125; @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException &#123; this.applicationContext = applicationContext; System.out.println("传入的ioc: " + applicationContext); &#125;&#125; 注入到配置中测试 12345678910111213/** * @Author: cuzz * @Date: 2018/9/25 10:28 * @Description: */public class IOCTestAware &#123; @Test public void test01() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAware.class); &#125;&#125; 测试结果 123当前Bean的名字: red当前的BeanFactory: org.springframework.beans.factory.support.DefaultListableBeanFactory@159c4b8: defining beans [org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,mainConfigOfAware,red]; root of factory hierarchy传入的ioc: org.springframework.context.annotation.AnnotationConfigApplicationContext@1e89d68: startup date [Tue Sep 25 10:29:17 CST 2018]; root of context hierarchy 把Spring自定义组件注入到容器中 原理： 1public interface ApplicationContextAware extends Aware &#123;&#125; xxxAware都是通过xxxProcessor来处理的 比如：ApplicationContextAware 对应ApplicationContextAwareProcessor 自动装配@Profile环境搭建Profile是Spring为我们提供可以根据当前环境，动态的激活和切换一系组件的功能 a. 使用命令动态参数激活：虚拟机参数位子加载 `-Dspring.profiles.active=test b. 使用代码激活环境 12345678910111213141516171819/** * @Author: cuzz * @Date: 2018/9/25 10:59 * @Description: */public class IOCTestProfile &#123; @Test public void test01() &#123; // 1. 使用无参构造器创建一个applicationContext AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(); // 2. 设置要激活的环境 applicationContext.getEnvironment().setActiveProfiles("test"); // 3. 注册主配置类 applicationContext.register(MainConfigOfProfile.class); // 4. 启动刷新容器 applicationContext.refresh(); &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发（二）]]></title>
    <url>%2F2018%2F09%2F24%2FSpring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注解可以简化配置，提高效率 The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform. 声明周期@Bean指定初始化和销毁方法Bean的生命周期Bean的创建、初始化和销毁是由容器帮我们管理的 我们可以自定义初始化和销毁方法，容器在进行到当前生命周期的时候来调用我买自定义的初始化和销毁方法 构造（对象创建） ​ 单实例： 在容器启动的时候创建 ​ 多实例： 在每次获取的时候创建对象 指定初始化方法初始化：对象创建完成后，并赋值化，调用初始化方法 销毁：单实例是在容器关闭的时候销毁，多实例容器不会管理这个Bean，容器不会调用销毁方法 编写一个Car类 12345678910111213141516171819/** * @Author: cuzz * @Date: 2018/9/23 21:20 * @Description: */public class Car &#123; public Car () &#123; System.out.println("car constructor..."); &#125; public void init() &#123; System.out.println("car...init..."); &#125; public void destroy() &#123; System.out.println("car...destroy..."); &#125;&#125; 在xml中我们可以指定init-method和destroy-method方法，如 1&lt;bean id="car" class="com.cuzz.bean.Car" init-method="init" destroy-method="destroy"&gt;&lt;/bean&gt; 使用注解我们可以 1234567891011121314/** * @Author: cuzz * @Date: 2018/9/24 12:49 * @Description: 配置类 */@Configurationpublic class MainConfigOfLifecycle &#123; @Bean(initMethod = "init", destroyMethod = "destroy") public Car car() &#123; return new Car(); &#125;&#125; 测试 12345678910111213141516171819/** * @Author: cuzz * @Date: 2018/9/24 13:00 * @Description: */public class IOCTestLifeCycle &#123; @Test public void test01() &#123; // 创建ioc容器 AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfLifecycle.class); System.out.println("容器创建完成..."); // 关闭容器 System.out.println("---&gt;开始关闭容器"); applicationContext.close(); System.out.println("---&gt;已经关闭容器"); &#125;&#125; 可以看出先创建car，再调用init方法，在容器关闭时销毁实例 123456car constructor...car...init...容器创建完成...---&gt;开始关闭容器car...destroy...---&gt;已经关闭容器 在配置数据源的时候，有很多属性赋值，销毁的时候要把连接给断开 生命周期InitializingBean和DisposableBeanInitializingBean可以通过Bean实现InitializingBean来定义初始化逻辑，是设置好所有属性会调用afterPropertiesSet()方法 1234567891011121314public interface InitializingBean &#123; /** * Invoked by a BeanFactory after it has set all bean properties supplied * (and satisfied BeanFactoryAware and ApplicationContextAware). * &lt;p&gt;This method allows the bean instance to perform initialization only * possible when all bean properties have been set and to throw an * exception in the event of misconfiguration. * @throws Exception in the event of misconfiguration (such * as failure to set an essential property) or if initialization fails. */ void afterPropertiesSet() throws Exception;&#125; DisposableBean可以通过Bean实现DisposableBean来定义销毁逻辑，会调用destroy()方法 1234567891011public interface DisposableBean &#123; /** * Invoked by a BeanFactory on destruction of a singleton. * @throws Exception in case of shutdown errors. * Exceptions will get logged but not rethrown to allow * other beans to release their resources too. */ void destroy() throws Exception;&#125; 例子编写一个Cat类 1234567891011121314151617181920212223/** * @Author: cuzz * @Date: 2018/9/24 13:36 * @Description: */public class Cat implements InitializingBean, DisposableBean&#123; public Cat() &#123; System.out.println("cat constructor..."); &#125; @Override public void afterPropertiesSet() throws Exception &#123; System.out.println("cat...init..."); &#125; @Override public void destroy() throws Exception &#123; System.out.println("cat...destroy..."); &#125;&#125; 测试 123456cat constructor...cat...init...容器创建完成...---&gt;开始关闭容器cat...destroy...---&gt;已经关闭容器 生命周期@PostContruct和@PreDestroy注解@PostContruct在Bean创建完成并且属性赋值完成，来执行初始化 @PreDestroy在容器销毁Bean之前通知我们进行清理工作 编写一个Dog类，并把他注入到配置类中 123456789101112131415161718192021/** * @Author: cuzz * @Date: 2018/9/24 14:03 * @Description: */public class Dog &#123; public Dog() &#123; System.out.println("dog constructor..."); &#125; @PostConstruct public void postConstruct() &#123; System.out.println("post construct..."); &#125; @PreDestroy public void preDestroy() &#123; System.out.println("pre destroy..."); &#125;&#125; 测试结果 123456dog constructor...post construct...容器创建完成...---&gt;开始关闭容器pre destroy...---&gt;已经关闭容器 生命周期BeanPostProscessor后置处理器在Bean初始化前后做一些处理 1234567public interface BeanPostProcessor &#123; // 在初始化之前工作 Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException; // 在初始化之后工作 Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException;&#125; 编写一个MyBeanPostProcessor实现BeanPostProcessor接口 123456789101112131415161718/** * @Author: cuzz * @Date: 2018/9/24 14:21 * @Description: 后置处理器，初始化前后进行处理工作 */public class MyBeanPostProcessor implements BeanPostProcessor&#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("---&gt;postProcessBeforeInitialization..." + beanName +"==&gt;" + bean); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println("---&gt;postProcessAfterInitialization..." + beanName +"==&gt;" + bean); return bean; &#125;&#125; 测试 123456789101112---&gt;postProcessBeforeInitialization...org.springframework.context.event.internalEventListenerProcessor==&gt;org.springframework.context.event.EventListenerMethodProcessor@1dc67c2---&gt;postProcessAfterInitialization...org.springframework.context.event.internalEventListenerProcessor==&gt;org.springframework.context.event.EventListenerMethodProcessor@1dc67c2---&gt;postProcessBeforeInitialization...org.springframework.context.event.internalEventListenerFactory==&gt;org.springframework.context.event.DefaultEventListenerFactory@2bd765---&gt;postProcessAfterInitialization...org.springframework.context.event.internalEventListenerFactory==&gt;org.springframework.context.event.DefaultEventListenerFactory@2bd765cat constructor...---&gt;postProcessBeforeInitialization...cat==&gt;com.cuzz.bean.Cat@1d3b207cat...init...---&gt;postProcessAfterInitialization...cat==&gt;com.cuzz.bean.Cat@1d3b207容器创建完成...---&gt;开始关闭容器cat...destroy...---&gt;已经关闭容器 在实例创建之前后创建之后会被执行 生命周期BeanPostProcessor原理通过debug到populateBean，先给属性赋值在执行initializeBean方法 123456try &#123; populateBean(beanName, mbd, instanceWrapper); if (exposedObject != null) &#123; exposedObject = initializeBean(beanName, exposedObject, mbd); &#125;&#125; initializeBean方法时， 1234567891011121314151617181920protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; Object wrappedBean = bean; if (mbd == null || !mbd.isSynthetic()) &#123; // 执行before方法 wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; ... try &#123; // 执行初始化 invokeInitMethods(beanName, wrappedBean, mbd); &#125; if (mbd == null || !mbd.isSynthetic()) &#123; // 执行after方法 wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean;&#125; Spring底层对BeanPostProcessor的使用： Bean赋值、注入其他组件、@Autowired、生命周期注解功能、@Async等等都使用到了BeanPostProcessor这个接口的实现类，很重要]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring注解驱动开发（一）]]></title>
    <url>%2F2018%2F09%2F23%2FSpring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[注解可以简化配置，提高效率 The Spring Framework provides a comprehensive programming and configuration model for modern Java-based enterprise applications - on any kind of deployment platform. 组件注册@Configuration和@Bean的注入使用xml方式我们一起注入一个bean使用xml来配置 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;bean id="person" class="com.cuzz.bean.Person"&gt; &lt;property name="name" value="cuzz"&gt;&lt;/property&gt; &lt;property name="age" value="18"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 我可以使用ClassPathXmlApplicationContext来获取 12345678910111213/** * @Author: cuzz * @Date: 2018/9/23 10:48 * @Description: */public class MainTest &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("bean.xml"); // 用id获取 Person bean = (Person) applicationContext.getBean("person"); System.out.println(bean); &#125;&#125; 输出Person(name=cuzz, age=18) 注解编写一个配置类 1234567891011121314/** * @Author: cuzz * @Date: 2018/9/23 10:55 * @Description: 配置类 */@Configuration // 告诉Spring这是一个配置类public class MainConfig &#123; // 给容器中注册一个Bean,类型为返回值类型,id默认用方法名 // 也可以指定id @Bean(value = "person01") public Person person() &#123; return new Person("vhsj", 16); &#125;&#125; 可以通过AnnotationConfigApplicationContext来获取，并且获取id 1234567891011121314151617/** * @Author: cuzz * @Date: 2018/9/23 10:59 * @Description: */public class MainTest &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext context = new AnnotationConfigApplicationContext(MainConfig.class); Person person = (Person) context.getBean(Person.class); System.out.println(person); String[] names = context.getBeanNamesForType(Person.class); for (String name: names) &#123; System.out.println(name); &#125; &#125;&#125; 输出 12Person(name=vhsj, age=16)person01 由于给bean添加一个一个value，可以改变默认id 组件注册@ComponentScan使用xml只要标注了注解就能扫描到如:@Controller @Service @Repository @component 1&lt;context:component-scan base-package="com.cuzz"&gt;&lt;/context:component-scan&gt; 注解在配置类中添加 12345678910/** * @Author: cuzz * @Date: 2018/9/23 10:55 * @Description: 配置类 */@Configuration // 告诉Spring这是一个配置类@ComponentScan(value = "com.cuzz") // 指定包public class MainConfig &#123; &#125; 添加controller、service等 测试 1234567891011121314151617/** * @Author: cuzz * @Date: 2018/9/23 13:03 * @Description: */public class IOCTest &#123; @Test public void test01() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig.class); // 获取所有bean定义的名字 String[] beanNames = applicationContext.getBeanDefinitionNames(); for (String name : beanNames) &#123; System.out.println(name); &#125; &#125;&#125; 输出结果 1234567891011org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfigbookControllerbookDaobookServiceperson01 可以看出添加@Controller @Service @Repository @component注解的都可以扫描到 还可以指定添加某些类，和排除某些类，进入ComponentScan注解中有下面两个方法 12345ComponentScan.Filter[] includeFilters() default &#123;&#125;;ComponentScan.Filter[] excludeFilters() default &#123;&#125;;includeFilters = Filter[] ：指定扫描的时候只需要包含哪些组件excludeFilters = Filter[] ：指定扫描的时候按照什么规则排除那些组件 配置类，排除Controller 1234567@Configuration // 告诉Spring这是一个配置类@ComponentScan(value = "com.cuzz", excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION, classes = &#123;Controller.class&#125;)&#125;)public class MainConfig &#123;&#125; 运行测试方法，可以得出没有Controller类的 123456789org.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfigbookDaobookServiceperson01 自定义TypeFilter指定过滤规则第一和第二比较常用 12345FilterType.ANNOTATION：按照注解FilterType.ASSIGNABLE_TYPE：按照给定的类型；FilterType.ASPECTJ：使用ASPECTJ表达式FilterType.REGEX：使用正则指定FilterType.CUSTOM：使用自定义规则 新建一个MyTypeFilte类实现TypeFilter接口 1234567891011121314151617181920212223242526272829/** * @Author: cuzz * @Date: 2018/9/23 15:03 * @Description: */public class MyTypeFilter implements TypeFilter&#123; /** * metadataReader：读取到的当前正在扫描的类的信息 * metadataReaderFactory:可以获取到其他任何类信息的 */ @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException &#123; //获取当前类注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取当前正在扫描的类的类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取当前类资源（类的路径） Resource resource = metadataReader.getResource(); String className = classMetadata.getClassName(); System.out.println("---&gt;"+className); // 这些类名中包含er就返回true if(className.contains("er"))&#123; return true; &#125; return false; &#125;&#125; 使用自定义注解记得需要关闭默认过滤器useDefaultFilters = false 123456789101112131415161718/** * @Author: cuzz * @Date: 2018/9/23 10:55 * @Description: 配置类 */@Configuration @ComponentScan(value = "com.cuzz", includeFilters = @ComponentScan.Filter(type = FilterType.CUSTOM, classes = MyTypeFilter.class), useDefaultFilters = false)public class MainConfig &#123; // 给容器中注册一个Bean,类型为返回值类型,id默认用方法名 // 也可以指定id @Bean(value = "person01") public Person person() &#123; return new Person("vhsj", 16); &#125;&#125; 测试12345678910111213141516171819202122---&gt;com.cuzz.AppTest---&gt;com.cuzz.bean.MainTest---&gt;com.cuzz.config.IOCTest---&gt;com.cuzz.config.MainTest---&gt;com.cuzz.App---&gt;com.cuzz.bean.Person---&gt;com.cuzz.config.MyTypeFilter---&gt;com.cuzz.controller.BookController---&gt;com.cuzz.dao.BookDao---&gt;com.cuzz.sevice.BookServiceorg.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfig // 不是扫描的 person // 这个是在bean中myTypeFilter // 有erbookController // 有erbookService // 有erperson01 // 这个是在bean中 组件注册@Scope设置作用域Spring的bean默认是单例的123456789101112@Testpublic void test02() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class); // 获取所有bean定义的名字 String[] beanNames = applicationContext.getBeanDefinitionNames(); for (String name : beanNames) &#123; System.out.println(name); &#125; Object bean = applicationContext.getBean("person"); Object bean2 = applicationContext.getBean("person"); System.out.println(bean == bean2); // 输出true&#125; Scope的四个范围1234ConfigurableBeanFactory#SCOPE_PROTOTYPE // 多实例 每次获取时创建对象，不会放在ioc容器中ConfigurableBeanFactory#SCOPE_SINGLETON // 单实例 ioc容器启动是创建对象，以后从容器中获取WebApplicationContext#SCOPE_REQUEST // web同一次请求创建一个实例WebApplicationContext#SCOPE_SESSION // web同一个session创建一个实例 如果我们把Scope修改 1234567891011121314/** * @Author: cuzz * @Date: 2018/9/23 15:40 * @Description: */@Configurationpublic class MainConfig2 &#123; @Scope(value = "prototype") @Bean public Person person() &#123; return new Person("vhuj", 25); &#125;&#125; 则测试输出false 组件注册@Lazy-bean懒加载懒加载懒加载的是针对单实例Bean，默认是在容器启动的时创建的，我们可以设置懒加载容器启动是不创建对象，在第一次使用（获取）Bean创建对象，并初始化 测试先给添加一个@Lazy注解 12345678910@Configurationpublic class MainConfig2 &#123; @Lazy @Bean public Person person() &#123; System.out.println("给容器中添加Person..."); return new Person("vhuj", 25); &#125;&#125; 编写一个测试方法 1234567@Testpublic void test03() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class); System.out.println("ioc容器创建完成..."); Object bean = applicationContext.getBean("person");&#125; 输出 12ioc容器创建完成...给容器中添加Person... 添加一个@Lazy是在第一次获取时，创建对象，以后获取就不需要创建了，直接从容器中获取，因为它是单实例 组件注册@Conditional按条件注册按照一定条件进行判断，满足条件给容器中注册Bean 编写自己的Condition类如果系统是windows，给容器中注入”bill” 如果系统是linux，给容器中注入”linus” 编写WindowCondition类并重写matches方法 12345678910111213141516171819202122/** * @Author: cuzz * @Date: 2018/9/23 20:30 * @Description: 判断是否是windows */ public class WindowCondition implements Condition&#123; /** * @param context 判断条件 * @param metadata 注释信息 * @return boolean */ @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; Environment environment = context.getEnvironment(); String property = environment.getProperty("os.name"); if (property.contains("Windows")) &#123; return true; &#125; return false; &#125; &#125; context有以下方法 12345678// 能获取ioc使用的beanfactoryConfigurableListableBeanFactory beanFactory = context.getBeanFactory();// 能获取到类加载器ClassLoader classLoader = context.getClassLoader();// 获取到环境变量Environment environment = context.getEnvironment();// 获取到Bean定义的注册类BeanDefinitionRegistry registry = context.getRegistry(); 配置类添加Bean添加Condition条件 123456789101112131415@Configurationpublic class MainConfig2 &#123; @Conditional(&#123;WindowCondition.class&#125;) @Bean("bill") public Person person01() &#123; return new Person("Bill Gates", 60); &#125; @Conditional(&#123;LinuxCondition.class&#125;) @Bean("linux") public Person person02() &#123; return new Person("linus", 45); &#125;&#125; 测试12345678910111213141516171819@Testpublic void test04() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class); // 获取环境变量 ConfigurableEnvironment environment = applicationContext.getEnvironment(); String property = environment.getProperty("os.name"); System.out.println(property); // 获取所有bean定义的名字 String[] beanNames = applicationContext.getBeanDefinitionNames(); for (String name : beanNames) &#123; System.out.println(name); &#125; // key 是id Map&lt;String, Person&gt; map = applicationContext.getBeansOfType(Person.class); System.out.println(map);&#125; 发现只有“bill”这个Bean被注入 12345678910Windows 7org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfig2bill&#123;bill=Person(name=Bill Gates, age=60)&#125; 组件注册@Improt给容器中快速导入一个组件@Import导入@Import可以导入第三方包，或则自己写的类，比较方便，Id默认为全类名 比如我们新建一个类 1234567/** * @Author: cuzz * @Date: 2018/9/23 21:08 * @Description: */public class Color &#123;&#125; 我们只需要在配置类添加一个@Import把这个类导入 123@Import(&#123;Color.class&#125;)@Configurationpublic class MainConfig2 &#123;&#125; ImportSelector接口导入的选择器返回导入组件需要的全类名的数组 123456789public interface ImportSelector &#123; /** * Select and return the names of which class(es) should be imported based on * the &#123;@link AnnotationMetadata&#125; of the importing @&#123;@link Configuration&#125; class. */ String[] selectImports(AnnotationMetadata importingClassMetadata);&#125; 编写一个MyImportSelector类实现ImportSelector接口 1234567891011121314/** * @Author: cuzz * @Date: 2018/9/23 21:15 * @Description: */public class MyImportSelector implements ImportSelector&#123; // 返回值就导入容器组件的全类名 // AnnotationMetadata:当前类标注的@Import注解类的所有注解信息 @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[] &#123;"com.cuzz.bean.Car"&#125;; &#125;&#125; 在配置类中，通过@Import导入 12345678/** * @Author: cuzz * @Date: 2018/9/23 15:40 * @Description: 配置类 */@Import(&#123;Color.class, MyImportSelector.class&#125;)@Configurationpublic class MainConfig2 &#123;&#125; 测试结果，com.cuzz.bean.Car注入了 123456789org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfig2com.cuzz.bean.Colorcom.cuzz.bean.Car ImportBeanDefinitionRegistrar接口选择器123456789101112131415public interface ImportBeanDefinitionRegistrar &#123; /** * Register bean definitions as necessary based on the given annotation metadata of * the importing &#123;@code @Configuration&#125; class. * &lt;p&gt;Note that &#123;@link BeanDefinitionRegistryPostProcessor&#125; types may &lt;em&gt;not&lt;/em&gt; be * registered here, due to lifecycle constraints related to &#123;@code @Configuration&#125; * class processing. * @param importingClassMetadata annotation metadata of the importing class * @param registry current bean definition registry */ public void registerBeanDefinitions( AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry);&#125; 编写一个ImportBeanDefinitionRegistrar实现类 123456789101112131415161718192021222324/** * @Author: cuzz * @Date: 2018/9/23 21:29 * @Description: */public class MyImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; /** * @param importingClassMetadata 当前类的注解信息 * @param registry 注册类 */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; // 查询容器 boolean b = registry.containsBeanDefinition("com.cuzz.bean.Car"); // 如果有car, 注册一个汽油类 if (b == true) &#123; // 需要添加一个bean的定义信息 RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(Petrol.class); // 注册一个bean, 指定bean名 registry.registerBeanDefinition("petrol", rootBeanDefinition); &#125; &#125;&#125; 配置类 12345678/** * @Author: cuzz * @Date: 2018/9/23 15:40 * @Description: 配置类 */@Import(&#123;Color.class, MyImportSelector.class, MyImportBeanDefinitionRegistrar.class&#125;)@Configurationpublic class MainConfig2 &#123;&#125; 测试结果，出现了petrol 12345678910org.springframework.context.annotation.internalConfigurationAnnotationProcessororg.springframework.context.annotation.internalAutowiredAnnotationProcessororg.springframework.context.annotation.internalRequiredAnnotationProcessororg.springframework.context.annotation.internalCommonAnnotationProcessororg.springframework.context.event.internalEventListenerProcessororg.springframework.context.event.internalEventListenerFactorymainConfig2com.cuzz.bean.Colorcom.cuzz.bean.Car petrol 组件注册使用FactoryBean注册组件编写一个ColorFactoryBean类 12345678910111213141516171819202122/** * @Author: cuzz * @Date: 2018/9/23 21:55 * @Description: Spring定义的工厂Bean */public class ColorFactoryBean implements FactoryBean&lt;Color&gt; &#123; // 返回一个Color对象 @Override public Color getObject() throws Exception &#123; return new Color(); &#125; @Override public Class&lt;?&gt; getObjectType() &#123; return Color.class; &#125; // 是否为单例 @Override public boolean isSingleton() &#123; return true; &#125;&#125; 注入到容器中 1234@Beanpublic ColorFactoryBean colorFactoryBean() &#123; return new ColorFactoryBean();&#125; 测试 12345678@Testpublic void test05() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class); Object bean = applicationContext.getBean("colorFactoryBean"); // 工厂bean调用的是getClass()方法 System.out.println("colorFactoryBean的类型是: " + bean.getClass());&#125; 输出，发现此时的bean调用的方法是getObjectType方法 1colorFactoryBean的类型是: class com.cuzz.bean.Color 如果需要获取BeanFactory本身，可以在id前面加一个“&amp;”标识 1234567891011@Testpublic void test05() &#123; AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfig2.class); Object bean = applicationContext.getBean("colorFactoryBean"); // 工厂bean调用的是getClass()方法 System.out.println("colorFactoryBean的类型是: " + bean.getClass()); Object bean2 = applicationContext.getBean("&amp;colorFactoryBean"); // 工厂bean调用的是getClass()方法 System.out.println("colorFactoryBean的类型是: " + bean2.getClass());&#125; 此时输出 12colorFactoryBean的类型是: class com.cuzz.bean.ColorcolorFactoryBean的类型是: class com.cuzz.bean.ColorFactoryBean]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习结束篇]]></title>
    <url>%2F2018%2F09%2F10%2F%E5%AE%9E%E4%B9%A0%E7%BB%93%E6%9D%9F%E7%AF%87%2F</url>
    <content type="text"><![CDATA[常怀感恩的心 昨天提交了离职信，完了成了一系列辞职手续 总经理找我聊了一会，谈了谈人生规划，很感谢他能给予我建议，也希望我毕业后能再回公司 先是和我师父告别，师父先是询问了我的情况，后来把我带到公司楼下聊了一会，询问了我一下规划，总结一下他给我提的意见 毕业刚出去，先去一线互联网城市，首先选择大厂，前三年不要太在意工资，主要是眼界 不要本末倒置，现在不要天天去背那些面试题和刷题，当前重要的是知识的沉淀，把公司用到的中间件，好好研究一下，不要只是看看，而要动手去搭建 不是科班出身的，身边缺少这种技术的氛围，平时多努力努力，多认识认识朋友 学校有项目，即使没报酬，也要去参与，多积累经验 然后是跟外卖组的人告别，感谢组长CJG，小师兄HL，以及CWZ，BW，NZ这些人对我的帮助，这一段时间在这里学习到了许多，感谢这些人 HL小师兄，也单独和我聊了聊，询问了我的情况，也给我一些工作经验，不能被人影响到自己，平时做事认真一点，不要担心犯错等 小师兄还送我下楼，最后小师兄拥抱一个就告别了 走到地铁站发现身上还有一张48的的士票还没报，又回公司了 然后又跟同事告别了一波]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实习记录]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%AE%9E%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[实习给了我很大信心 实习一段时间了，说说最近的感受吧 我是转行的，现在是一名材料计算的研究生，为什么要说材料计算呢，我是希望去面试的时候至少有计算这两个字，HR至少会觉得我跟计算机有点靠边，减少被HR给过滤掉 学java大概半年了，把java基础学完，在慕课网上找了一个实战课程，这是我部署上线的网站（还没写完），就去找实习了 由于是暑假，老师管的也没那么严，不用去实验室 刚开始的时候，不是很自信，在拉钩、Boss直聘和智联投简历，大概投了100来份，收到5-6个面试，武汉的夏天真的热，最气愤的是，遇到一两个培训机构，浪费时间，后来去面试都会在网上先查查，刚开始面试的都是一些小公司，小公司基本都是问你项目，然而我项目经验又不多，基本上都是回去等消息 接着面试了另一家小公司，公司的老板和我是一个学校的，跟我聊的也很不错，本来打算在这里实习的，后来收到良品的实习offer，就没去了，也跟这位学长沟通了，他也支持我 后来良品铺子打电话给我，让我去面试，良品铺子在武汉来说算比较大的企业，面试我的是一名架构师，大公司比较喜欢问基础，我对java基础掌握的还不错，答的也还可以，得到了他的认可，后面的面试就很轻松，他还主动要帮我加工资，后来我就认他当我师傅，真的很好，很感谢他 他还夸我基础挺好的，后来被我分配到外卖组，也是比较好的组，属于电商，所用的技术也是比较新 来组里又碰到了同一个学校的小师兄还是老乡，真是太幸运了，还有我组长，人都超级nice，也从他们那里学到很多 平时把需求做完，自己看看博客，看看书，学学公司所有的框架，发现公司用的框架很多都是阿里的，比起以前在工厂实习简直太爽了 实习这一段时间自己的提升真的很多，所以有机会一定要出去实习，平时我们部门还会组织技术分享，也可以增加自己的眼界，平时遇到问题，也可以快速寻求帮助，快速解决问题，知道一个公司是怎么开发产品的 最后收获最多的还是自信，刚开始觉得自己不是科班的有点不太自信，实习汇报完后小师兄说我学习能力比较强，上手快，不用让他操心，我的组长对我的评价说我达到2年的水平，哈哈，真的把我高兴坏了，我们的组长的boss也给我的评价也不错，我不是来炫耀这些，只是这些肯定给我很大的信心，让我在转行的道路上越走越有勇气，最后还是要靠自己努力，平时多写写代码，多看看书 最后感谢在我转行时所遇见的这些人。]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>实习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery学习]]></title>
    <url>%2F2018%2F06%2F24%2FjQuery%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[jQuery是一个快速、简洁的JavaScript框架 jQuery设计的宗旨是“write Less，Do More” 初识jQueryjQuery是一个快速、简洁的JavaScript框架，是继Prototype之后又一个优秀的JavaScript代码库（或JavaScript框架）。jQuery设计的宗旨是“write Less，Do More”，即倡导写更少的代码，做更多的事情。它封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互 总结来说为下面三点： jQuery 是一个 JavaScript jQuery 极大地简化了 JavaScript 编程 jQuery 很容易学习 使用jQuery编写HelloWorld 下载jQuery库 引入jQuery 12345&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;01-初识jQuery&lt;/title&gt; &lt;script src=&quot;js/jquery-1.11.3/jquery.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 编写helloWorld 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;02-jQuery-HelloWorld&lt;/title&gt; &lt;script src=&quot;js/jquery-1.11.3/jquery.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 原生js的固定写法 window.onload = function(ev) &#123; &#125;; // jQuery的固定写法 $(document).ready(function () &#123; alert(&quot;Hello World&quot;); &#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; jQuery和js入口函数的区别12345678910111213141516171819&lt;script&gt; window.onload = function (ev) &#123; // 通过原生的js入口函数可以拿到Dom元素 var img = document.getElementsByTagName(&quot;img&quot;)[0]; console.log(img); // 通过原生的js入口函数可以拿到dom元素的宽高 var width = window.getComputedStyle(img).width; console.log(width); &#125;; $(document).ready(function () &#123; // 通过jQuery入口函数可以拿到Dom元素 var $img = $(&quot;img&quot;)[0]; console.log($img); // 通过jQuery入口函数不能拿到dom元素的宽高 var $width = $img.width(); console.log($width); &#125;);&lt;/script&gt; 区别: 原生jQuery入口函数的加载模式不同 原生js会等到dom加载完毕，并且图片也加载完毕才会执行 jQuery会等到dom加载完毕，但不会等到图片也加载完毕就会执行 12345678910111213141516&lt;script&gt; window.onload = function (ev) &#123; alert(&quot;hello cuzz&quot;); // 不会显示 &#125;; window.onload = function (ev) &#123; alert(&quot;hello cuxx&quot;); // 会显示 &#125;;&lt;/script&gt;&lt;script&gt; $(document).ready(function () &#123; alert(&quot;hello cuzz&quot;); // 会显示 &#125;); $(document).ready(function () &#123; alert(&quot;hello cuxx&quot;); // 会显示 &#125;);&lt;/script&gt; 区别： 多个window.onload只会执行一次, 后面的会覆盖前面的 多个$(document).ready()会执行多次,后面的不会覆盖前面的 原因：jQuery框架本质是一个闭包，每次执行我们都会给ready函数传递一个新的函数，不同函数内部的数据不会相互干扰 1234567891011&lt;script&gt; // 相当于这样写 var test1 = function () &#123; alert(&quot;hello cuzz&quot;); &#125; var test2 = function () &#123; alert(&quot;hello cuxx&quot;); &#125; $(document).ready(test1); $(document).ready(test2);&lt;/script&gt; 对比： window.onload $(document).ready() 执行时机 必须等待网页全部加载完毕(包括 图片等),然后再执行包裹代码 只需要等待网页中的DOM结构 加载完毕,就能执行包裹的代码 执行次数 只能执行一次,如果第二次,那么 第一次的执行会被覆盖 可以执行多次,第N次都不会被上 一次覆盖 简写方案 无 $(function () { }); jQuery的四种写法123456789101112131415161718&lt;script&gt; // 第一种写法 $(document).ready(function () &#123; alert(&quot;hello cuzz&quot;); &#125;); // 第二种写法 jQuery(document).ready(function () &#123; alert(&quot;hello cuzz&quot;); &#125;); // 第三种写法 $(function () &#123; alert(&quot;hello cuzz&quot;); &#125;); // 第四种写法 jQuery(function () &#123; alert(&quot;hello cuzz&quot;); &#125;);&lt;/script&gt; 推荐使用第三种写法 jQuery的核心函数 jQuery(callback)，当dom加载完成之后执行传入的回调函数 12345&lt;script&gt; $(function () &#123; alert(&quot;123&quot;); &#125;);&lt;/script&gt; jQuery([sel,[context]])，接收一个包含 CSS 选择器的字符串，然后用这个字符串去匹配一组元素,并包装成jQuery对象 1234567891011&lt;script&gt; $(function () &#123; // 利用jQuery获取的div,得到的是一个jQuery对象 var $box = $(&quot;div&quot;); console.log($box); // 利用原生js语法获取的div,得到的是一个js对象 var box = document.getElementsByTagName(&quot;div&quot;); console.log(box); &#125;);&lt;/script&gt; 原生JS对象和jQuery对象相互转换 jQuery(html, [ownerDoc]) 根据 HTML 标记字符串，动态创建DOM 元素123456789&lt;script&gt; $(function () &#123; var $eles = $(&quot;&lt;p&gt;我是span&lt;/p&gt;&lt;u&gt;我是u&lt;/u&gt;&quot;); // 无论是jQuery找到的还是创建的,我们最终拿到的永远都是jQuery对象 console.log($eles); // 将创建好的DOM元素添加到body中 $(&quot;body&quot;).append($eles); &#125;);&lt;/script&gt; jQuery的本质是一个伪数组，有0到length-1的属性 jQuery静态方法 静态方法 12345678910111213&lt;script&gt; // 定义一个类 function AClass() &#123; &#125;; // 给这个类添加一个静态方法 AClass.staticMethod = function () &#123; alert(&quot;staticMethod&quot;) &#125;; // 静态方法的调用 AClass.staticMethod();&lt;/script&gt; 实例方法 123456789101112131415&lt;script&gt; // 定义一个类 function AClass() &#123; &#125; // 给这个类添加一个实例方法 AClass.prototype.instanceMethod = function () &#123; alert(&quot;instanceMethod&quot;); &#125; // 实例方法的调用 var a = new AClass(); a.instanceMethod();&lt;/script&gt; 常用静态方法 $.each(object, [callback]) 1234567891011121314151617181920212223242526272829303132$(function () &#123; // 遍历数组 var arr = [1, 3, 5, 7, 9]; // 通过原生方法遍历数组 // 第一个回调函数参数是遍历到的元素 // 第二个回调函数参数是当前遍历的索引 // 返回值: 没有返回值 var res = arr.forEach(function (ele, idx) &#123; console.log(idx, ele); &#125;); console.log(res); // 通过jQuery静态方法遍历数组 // 第一个回调函数参数是当前遍历的索引 // 第二个回调函数参数是遍历到的元素 // 返回值: 被遍历的数组 var $res2 = $.each(arr, function (idx, ele) &#123; console.log(idx, ele); &#125;); console.log($res2); // 遍历对象 var obj = &#123;name: &quot;&quot;, age:&quot;33&quot;, gender:&quot;male&quot;&#125;; // js对象没有forEach方法,所以通过forin方法遍历对象 for(var key in obj)&#123; console.log(key, obj[key]); &#125; // 通过jQuery静态方法遍历对象 $.each(obj,function (key, value) &#123; console.log(key, value); &#125;);&#125;); $.holdReady(hold)，传入true或false来暂停或则恢复ready()事件 $.trim(str) 去掉字符串起始和结尾的空格 $.isArray(obj) 判断是否是数组 $.isFunction(obj)判断是否是函数 $.isWindow(obj)判断是否是window对象学习网站在网上，发现菜鸟教程比较详细，排版也比较好，不再更新jQuery]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python零基础入门笔记]]></title>
    <url>%2F2018%2F01%2F02%2FPython%E9%9B%B6%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[复习是为了更好的学习更新的知识。 学习python有一年多了，希望通过学习笔记来复习了，也能让后来者少走一点弯路。在课程笔记的同时加入了一部分自己的经验补充。 [√] 廖雪峰老师在慕课网的课程: Python入门 Python的初次体验python语言介绍全世界有几百种编程语言，但是流行的只有十几种，python就是其中一种。荷兰人龟叔于1989年圣诞节创立。 特点：优雅，明确，简单。 适合的领域： web网站和各种网络服务； 系统工具和脚本； 作为胶水语言把其他语言开发的模块包装起来方便使用。 Python是一门高级语言，所以不适合贴近硬件的代码: 比如驱动程序（首选C） 移动开发，有各自的语言，（objectC，swift/java） 游戏开发（首选C/C++）。 Python实际应用： YouTube，豆瓣，搜狐邮箱；Openstack开源云计算平台。Google，Yahoo，NASA。 语言之间的对比： C编译为机器码；JAVA编译为字节码；python为解释执行。 缺点： 运行慢，Python源码不能加密。 Python版本的选择博主建议选择安装环境篇的进阶版：2.7版本与3.x版本共存。 3.x版本建议选择Python 3.5.1 |Anaconda 4.1.0 (64-bit)以后如果要使用python进行TensorFlow windows版的配置可以省下时间。 windows下安装python参考：搭建Python开发环境 第一个python程序cmd下输入python。进入交互式环境。 命令行模式启动python:python 命令行模式执行python文件python 目录/xxx.py 命令行模式关闭python：exit() 注意：不要使用word，或者windows下自带的记事本来进行代码编写。 推荐使用： 轻量级：sublime Text 或 editplus 重量级(较大工程) : pycharm Professional 2.7版本专属： print &#39;hello,world!&#39; 3.x版本(2.7版本也可以正常运行)： print (&quot;hello,world!&quot;) Python变量和数据类型 讲解Python基本的数据类型.包括整数、浮点数、字符串和布尔类型，以及变量的概念和基本的数据运算。 数据类型整数在Python程序中，整数的表示方法和数学上的写法一模一样. 例如：1，100，-8080，0，等等。十六进制用0x前缀和0-9，a-f表示. 例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数: 因为按照科学记数法表示时，一个浮点数的小数点位置是可变的 比如，1.23x10^9和12.3x10^8是相等的。 浮点数可以用数学写法: 如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 知识点：python2与3不同整除 python2.7下：/ 和 // 都是整数除法。 例: 1/2结果为0.后面小数部分会直接去除掉。 python3.x下： / 为浮点数除法(如：1/2=0.5) //为整数除法(如: 1//2 = 0） 12345a = 1 b = 2print a+b#python2.7下想要浮点数除法就得使用类型转换。print float(a)/b 字符串字符串是以’’或””括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分. 因此，字符串’abc’只有a，b，c这3个字符。 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为 True，and运算结果才是 True。 or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。 not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。 空值空值是Python里一个特殊的值，用None表示。 None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 编程小任务： 计算十进制整数 45678 和十六进制整数 0x12fd2 之和。 请用字符串表示出Learn Python in imooc。 请计算以下表达式的布尔值（注意==表示判断是否相等）：12100 &lt; 990xff == 255 题目答案： 1234print 45678+0x12fd2print "Learn Python in imooc" print 100&lt;99 print 0xff == 255 运行结果： 1234123456Learn Python in imoocFalseTrue print语句print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下： 1print 'hello, world' 注意： 当我们在Python交互式环境下编写代码时，&gt;&gt;&gt;是Python解释器的提示符，不是代码的一部分。 当我们在文本编辑器中编写代码时，千万不要自己添加 &gt;&gt;&gt;。 print语句也可以跟上多个字符串，用逗号,隔开，就可以连成一串输出： 1print 'The quick brown fox', 'jumps over', 'the lazy dog' 运行结果： 1The quick brown fox jumps over the lazy dog print会依次打印每个字符串，知识点：遇到逗号,会输出一个空格. print也可以打印整数，或者计算结果： 1234&gt;&gt;&gt; print 300300 #运行结果&gt;&gt;&gt; print 100 + 200300 #运行结果 漂亮做法： 12&gt;&gt;&gt; print '100 + 200 =', 100 + 200100 + 200 = 300 #运行结果 注意: 对于100 + 200，Python解释器自动计算出结果300.但是，’100 + 200 =’是字符串而非数学公式，Python把它视为字符串. 编程任务：请用两种方式打印出 hello, python.实现代码： 123#input codeprint 'hello, python.'print 'hello,','python.' 运行结果： 12hello, python.hello, python. 注释Python的注释以#开头，后面的文字直到行尾都算注释 12345# 这一行全部都是注释...print 'hello' # 这也是注释# 暂时不想运行下面一行代码:# print 'hello, python.' 注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉： 编程任务:将代码编辑器中的 “print ‘hello’” 语句修改成注释语句 实现代码： 1# print 'hello' 注释：多行注释1234'''下面是一行被注释代码下面是两行被注释代码''' 什么是变量在Python中，变量的概念基本上和初中代数的方程变量是一致的。 例如，对于方程式y=x*x ，x就是变量。 当x=2时，计算结果是4。当x=5时，计算结果是25。 只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 在Python程序中，变量是用一个变量名表示。 知识点：变量名必须是大小写英文、数字和下划线 _ 的组合，且不能用数字开头。比如： 12a = 1t_007 = 'T007' 变量a是一个整数。变量t_007是一个字符串。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： 1234a = 123 # a是整数print aa = 'imooc' # a变为字符串print a 知识点: 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）： 123//这些是java代码int a = 123; // a是整数类型变量a = "mooc"; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。请不要把赋值语句的等号等同于数学的等号。比如下面的代码： 12x = 10x = x + 2 如果从数学上理解x = x + 2那无论如何是不成立的. 在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 最后，知识点: 理解变量在计算机内存中的表示也非常重要。当我们写：a = ‘ABC’时，Python解释器干了两件事情： 在内存中创建了一个’ABC’的字符串； 在内存中创建了一个名为a的变量，并把它指向’ABC’。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码： 1234a = 'ABC'b = aa = 'XYZ'print b 最后一行打印出变量b的内容到底是’ABC’呢还是’XYZ’？如果从数学意义上理解，就会错误地得出b和a相同，也应该是’XYZ’，但实际上b的值是’ABC’，让我们一行一行地执行代码，就可以看到到底发生了什么事： 执行a = &#39;ABC&#39;，解释器创建了字符串 &#39;ABC&#39;和变量 a，并把a指向 &#39;ABC&#39;： 执行b = a，解释器创建了变量 b，并把b指向 a 指向的字符串&#39;ABC&#39;： 执行a = &#39;XYZ&#39;，解释器创建了字符串&#39;XYZ&#39;，并把a的指向改为’XYZ’，但b并没有更改： 所以，最后打印变量b的结果自然是’ABC’了。 编程任务： 等差数列可以定义为每一项与它的前一项的差等于一个常数，可以用变量 x1 表示等差数列的第一项，用 d 表示公差，请计算数列 1 4 7 10 13 16 19 … 前 100 项的和。 实现代码: 1234567x1 = 1d = 3n = 100x100 = x1+(100-1)*ds2 = (x1+x100)*100/2s = n*x1+n*(n-1)*d/2print s,s2 等差数列公式： （首项+尾项）*项数/2 项数*首项+项数*(项数-1)*公差/2 运行结果： 114950 14950 定义字符串字符串可以用&#39;&#39;或者&quot;&quot;括起来表示。 如果字符串本身包含&#39;怎么办？比如我们要表示字符串 I&#39;m OK，这时，可以用&quot; &quot;括起来表示： 12"I'm OK"'Learn "Python" in imooc' 类似的，知识点: 如果字符串包含&quot;，我们就可以用&#39; &#39;括起来表示： 如果字符串既包含&#39;又包含&quot;怎么办？ 知识点：转义 这个时候，就需要对字符串的某些特殊字符进行转义，Python字符串用\进行转义。 要表示字符串 Bob said &quot;I&#39;m OK&quot;.由于 &#39; 和&quot;会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为 12'Bob said \"I\'m OK\".'# 在要保留原状的字符串前面加上右斜杠 注意：转义字符 \不计入字符串的内容中。 常用的转义字符还有： \n表示换行 \t 表示一个制表符 \\ 表示 \ 字符本身 编程任务： 请将下面两行内容用Python的字符串表示并打印出来： 12 Python was started in 1989 by &quot;Guido&quot;. Python is free and easy to learn. 12s = 'Python was started in 1989 by"Guido".\nPython is free and easy to learn.'print s raw字符串与多行字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如： 1r'\(~_~)/ \(~_~)/' 解释： 这个例子举得不是很好。可以看出raw加上之后。可能产生误会的\被修改为\\(\\ 表示 \ 字符本身) 不加上r 只有\和(并没有合成转义字符。 加上r。\需要被转义，经过转义后显示出来还是自己。 知识点: 个人小题(r的强大作用) 上图效果可以看出r的强大作用。 但是r&#39;我是一段字符&#39;表示法不能表示多行字符串(r&#39;&#39;&#39;一段字符&#39;&#39;&#39;)，也不能表示包含&#39;和 &quot;的字符串（为什么？） 因为如果r&#39;mtian&#39;yan&#39; r遇到左边第一个&#39;,会继续往后找闭合的标志&#39;然后找到mtian的地方。它任务结束了。代码继续往下执行。当扫到yan这里他就会报错。 ???(更深层待续) 或者r&quot;mtian&quot;yan&quot; 或导致r提前结束掉。后面的就无法继续匹配到对应的。 知识点: 多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： 12345'''Line 1Line 2Line 3'''#上面这个字符串的表示方法和下面的是完全一样的：'Line 1\nLine 2\nLine 3' 还可以在多行字符串前面添加 r ，把这个多行字符串也变成一个raw字符串： 123r'''Python is created by "Guido".It is free and easy to learn.Let's start learn Python in imooc!''' 编程任务：请把下面的字符串用r&#39;&#39;&#39;...&#39;&#39;&#39;的形式改写，并用print打印出来： 1&apos;\&quot;To be, or not to be\&quot;: that is the question.\nWhether it\&apos;s nobler in the mind to suffer.&apos; 12print r'''"To be,or not to be":that is the question.Whether it's nobler in the mind to suffer.''' 知识点: Unicode字符串字符串还有一个编码问题。 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。 如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。 因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。 Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： 123print u'中文'中文注意: 不加 u ，中文就不能正常显示。(这个应该是很早版本才会。笔者现在已经无法复现) 转载: http://blog.csdn.net/lxdcyh/article/details/4018054 字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码decode成unicode，再从unicode编码encode成另一种编码。 decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode(&#39;gb2312&#39;)，表示将gb2312编码的字符串str1转换成unicode编码。 encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘gb2312’)，表示将unicode编码的字符串str2转换成gb2312编码 代码中字符串的默认编码与代码文件本身的编码一致。 如：s=’中文’ 如果是在utf8的文件中，该字符串就是utf8编码，如果是在gb2312的文件中，则其编码为gb2312。这种情况下，要进行编码转换，都需要先用decode方法将其转换成unicode编码，再使用encode方法将其转换成其他编码。通常，在没有指定特定的编码方式时，都是使用的系统默认编码创建的代码文件 如果字符串是这样定义：s=u’中文’ 则该字符串的编码就被指定为unicode了，即python的内部编码，而与代码文件本身的编码无关。因此，对于这种情况做编码转换，只需要直接使用encode方法将其转换成指定编码即可。 如果一个字符串已经是unicode了，再进行解码则将出错，因此通常要对其编码方式是否为unicode进行判断： 12isinstance(s, unicode) #用来判断是否为unicode 用非unicode编码形式的str来encode会报错 如何获得系统的默认编码？ 1234#!/usr/bin/env python#coding=utf-8import sysprint sys.getdefaultencoding() 该段程序在Win10(1079)上输出为：ascii 在某些IDE中，字符串的输出总是出现乱码，甚至错误，其实是由于IDE的结果输出控制台自身不能显示字符串的编码，而不是程序本身的问题。 如在UliPad(注:UliPad是wxPython的动力，导向和灵活的编程器)中运行如下代码： 12s=u&quot;中文&quot;print s 会提示：UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-1: ordinal not in range(128)。这是因为UliPad在控制台信息输出窗口是按照ascii编码输出的（系统的默认编码是ascii），而上面代码中的字符串是Unicode编码的，所以输出时产生了错误。 将最后一句改为：print s.encode(&#39;gb2312&#39;) 则能正确输出“中文”两个字。 若最后一句改为：print s.encode(&#39;utf8&#39;) 则输出：/xe4/xb8/xad/xe6/x96/x87，这是控制台信息输出窗口按照ascii编码输出utf8编码的字符串的结果。 unicode(str,&#39;gb2312&#39;)与str.decode(&#39;gb2312&#39;)是一样的，都是将gb2312编码的str转为unicode编码 使用str.__class__可以查看str的编码形式为str类型。 window默认编码gbk；linux默认编码utf8 原理说了半天，最后来个包治百病的吧：(天涯)：下面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python #coding=utf-8def getCoding(strInput): ''' 获取编码格式 ''' if isinstance(strInput, unicode): return "unicode" try: strInput.decode("utf8") return 'utf8' except: pass try: strInput.decode("gbk") return 'gbk' except: pass def tran2UTF8(strInput): ''' 转化为utf8格式 ''' strCodingFmt = getCoding(strInput) if strCodingFmt == "utf8": return strInput elif strCodingFmt == "unicode": return strInput.encode("utf8") elif strCodingFmt == "gbk": return strInput.decode("gbk").encode("utf8")def tran2GBK(strInput): ''' 转化为gbk格式 ''' strCodingFmt = getCoding(strInput) if strCodingFmt == "gbk": return strInput elif strCodingFmt == "unicode": return strInput.encode("gbk") elif strCodingFmt == "utf8": return strInput.decode("utf8").encode("gbk")s = "中文"if isinstance(s, unicode): #s=u"中文" print s.encode('gb2312') print "我是Unicode编码的"elif getCoding(s) == "utf8": #s="中文" print s.decode('utf-8').encode('gb2312') print "我是utf-8编码的"else: print s.decode('gbk').encode('gbk') print "我是gbk编码的" 上图结果一：以utf-8格式保存的py文件。图二：以ascii格式保存的py文件。 编码检测包 chardet 知识点：因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码 插入数据库报错的解决方案:UnicodeDecodeError: ‘ascii’ codec can’t decode byte 123import sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;) Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效： 转义： 1234567891011u'中文\n日文\n韩文'#多行：u'''第一行第二行'''#raw+多行：ur'''Python的Unicode字符串支持"中文","日文","韩文"等多种语言''' 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释 1234# -*- coding: utf-8 -*-#简洁版#coding=utf-8 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。 编程任务：用多行Unicode字符串表示下面的唐诗并打印： 静夜思 床前明月光，疑是地上霜。举头望明月，低头思故乡。 知识点: https://www.python.org/dev/peps/pep-0263/ python定义文件编码到底用哪种？ 12345# coding=&lt;encoding name&gt; #!/usr/bin/python# -*- coding: &lt;encoding name&gt; -*-#!/usr/bin/python# vim: set fileencoding=&lt;encoding name&gt; : 这些都可以只要第一二行能满足如下正则表达式 1^[ \t\v]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+) 12345678910# -*- coding: utf-8 -*-# This Python file uses the following encoding: utf-8# 花式标明print '''静夜思床前明月光，疑是地上霜。举头望明月，低头思故乡。''' 如果不标明文件编码或找不到。python会默认你是ASCII 整数和浮点数Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。 基本的运算： 1231 + 2 + 3 # ==&gt; 64 * 5 - 6 # ==&gt; 147.5 / 8 + 2.1 # ==&gt; 3.0375 使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层： 12(1 + 2) * 3 # ==&gt; 9(2.2 + 3.3) / (1.5 * (9 - 0.3)) # ==&gt; 0.42145593869731807 和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数： 121 + 2 # ==&gt; 整数 31.0 + 2.0 # ==&gt; 浮点数 3.0 但是整数和浮点数混合运算的结果就变成浮点数了： 11 + 2.0 # ==&gt; 浮点数 3.0 为什么要区分整数运算和浮点数运算呢？ 这是因为整数运算的结果永远是精确的，而浮点数运算的结果不一定精确，因为计算机内存再大，也无法精确表示出无限循环小数，比如 0.1 换成二进制表示就是无限循环小数。 那整数的除法运算遇到除不尽的时候，结果难道不是浮点数吗？我们来试一下： 111 / 4 # ==&gt; 2 令很多初学者惊讶的是，Python的整数除法，即使除不尽，结果仍然是整数，余数直接被扔掉。不过，Python提供了一个求余的运算 % 可以计算余数： 111 % 4 # ==&gt; 3 如果我们要计算 11 / 4 的精确结果，按照“整数和浮点数混合运算的结果是浮点数”的法则，把两个数中的一个变成浮点数再运算就没问题了： 111.0 / 4 # ==&gt; 2.75 编程任务：请计算 2.5 + 10 / 4 ,并解释计算结果为什么不是期望的 5.0 ? 请修复上述运算，使得计算结果是 5.0 1print 2.5 + 10.0 / 4 运行结果： 15.0 布尔类型我们已经了解了Python支持布尔类型的数据，布尔类型只有True和False两种值，但是布尔类型有以下几种运算： 与运算：只有两个布尔值都为 True 时，计算结果才为 True。 1234True and True # ==&gt; TrueTrue and False # ==&gt; FalseFalse and True # ==&gt; FalseFalse and False # ==&gt; False 或运算：只要有一个布尔值为 True，计算结果就是 True。 1234True or True # ==&gt; TrueTrue or False # ==&gt; TrueFalse or True # ==&gt; TrueFalse or False # ==&gt; False 非运算：把True变为False，或者把False变为True： 12not True # ==&gt; Falsenot False # ==&gt; True 布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： 知识点：Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True。短路运算 12a = Trueprint a and 'a=T' or 'a=F' 计算结果不是布尔类型，而是字符串 &#39;a=T&#39;，这是为什么呢？ 因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以： True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 在计算 a and b时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。 编码任务：请运行如下代码，并解释打印的结果： 1234a = 'python'print 'hello,', a or 'world'b = ''print 'hello,', b or 'world' 1234567# -*- coding: utf-8 -*-a = 'python'print 'hello,', a or 'world'#a为非空，则输出ab = ''#b为空，输出worldprint 'hello,', b or 'world' 运行结果： 12hello, pythonhello, world Python集合类型:list和tuple创建listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 12&gt;&gt;&gt; ['Michael', 'Bob', 'Tracy']['Michael', 'Bob', 'Tracy'] list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。 构造list非常简单，按照上面的代码，直接用 [ ]把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list： 123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates # 打印classmates变量的内容['Michael', 'Bob', 'Tracy'] 由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据： 1&gt;&gt;&gt; L = [&apos;Michael&apos;, 100, True] 一个元素也没有的list，就是空list： 1&gt;&gt;&gt; empty_list = [] 编程任务 假设班里有3名同学：Adam，Lisa和Bart，他们的成绩分别是 95.5，85 和 59，请按照 名字, 分数, 名字, 分数… 的顺序按照分数从高到低用一个list表示，然后打印出来。 12L = ['Adam', 95.5,'Lisa', 85, 'Bart', 59]print L 运行结果: 1[&apos;Adam&apos;, 95.5, &apos;Lisa&apos;, 85, &apos;Bart&apos;, 59] 注：list本身就是有序的。所以直接打印即可。 Python按照索引访问list由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。 需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。 因此，要打印第一名同学的名字，用 L[0]: 12345678910&gt;&gt;&gt; print L[0]Adam#要打印第二名同学的名字，用 L[1]:&gt;&gt;&gt; print L[1]Lisa#要打印第三名同学的名字，用 L[2]:&gt;&gt;&gt; print L[2]Bart 要打印第四名同学的名字，用 L[3]: 1234&gt;&gt;&gt; print L[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。 所以，使用索引时，千万注意不要越界。 编程任务 三名同学的成绩可以用一个list表示：L = [95.5, 85, 59] 请按照索引分别打印出第一名、第二名、第三名，同时测试 print L[3]。 实现代码： 12345L = [95.5,85,59]print L[0]print L[1]print L[2]print L[3] 运行结果： 1234567Traceback (most recent call last): File &quot;index.py&quot;, line 5, in print L[3]IndexError: list index out of range95.58559 知识点：正序从0开始，逆序从-1开始是最好一个list内容。 当索引数字为负数时，表示逆序读出List中的内容，记住List的最后一个空间的编号为-1开始 倒序访问list我们还是用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 这时，老师说，请分数最低的同学站出来。 要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2： 12&gt;&gt;&gt; print L[2]Bart Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素： 12&gt;&gt;&gt; print L[-1]Bart Bart同学表示躺枪。 类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示： 123456789&gt;&gt;&gt; print L[-2]Lisa&gt;&gt;&gt; print L[-3]Adam&gt;&gt;&gt; print L[-4]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of rangeL[-4] 报错了，因为倒数第四不存在，一共只有3个元素。 使用倒序索引时，也要注意不要越界。 编程任务 三名同学的成绩可以用一个list表示：L = [95.5, 85, 59] 请按照倒序索引分别打印出倒数第一、倒数第二、倒数第三。 实现代码： 12345L = [95.5, 85, 59]print L[-1]print L[-2]print L[-3]print L[-4] 运行结果： 1234567Traceback (most recent call last): File &quot;index.py&quot;, line 5, in print L[-4]IndexError: list index out of range598595.5 list添加新元素(append insert)现在，班里有3名同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？ 第一个办法是用 list 的 append() 方法，把新同学追加到 list 的末尾： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.append(&apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] append()总是把新的元素添加到 list 的尾部。 如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？ 方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.insert(0, &apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Paul&apos;, &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] L.insert(0, &#39;Paul&#39;) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。 编程任务 假设新来一名学生Paul，Paul 同学的成绩比Bart好，但是比Lisa差，他应该排到第三名的位置，请用代码实现。 代码实现: 123L = ['Adam', 'Lisa', 'Bart']L.insert(2,'paul')print L 运行结果: 1['Adam', 'Lisa', 'paul', 'Bart'] 正向第三名索引号为2.倒数第三名索引号为-3 list删除元素(pop)Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？ 如果Paul同学排在最后一个，我们可以用list的pop()方法删除： 12345&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L.pop()&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。 如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;] 要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉： 1234&gt;&gt;&gt; L.pop(2)&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 两种方式：直接pop()默认删除第一个，括号内指定参数：索引，删除索引位置上。 编码任务1L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;] Paul的索引是2，Bart的索引是3，如果我们要把Paul和Bart都删掉，请解释下面的代码为什么不能正确运行： 12L.pop(2)L.pop(3) 怎样调整代码可以把Paul和Bart都正确删除掉？ 解释：因为语句是按顺序执行的删除了Paul之后。索引号3已经越界。我们要删除的Bart已经变成2了。 知识点：这教育我们删除list时要秉着从前到后顺序。 List替换元素假设现在班里仍然是3名同学： &gt;&gt;&gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;] 现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。 另一个办法是直接用Paul把Bart给替换掉： 123&gt;&gt;&gt; L[2] = &apos;Paul&apos;&gt;&gt;&gt; print LL = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;] 对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。 由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作： &gt;&gt;&gt; L[-1] = &#39;Paul&#39; 编程任务 班里的同学按照分数排名是这样的：L = [‘Adam’, ‘Lisa’, ‘Bart’]但是，在一次考试后，Bart同学意外取得第一，而Adam同学考了倒数第一。 请通过对list的索引赋值，生成新的排名。 实现代码： 1234L = ['Adam', 'Lisa', 'Bart']L[0]='Bart'L[-1]='Adam'print L 运行结果： 1[&apos;Bart&apos;, &apos;Lisa&apos;, &apos;Adam&apos;] 创建tupletuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，知识点：tuple一旦创建完毕，就不能修改了。 同样是表示班里同学的名称，用tuple表示如下： 1&gt;&gt;&gt; t = (&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;) 创建tuple和创建list唯一不同之处是用( )替代了[ ]。 现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。 获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试： 1234&gt;&gt;&gt; t[0] = &apos;Paul&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment 编程任务 创建一个tuple，顺序包含0 - 9这10个数。 实现代码： 12t = (0,1,2,3,4,5,6,7,8,9)print t 运行结果： 1(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) 创建单元素tupletuple和list一样，可以包含 0 个、1个和任意多个元素。 包含多个元素的 tuple，前面我们已经创建过了。 包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示： 123&gt;&gt;&gt; t = ()&gt;&gt;&gt; print t() 创建包含1个元素的 tuple 呢？来试试： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; print t1 好像哪里不对！t 不是 tuple ，而是整数1。为什么呢？ 知识点：单元素tuple的()被当做优先级。(1)变成整数1.单元素括号结尾加, 因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。 正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号,，这样就避免了歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; print t(1,) Python在打印单元素tuple时，也自动添加了一个,，为了更明确地告诉你这是一个tuple。 多元素 tuple 加不加这个额外的,效果是一样的： 123&gt;&gt;&gt; t = (1, 2, 3,)&gt;&gt;&gt; print t(1, 2, 3) 编程任务下面代码为什么没有创建出包含一个学生的 tuple： 12t = ('Adam')print t 请修改代码，确保 t 是一个tuple。 因为单元素tuple的括号被当做是优先级标志。要加上额外,标识这是一个元组。 实现代码： 12t = ('Adam',)print t 运行结果: 1(&apos;Adam&apos;,) “可变”的tuple(指向不变。指向的东西可以变)前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个可变的tuple： 1&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;]) 注意到 t 有 3 个元素：&#39;a&#39;，&#39;b&#39;和一个list：[&#39;A&#39;, &#39;B&#39;]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到： 12345&gt;&gt;&gt; L = t[2]# 然后，我们把list的两个元素改一改：&gt;&gt;&gt; L[0] = 'X'&gt;&gt;&gt; L[1] = 'Y' 再看看tuple的内容： 12&gt;&gt;&gt; print t(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 不是说tuple一旦定义后就不可变了吗？怎么现在又变了？ 别急，我们先看看定义的时候tuple包含的3个元素： 当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为： 表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。 tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了指向不变后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 编程任务： 定义了tuple：t = (‘a’, ‘b’, [‘A’, ‘B’]) 由于 t 包含一个list元素，导致tuple的内容是可变的。能否修改上述代码，让tuple内容不可变？ 解答：将里面的list替换成一个不可变的元素。比如tuple。 实现代码: 12t = (&apos;a&apos;, &apos;b&apos;, (&apos;A&apos;, &apos;B&apos;))print t 运行结果： 1(&apos;a&apos;, &apos;b&apos;, (&apos;A&apos;, &apos;B&apos;)) Python的条件判断和循环语句if语句计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现： 12345age = 20if age &gt;= 18: print 'your age is', age print 'adult'print 'END' 注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。 知识点: 缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。 注意: if 语句后接表达式，然后用:表示代码块开始。 如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车： 12345&gt;&gt;&gt; age = 20&gt;&gt;&gt; if age &gt;= 18:... print &apos;your age is&apos;, age... print &apos;adult&apos;... 12your age is 20adult 编程任务 如果成绩达到60分或以上，视为passed。 假设Bart同学的分数是75，请用if语句判断是否能打印出 passed: 实现代码: 123score = 75if score&gt;=60: print 'passed' 运行结果: 1passed if-else当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块： 12if age &gt;= 18: print 'adult' 如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，怎么办？ 方法是再写一个 if: 12if age &lt; 18: print 'teenager' 或者用 not 运算： 12if not age &gt;= 18: print 'teenager' 细心的同学可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if ... else ... 语句把它们统一起来： 1234if age &gt;= 18: print 'adult'else: print 'teenager' 利用 if ... else ...语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。 注意: else 后面有个:。 编程任务 如果成绩达到60分或以上，视为passed，否则视为failed。 假设Bart同学的分数是55，请用if语句打印出 passed 或者 failed: 实现代码： 12345score = 55if score&gt;=60: print 'passed'else: print 'failed' 运行结果: 1failed if-elif-else有的时候，一个 if … else … 还不够用。比如，根据年龄的划分： 条件1：18岁或以上：adult 条件2：6岁或以上：teenager 条件3：6岁以下：kid 我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3： 1234567if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: print &apos;kid&apos; 这样写出来，我们就得到了一个两层嵌套的 if … else … 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby： 12345678910if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: if age &gt;= 3: print &apos;kid&apos; else: print &apos;baby&apos; 这种缩进只会越来越多，代码也会越来越难看。 要避免嵌套结构的 if … else …，我们可以用 if … 多个elif … else … 的结构，一次写完所有的规则： 12345678if age &gt;= 18: print &apos;adult&apos;elif age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 3: print &apos;kid&apos;else: print &apos;baby&apos; elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。 特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。 请思考下面的代码： 1234567age = 8if age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 18: print &apos;adult&apos;else: print &apos;kid&apos; 当 age = 8 时，结果正确，但 age = 20 时，为什么没有打印出 adult？ 如果要修复，应该如何修复？ 知识点解答: 因为当age=20.第一个条件&gt;=6满足就短路了。因此我们在设置条件应该从严格到松泛. 1234567age = 20if age &gt;= 18: print &apos;teenager&apos;elif age &gt;= 6: print &apos;adult&apos;else: print &apos;kid&apos; 编程任务 如果按照分数划定结果： 90分或以上：excellent 80分或以上：good 60分或以上：passed 60分以下：failed 请编写程序根据分数打印结果。 实现代码: 12345678910score = 85if score&gt;=90: print 'excellent'elif score&gt;=80: print 'good'elif score&gt;=60: print 'passed'else: print 'failed' 运行结果: 1good for循环list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list： 1234L = ['Adam', 'Lisa', 'Bart']print L[0]print L[1]print L[2] 如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。 这时，循环就派上用场了。 Python的 for 循环就可以依次把list或tuple的每个元素迭代出来： 123L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]for name in L: print name 注意: name 这个变量是在 for 循环中定义的(这是一个临时变量名字可自定义)，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。 这样一来，遍历一个list或tuple就非常容易了。 编程任务 班里考试后，老师要统计平均成绩，已知4位同学的成绩用list表示如下：L = [75, 92, 59, 68] 请利用for循环计算出平均成绩。 实现代码: 12345L = [75, 92, 59, 68]sum = 0.0for x in L: sum =sum+xprint sum / 4 运行结果： 173.5 while循环和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。 比如要从 0 开始打印不大于 N 的整数： 12345N = 10x = 0while x &lt; N: print x x = x + 1 while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块,否则，退出循环。 在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。 如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。 编程任务 利用while循环计算100以内奇数的和。 实现代码: 123456sum = 0x = 1while x&lt;=100: sum=sum+x x=x+2print sum 知识点: 奇数只需要从1开始不断加2都是奇数。 运行结果： 12500 break退出循环用for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。 比如计算1至100的整数和，我们用while来实现： 12345678sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum 咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。 编程任务 利用 while True 无限循环配合 break 语句，计算 1 + 2 + 4 + 8 + 16 + … 的前20项的和。 实现代码: 12345678910sum = 0x = 1n = 1while True: sum =sum+x x =2*x n =n+1 if n &gt;20: breakprint sum 运行结果: 11048575 continue继续循环在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。 假设我们已经写好了利用for循环计算平均分的代码： 1234567L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L: sum = sum + x n = n + 1print sum / n 现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环： 12345for x in L: if x &lt; 60: continue sum = sum + x n = n + 1 coutinue: 跳过下面的代码。开始下一次循环。 编程任务 对已有的计算 0 - 100 的while循环进行改造，通过增加 continue 语句，使得只计算奇数的和： 12345678sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum 思路: if判断到是偶数，continue跳过。 实现代码: 1234567891011sum = 0x = 0while True: x = x + 1 if x &gt; 100: break if x%2==0: continue sum = sum+x print sum 运行结果: 12500 多重循环(嵌套循环)在循环内部，还可以嵌套循环，我们来看一个例子： 123for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]: print x + y x 每循环一次，y就会循环 3 次，这样，我们可以打印出一个全排列： 123456789A1A2A3B1B2B3C1C2C3 编程任务 对100以内的两位数，请使用一个两重循环打印出所有十位数数字比个位数数字小的数，例如，23（2 &lt; 3）。 代码实现。 123456tens_place = [1,2,3,4,5,6,7,8,9]ones_place = [0,1,2,3,4,5,6,7,8,9]for x in tens_place: for y in ones_place: if x&lt;y: print x*10 + y 运行结果： 12345678910121314151617181923略 重要的数据类型Dict和Set什么是dict我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 或者考试的成绩列表： 1[95, 85, 59] 但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。 如果把名字和分数关联起来，组成类似的查找表： 123&apos;Adam&apos; ==&gt; 95&apos;Lisa&apos; ==&gt; 85&apos;Bart&apos; ==&gt; 59 给定一个名字，就可以直接查到分数。 Python的 dict 就是专门干这件事的。用 dict 表示名字-成绩的查找表如下： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 我们把名字称为key，对应的成绩称为value，dict就是通过 key来查找 value。 花括号 {} 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。 知识点： 区别小课堂 单元素的tuple必须在后面多加一个逗号。 dict最后的逗号可以省略 由于dict也是集合，len() 函数可以计算任意集合的大小： 12&gt;&gt;&gt; len(d)3 知识点：注意: 一个 key-value 算一个，因此，dict大小为3。 编程任务 新来的Paul同学成绩是 75 分，请编写一个dict，把Paul同学的成绩也加进去。 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 实现代码: 1234567d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 75 &#125; 访问dict我们已经能创建一个dict，用于表示名字和成绩的对应关系： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 那么，如何根据名字来查找对应的成绩呢？ 可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key： 1234567&gt;&gt;&gt; print d[&apos;Adam&apos;]95&gt;&gt;&gt; print d[&apos;Paul&apos;]Traceback (most recent call last): File &quot;index.py&quot;, line 11, in &lt;module&gt; print d[&apos;Paul&apos;]KeyError: &apos;Paul&apos; 注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。 知识点：避免 KeyError 发生，有两个办法： 是先判断一下 key 是否存在，用 in 操作符： 12if &apos;Paul&apos; in d: print d[&apos;Paul&apos;] 如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。 是使用dict本身提供的一个get方法，在Key不存在的时候，返回None： 1234&gt;&gt;&gt; print d.get(&apos;Bart&apos;)59&gt;&gt;&gt; print d.get(&apos;Paul&apos;)None 编程任务根据如下dict：12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 请打印出：Adam: 95Lisa: 85Bart: 59 实现代码: 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125;print &apos;Adam:&apos;,d[&apos;Adam&apos;]print &apos;Lisa:&apos;,d.get(&apos;Lisa&apos;)print &apos;Bart:&apos;,d[&apos;Bart&apos;] 运行结果： 123Adam: 95Lisa: 85Bart: 59 dict的特点知识点：dict查找速度快。list查找速度随着元素增加而逐渐下降。缺点：内存占用大。list慢但内存占用小。 dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。 不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。 由于dict是按 key 查找，所以，在一个dict中，key不能重复。 dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 当我们试图打印这个dict时： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明 知识点:dict内部是无序的，不能用dict存储有序的集合。 知识点：dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。 但是list是可变的，就不能作为 key。 可以试试用list作为key时会报什么样的错误。 不可变这个限制仅作用于key，value是否可变无所谓： 12345&#123; &apos;123&apos;: [1, 2, 3], # key 是 str，value是list 123: &apos;123&apos;, # key 是 int，value 是 str (&apos;a&apos;, &apos;b&apos;): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean&#125; 最常用的key还是字符串，因为用起来最方便。 编程任务 请设计一个dict，可以根据分数来查找名字，已知成绩如下： 123Adam: 95,Lisa: 85,Bart: 59. 实现代码: 12345d = &#123; 95:&apos;Adam&apos;, 85:&apos;Lisa&apos;, 59:&apos;Bart&apos;&#125; 运行结果：无 更新dictdict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 要把新同学’Paul’的成绩 72 加进去，用赋值语句： 1&gt;&gt;&gt; d[&apos;Paul&apos;] = 72 再看看dict的内容： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value： 123&gt;&gt;&gt; d[&apos;Bart&apos;] = 60&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 60&#125; 编程任务 请根据Paul的成绩 72 更新下面的dict：123456789d = &#123; 95: &apos;Adam&apos;, 85: &apos;Lisa&apos;, 59: &apos;Bart&apos;&#125; 实现代码: 1234567d = &#123; 95: 'Adam', 85: 'Lisa', 59: 'Bart'&#125;d[72] = 'Paul'print d 运行结果： 1&#123;72: &apos;Paul&apos;, 59: &apos;Bart&apos;, 85: &apos;Lisa&apos;, 95: &apos;Adam&apos;&#125; 遍历dict由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。 直接使用for循环可以遍历 dict 的 key： 1234567&gt;&gt;&gt; d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;&gt;&gt;&gt; for key in d:... print key... LisaAdamBart 由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。 注：这里的key只是一个约定俗称的变量，可以改为其他名字。但是推荐用key。 编程任务 请用 for 循环遍历如下的dict，打印出 name: score 来。 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 实现代码： 1234567d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125;for key in d: print key+&quot;:&quot;,d[key] 运行结果: 123Lisa: 85Adam: 95Bart: 59 什么是setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。 有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。 set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。 知识点: 创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： 12345&gt;&gt;&gt; s = set(['A', 'B', 'C'])可以查看 set 的内容：&gt;&gt;&gt; print sset(['A', 'C', 'B']) 请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。 因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？ 12345&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;C&apos;])&gt;&gt;&gt; print sset([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])&gt;&gt;&gt; len(s)3 结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。 编程任务 请用set表示班里的4位同学：Adam, Lisa, Bart, Paul 实现代码: 12s = set(['Adam', 'Lisa', 'Bart', 'Paul'])print s 运行结果: 1set([&apos;Lisa&apos;, &apos;Paul&apos;, &apos;Adam&apos;, &apos;Bart&apos;]) 访问set由于set存储的是无序集合，所以我们没法通过索引来访问。 访问 set中的某个元素实际上就是判断一个元素是否在set中。 例如，存储了班里同学名字的set： 1&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]) 我们可以用 in 操作符判断： Bart是该班的同学吗？ 12345678910&gt;&gt;&gt; &apos;Bart&apos; in sTrueBill是该班的同学吗？&gt;&gt;&gt; &apos;Bill&apos; in sFalsebart是该班的同学吗？&gt;&gt;&gt; &apos;bart&apos; in sFalse 知识点：大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。 编程任务 由于上述set不能识别小写的名字，请改进set，使得 ‘adam’ 和 ‘bart’都能返回True。 既然大小写是不同的。那我们的set中就把大小写都包含。 实现代码: 123s = set(['Adam', 'Lisa', 'Bart', 'Paul','adam', 'lisa', 'bart', 'paul'])print 'adam' in sprint 'bart' in s 运行结果. 12TrueTrue set的特点set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。 set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。 最后，set存储的元素也是没有顺序的。 set的这些特点，可以应用在哪些地方呢？ 星期一到星期日可以用字符串&#39;MON&#39;, &#39;TUE&#39;, ... &#39;SUN&#39;表示。 假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？ 可以用 if 语句判断，但这样做非常繁琐： 12345x = '???' # 用户输入的字符串if x!= 'MON' and x!= 'TUE' and x!= 'WED' ... and x!= 'SUN': print 'input error'else: print 'input ok' 注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。 如果事先创建好一个set，包含&#39;MON&#39; ~ &#39;SUN&#39;： 1weekdays = set([&apos;MON&apos;, &apos;TUE&apos;, &apos;WED&apos;, &apos;THU&apos;, &apos;FRI&apos;, &apos;SAT&apos;, &apos;SUN&apos;]) 再判断输入是否有效，只需要判断该字符串是否在set中： 123456x = '???' # 用户输入的字符串if x in weekdays: print 'input ok'else: print 'input error'这样一来，代码就简单多了。 编程任务 月份也可以用set表示，请设计一个set并判断用户输入的月份是否有效。月份可以用字符串&#39;Jan&#39;, &#39;Feb&#39;, ...表示。 实现代码: 12345678910111213months = set(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul','Aug','Sep','Oct','Nov','Dec'])x1 = 'Feb'x2 = 'Sun'if x1 in months: print 'x1: ok'else: print 'x1: error'if x2 in months: print 'x2: ok'else: print 'x2: error' 运行结果: 12x1: okx2: error 遍历set由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。 直接使用 for 循环可以遍历 set 的元素： 1234567&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart'])&gt;&gt;&gt; for name in s:... print name... LisaAdamBart 注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。 编程任务 请用 for 循环遍历如下的set，打印出 name: score 来。 1s = set([(&apos;Adam&apos;, 95), (&apos;Lisa&apos;, 85), (&apos;Bart&apos;, 59)]) 上面这个set中的每一个元素又是一个字典。 set([ ])是壳子。 (&#39;Adam&#39;, 95), (&#39;Lisa&#39;, 85), (&#39;Bart&#39;, 59)才是真正的内容 实现代码： 123s = set([('Adam', 95), ('Lisa', 85), ('Bart', 59)])for name,score in s: print name,':',score 运行结果: 123Lisa : 85Adam : 95Bart : 59 更新set(add remove)由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事： 是把新的元素添加到set中 是把已有元素从set中删除。(前提是如果有) 添加元素时，用set的add()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; print sset([1, 2, 3, 4]) 如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(3)&gt;&gt;&gt; print sset([1, 2, 3]) 删除set中的元素时，用set的remove()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; print sset([1, 2, 3]) 如果删除的元素不存在set中，remove()会报错： 12345&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.remove(4)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 4 所以用add()可以直接添加，而remove()前需要判断。 编程任务 针对下面的set，给定一个list，对list中的每一个元素，如果在set中，就将其删除，如果不在set中，就添加进去。 12s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;])L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 实现代码： 12345678s = set(['Adam', 'Lisa', 'Paul'])L = ['Adam', 'Lisa', 'Bart', 'Paul']for name in L: if name in s: s.remove(name) else: s.add(name)print s 函数定义与调用什么是函数我们知道圆的面积计算公式为： S = πr² 当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积： 123456r1 = 12.34r2 = 9.08r3 = 73.1s1 = 3.14 * r1 * r1s2 = 3.14 * r2 * r2s3 = 3.14 * r3 * r3 当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。 有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用 s = area_of_circle(x)，而函数 area_of_circle本身只需要写一次，就可以多次调用。 抽象是数学中非常常见的概念。举个例子： 计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作： 123100∑nn=1 这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。 而且，这种抽象记法是可扩展的，比如： 123100∑(n²+1)n=1 还原成加法运算就变成了： (1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。 写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。 Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。 编程任务 写一个函数 实现代码： 12s = area_of_circle(x)area_of_circle(x) 运行结果： 调用函数,内置函数Python内置了很多有用的函数，我们可以直接调用。 要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。 可以直接从Python的官方网站查看文档：http://docs.python.org/2/library/functions.html#abs 也可以在交互式命令行通过 help(abs)查看abs函数的帮助信息。 调用 abs 函数： 123456&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34 调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个： 1234&gt;&gt;&gt; abs(1, 2)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型： 1234&gt;&gt;&gt; abs(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: bad operand type for abs(): &apos;str&apos; 而比较函数 cmp(x, y) 就需要两个参数，如果 x&lt;y，返回 -1，如果 x==y，返回0，如果 x&gt;y，返回 1： 123456&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0 Python内置的常用函数还包括数据类型转换函数，比如 int()函数可以把其他数据类型转换为整数： 1234&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(12.34)12 str()函数把其他类型转换成 str： 1234&gt;&gt;&gt; str(123)&apos;123&apos;&gt;&gt;&gt; str(1.23)&apos;1.23&apos; 编程任务 sum()函数接受一个list作为参数，并返回list所有元素之和。请计算 1*1 + 2*2 + 3*3 + ... + 100*100。 实现代码： 1234567L = []L = []x = 1while x &lt;= 100: L.append(x * x) x = x + 1print sum(L) 运行结果: 1338350 编写函数在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return语句返回。 我们以自定义一个求绝对值的 my_abs 函数为例： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 知识点； 如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。return None可以简写为return。 编程任务 请定义一个 square_of_sum 函数，它接受一个list，返回list中每个元素平方的和。 实现代码: 12345678def square_of_sum(L): sum = 0 for x in L: sum = x*x+sum return sumprint square_of_sum([1, 2, 3, 4, 5])print square_of_sum([-5, 0, 5, 15, 25]) 运行结果: 1255900 函数之返回”多值”函数可以返回多个值吗？答案是肯定的。 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： math包提供了sin()和 cos()函数，我们先用import引用它： 12345import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 这样我们就可以同时获得返回值： 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print x, y151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print r(151.96152422706632, 70.0) 知识点：用print打印返回结果，原来返回值是一个tuple！ 但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，知识点：Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 编程任务 一元二次方程的定义是：ax² + bx + c = 0 请编写一个函数，返回一元二次方程的两个解。 注意：Python的math包提供了sqrt()函数用于计算平方根。 实现代码: 12345678import mathdef quadratic_equation(a, b, c): t = math.sqrt(b*b - 4*a*c) return (-b + t) / (2 * a),( -b - t )/ (2 * a)print quadratic_equation(2, 3, 0)print quadratic_equation(1, -6, 5) 运行结果: 12(0.0, -1.5)(5.0, 1.0) 递归函数在函数内部，可以调用其他函数。知识点: 如果一个函数在内部调用自身本身，这个函数就是递归函数。 举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * ... * n，用函数 fact(n)表示，可以看出： fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。 于是，fact(n)用递归的方式写出来就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 上面就是一个递归函数。可以试试： 123456&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 如果我们计算fact(5)，可以根据函数定义看到计算过程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 递归函数的优点是定义简单，逻辑清晰。知识点: 理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 知识点: 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。 编程任务(天涯) 汉诺塔 (http://baike.baidu.com/view/191666.htm) 的移动也可以看做是递归函数。 我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为： 如果a只有一个圆盘，可以直接移动到c； 如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。 请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤： 1move(n, a, b, c) 例如，输入 move(2, ‘A’, ‘B’, ‘C’)，打印出： 123A --&gt; BA --&gt; CB --&gt; C 实现代码： 12345678def move(n, a, b, c): if n ==1: print a, '--&gt;', c return move(n-1, a, c, b) print a, '--&gt;', c move(n-1, b, a, c)move(4, 'A', 'B', 'C') 运行结果: 123456789101112131415A --&gt; BA --&gt; CB --&gt; CA --&gt; BC --&gt; AC --&gt; BA --&gt; BA --&gt; CB --&gt; CB --&gt; AC --&gt; AB --&gt; CA --&gt; BA --&gt; CB --&gt; C 定义默认参数定义函数的时候，还可以有默认参数。 例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数： 1234&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(&apos;123&apos;, 8)83 知识点: int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。 可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。 我们来定义一个计算 x 的N次方的函数: 123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样一来，计算平方就不需要传入两个参数了： 12&gt;&gt;&gt; power(5)25 知识点: 由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面： 123456# OK:def fn1(a, b=1, c=2): pass# Error:def fn2(a=1, b): pass 个人: 这里我们可以把自己想象成计算机。在自己感到为难不知道哪个是哪个的时候。那么恭喜你，计算机也不知道。 编程任务 请定义一个 greet()函数，它包含一个默认参数，如果没有传入，打印 &#39;Hello, world.&#39;，如果传入，打印 &#39;Hello, xxx.&#39; 实现代码: 12345def greet(x = 'World'): print 'Hello,'+x+'.'greet()greet('mtianyan') 运行结果: 12Hello,World.Hello,mtianyan. 知识点: 定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： 12def fn(*args): print args 可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数： 12345678&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn('a')('a',)&gt;&gt;&gt; fn('a', 'b')('a', 'b')&gt;&gt;&gt; fn('a', 'b', 'c')('a', 'b', 'c') 可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。 定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数： 12def average(*args): ... 这样，在调用的时候，可以这样写： 123456&gt;&gt;&gt; average()0&gt;&gt;&gt; average(1, 2)1.5&gt;&gt;&gt; average(1, 2, 2, 3, 4)2.4 编程任务 请编写接受可变参数的 average() 函数。 12345678910def average(*args): sum = 0.0 if len(args) == 0: return sum for x in args: sum = sum + x return sum / len(args)print average()print average(1, 2)print average(1, 2, 2, 3, 4) 运行结果: 1230.01.52.4 切片操作对list进行切片取一个list的部分元素是非常常见的操作。比如，一个list如下： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 取前3个元素，应该怎么做？ 笨办法： 12&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 之所以是笨办法是因为扩展一下，取前N个元素就没辙了。 取前N个元素，也就是索引为0-(N-1)的元素，可以用循环： 1234567&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 对应上面的问题，取前3个元素，用一行代码就可以完成切片： 123&gt;&gt;&gt; L[0:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 知识点： [0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12&gt;&gt;&gt; L[:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 也可以从索引1开始，取出2个元素出来： 12&gt;&gt;&gt; L[1:3][&apos;Lisa&apos;, &apos;Bart&apos;] 只用一个 : ，表示从头到尾： 12&gt;&gt;&gt; L[:][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 因此，L[:]实际上复制出了一个新list。 知识点: 切片操作还可以指定第三个参数： 12&gt;&gt;&gt; L[::2][&apos;Adam&apos;, &apos;Bart&apos;] 第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 编程任务 range()函数可以创建一个数列： 12&gt;&gt;&gt; range(1, 101)[1, 2, 3, ..., 100] 请利用切片，取出： 前10个数； 3的倍数； 不大于50的5的倍数。 实现代码: 12345L = range(1, 101)print L[:10]print L[2::3]print L[4:50:5] 运行结果: 123[1, 2, 3, 4, 5, 6, 7, 8, 9, 10][3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99][5, 10, 15, 20, 25, 30, 35, 40, 45, 50] 倒序切片对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 12345678910111213&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; L[-2:]['Bart', 'Paul']&gt;&gt;&gt; L[:-2]['Adam', 'Lisa']&gt;&gt;&gt; L[-3:-1]['Lisa', 'Bart']&gt;&gt;&gt; L[-4:-1:2]['Adam', 'Bart'] 记住倒数第一个元素的索引是-1。知识点：倒序切片包含起始索引，不包含结束索引。 编程任务 利用倒序切片对 1 - 100 的数列取出： 最后10个数； 最后10个5的倍数。 实现代码： 123L = range(1, 101)print L[-10:]print L[-46::5] 对字符串切片字符串 &#39;xxx&#39;和 Unicode字符串 u&#39;xxx&#39;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 123456&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[-3:]&apos;EFG&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。知识点：Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。 编程任务 字符串有个方法 upper() 可以把字符变成大写字母： 12&gt;&gt;&gt; &apos;abc&apos;.upper()&apos;ABC&apos; 但它会把所有字母都变成大写。请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串。 提示：利用切片操作简化字符串操作。 实现代码: 123456def firstCharUpper(s): return s[0].upper() + s[1:]print firstCharUpper('hello')print firstCharUpper('sunday')print firstCharUpper('september') 运行结果： 123HelloSundaySeptember 各种迭代方式什么是迭代在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 在Python中，迭代是通过 for ... in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码： 123for (i=0; i&lt;list.length; i++) &#123; n = list[i];&#125; 可以看出，Python的for循环抽象程度要高于Java的for循环。 因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。 因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。 注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括： 有序集合：list，tuple，知识点: str和unicode； 无序集合：set 无序集合并且具有 key-value 对：dict 而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。 迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。 编程任务 请用for循环迭代数列 1-100 并打印出7的倍数。 实现代码: 123for i in range(1, 101): if i % 7 == 0: print i 运行结果: 1234567891011121314714212835424956637077849198 索引迭代知识点：Python中，迭代永远是取出元素本身，而非元素的索引。 对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 enumerate()函数： 12345678&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; for index, name in enumerate(L):... print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul 使用 enumerate()函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 变成了类似： 1[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)] 因此，迭代的每一个元素实际上是一个tuple： 1234for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： 12for index, name in enumerate(L): print index, &apos;-&apos;, name 这样不但代码更简单，而且还少了两条赋值语句。 可见，知识点: 索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 编程任务(天涯) zip()函数可以把两个 list 变成一个 list： 12&gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])[(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 在迭代 [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 提示：考虑使用zip()函数和range()函数 实现代码: 123L = ['Adam', 'Lisa', 'Bart', 'Paul']for index, name in zip(range(1, len(L)+1), L): print index, '-', name 运行结果: 12341 - Adam2 - Lisa3 - Bart4 - Paul 迭代dict的value迭代dict的value我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。 如果我们希望迭代 dict 对象的value，应该怎么做？ 知识点：values()把dict转换成一个包含所有value的listdict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，知识点: 任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，知识点: 可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 编程任务 给定一个dict：d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 请计算所有同学的平均分。 实现代码: 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;sum = 0.0for v in d.itervalues(): sum = sum + vprint sum / len(d) 运行结果: 178.25 迭代dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。 首先，我们看看 dict 对象的 items()方法返回的值： 123&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; print d.items()[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value： 123456&gt;&gt;&gt; for key, value in d.items():... print key, &apos;:&apos;, value... Lisa : 85Adam : 95Bart : 59 和 values()有一个 itervalues() 类似，items() 也有一个对应的 iteritems()，知识点： iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 编程任务 请根据dict：d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 打印出 name : score，最后再打印出平均分 average : score。 实现代码： 123456d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59, 'Paul': 74 &#125;sum = 0.0for k, v in d.iteritems(): sum = sum + v print k, ':', vprint 'average', ':', sum / len(d) 运行结果： 12345Lisa : 85Paul : 74Adam : 95Bart : 59average : 78.25 列表生成式:快速生成列表生成列表要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)： 12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？ 方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)... &gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。 知识点: 写列表生成式时，把要生成的元素 x * x放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 编程任务 请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, ..., 99x100] 提示：range(1, 100, 2)可以生成list [1, 3, 5, 7, 9,...] 实现代码： 1print [x * (x + 1) for x in range(1, 100, 2)] 运行结果： 1[2, 12, 30, 56, 90, 132, 182, 240, 306, 380, 462, 552, 650, 756, 870, 992, 1122, 1260, 1406, 1560, 1722, 1892, 2070, 2256, 2450, 2652, 2862, 3080, 3306, 3540, 3782, 4032, 4290, 4556, 4830, 5112, 5402, 5700, 6006, 6320, 6642, 6972, 7310, 7656, 8010, 8372, 8742, 9120, 9506, 9900] 复杂表达式使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。 假设有如下的dict： 1d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125; 完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： 12345tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]print '&lt;table&gt;'print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'print '\n'.join(tds)print '&lt;/table&gt;' 个人：&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt; 中： 第一个%s是name的填充位置。 第二个%s为score的填充位置。 有多少个name和score，会通过循环生成多少个。&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;设置表格头print ‘\n’.join(tds)。列表里的项通过\n连接成字符串。 注：字符串可以通过%进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list拼接成一个字符串。 把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了： 123456&lt;table border="1"&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 编程任务(天涯) 在生成的表格中，对于没有及格的同学，请把分数标记为红色。 提示：红色可以用 &lt;td style=&quot;color:red&quot;&gt; 实现。 实现代码: 12345678910d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;def generate_tr(name, score): if score &lt; 60: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score)tds = [generate_tr(name, score) for name, score in d.iteritems()]print &apos;&lt;table border=&quot;1&quot;&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; 运行结果: 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 编程任务 请编写一个函数，它接受一个 list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。 提示： isinstance(x, str) 可以判断变量 x 是否是字符串； 字符串的 upper() 方法可以返回大写的字母。 实现代码: 123def toUppers(L): return [x.upper() for x in L if isinstance(x, str)]print toUppers(['Hello', 'world', 101]) 运行结果: 1[&apos;HELLO&apos;, &apos;WORLD&apos;] 多层表达式(知识点)for循环可以嵌套，知识点：因此，在列表生成式中，也可以用多层 for 循环来生成列表。 对于字符串 &#39;ABC&#39; 和 &#39;123&#39;，可以使用两层循环，生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in '123']['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 翻译成循环代码就像下面这样： 1234L = []for m in 'ABC': for n in '123': L.append(m + n) 编程任务(天涯) 利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。 实现代码: 1print [100 * n1 + 10 * n2 + n3 for n1 in range(1, 10) for n2 in range(10) for n3 in range(10) if n1==n3] 运行结果： 1101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]]]></content>
      <categories>
        <category>python从入门到精通</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>零基础入门</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
