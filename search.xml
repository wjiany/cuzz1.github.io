<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Shell入门]]></title>
    <url>%2Fpost%2F9049990f.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[Python零基础入门笔记]]></title>
    <url>%2Fpost%2F7a862501.html</url>
    <content type="text"><![CDATA[复习是为了更好的学习更新的知识。 学习python有一年多了，希望通过学习笔记来复习了，也能让后来者少走一点弯路。在课程笔记的同时加入了一部分自己的经验补充。 [√] 廖雪峰老师在慕课网的课程: Python入门 Python的初次体验python语言介绍全世界有几百种编程语言，但是流行的只有十几种，python就是其中一种。荷兰人龟叔于1989年圣诞节创立。 特点：优雅，明确，简单。 适合的领域： web网站和各种网络服务； 系统工具和脚本； 作为胶水语言把其他语言开发的模块包装起来方便使用。 Python是一门高级语言，所以不适合贴近硬件的代码: 比如驱动程序（首选C） 移动开发，有各自的语言，（objectC，swift/java） 游戏开发（首选C/C++）。 Python实际应用： YouTube，豆瓣，搜狐邮箱；Openstack开源云计算平台。Google，Yahoo，NASA。 语言之间的对比： C编译为机器码；JAVA编译为字节码；python为解释执行。 缺点： 运行慢，Python源码不能加密。 Python版本的选择博主建议选择安装环境篇的进阶版：2.7版本与3.x版本共存。 3.x版本建议选择Python 3.5.1 |Anaconda 4.1.0 (64-bit)以后如果要使用python进行TensorFlow windows版的配置可以省下时间。 windows下安装python参考：搭建Python开发环境 第一个python程序cmd下输入python。进入交互式环境。 命令行模式启动python:python 命令行模式执行python文件python 目录/xxx.py 命令行模式关闭python：exit() 注意：不要使用word，或者windows下自带的记事本来进行代码编写。 推荐使用： 轻量级：sublime Text 或 editplus 重量级(较大工程) : pycharm Professional 2.7版本专属： print &#39;hello,world!&#39; 3.x版本(2.7版本也可以正常运行)： print (&quot;hello,world!&quot;) Python变量和数据类型 讲解Python基本的数据类型.包括整数、浮点数、字符串和布尔类型，以及变量的概念和基本的数据运算。 数据类型整数在Python程序中，整数的表示方法和数学上的写法一模一样. 例如：1，100，-8080，0，等等。十六进制用0x前缀和0-9，a-f表示. 例如：0xff00，0xa5b4c3d2，等等。 浮点数浮点数也就是小数，之所以称为浮点数: 因为按照科学记数法表示时，一个浮点数的小数点位置是可变的 比如，1.23x10^9和12.3x10^8是相等的。 浮点数可以用数学写法: 如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x10^9就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。 整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。 知识点：python2与3不同整除 python2.7下：/ 和 // 都是整数除法。 例: 1/2结果为0.后面小数部分会直接去除掉。 python3.x下： / 为浮点数除法(如：1/2=0.5) //为整数除法(如: 1//2 = 0） 12345a = 1 b = 2print a+b#python2.7下想要浮点数除法就得使用类型转换。print float(a)/b 字符串字符串是以’’或””括起来的任意文本，比如’abc’，”xyz”等等。请注意，’’或””本身只是一种表示方式，不是字符串的一部分. 因此，字符串’abc’只有a，b，c这3个字符。 布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来。 布尔值可以用and、or和not运算。 and运算是与运算，只有所有都为 True，and运算结果才是 True。 or运算是或运算，只要其中有一个为 True，or 运算结果就是 True。 not运算是非运算，它是一个单目运算符，把 True 变成 False，False 变成 True。 空值空值是Python里一个特殊的值，用None表示。 None不能理解为0，因为0是有意义的，而None是一个特殊的空值。 编程小任务： 计算十进制整数 45678 和十六进制整数 0x12fd2 之和。 请用字符串表示出Learn Python in imooc。 请计算以下表达式的布尔值（注意==表示判断是否相等）：12100 &lt; 990xff == 255 题目答案： 1234print 45678+0x12fd2print "Learn Python in imooc" print 100&lt;99 print 0xff == 255 运行结果： 1234123456Learn Python in imoocFalseTrue print语句print语句可以向屏幕上输出指定的文字。比如输出’hello, world’，用代码实现如下： 1print 'hello, world' 注意： 当我们在Python交互式环境下编写代码时，&gt;&gt;&gt;是Python解释器的提示符，不是代码的一部分。 当我们在文本编辑器中编写代码时，千万不要自己添加 &gt;&gt;&gt;。 print语句也可以跟上多个字符串，用逗号,隔开，就可以连成一串输出： 1print 'The quick brown fox', 'jumps over', 'the lazy dog' 运行结果： 1The quick brown fox jumps over the lazy dog print会依次打印每个字符串，知识点：遇到逗号,会输出一个空格. print也可以打印整数，或者计算结果： 1234&gt;&gt;&gt; print 300300 #运行结果&gt;&gt;&gt; print 100 + 200300 #运行结果 漂亮做法： 12&gt;&gt;&gt; print '100 + 200 =', 100 + 200100 + 200 = 300 #运行结果 注意: 对于100 + 200，Python解释器自动计算出结果300.但是，’100 + 200 =’是字符串而非数学公式，Python把它视为字符串. 编程任务：请用两种方式打印出 hello, python.实现代码： 123#input codeprint 'hello, python.'print 'hello,','python.' 运行结果： 12hello, python.hello, python. 注释Python的注释以#开头，后面的文字直到行尾都算注释 12345# 这一行全部都是注释...print 'hello' # 这也是注释# 暂时不想运行下面一行代码:# print 'hello, python.' 注释还有一个巧妙的用途，就是一些代码我们不想运行，但又不想删除，就可以用注释暂时屏蔽掉： 编程任务:将代码编辑器中的 “print ‘hello’” 语句修改成注释语句 实现代码： 1# print 'hello' 注释：多行注释1234'''下面是一行被注释代码下面是两行被注释代码''' 什么是变量在Python中，变量的概念基本上和初中代数的方程变量是一致的。 例如，对于方程式y=x*x ，x就是变量。 当x=2时，计算结果是4。当x=5时，计算结果是25。 只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。 在Python程序中，变量是用一个变量名表示。 知识点：变量名必须是大小写英文、数字和下划线 _ 的组合，且不能用数字开头。比如： 12a = 1t_007 = 'T007' 变量a是一个整数。变量t_007是一个字符串。 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如： 1234a = 123 # a是整数print aa = 'imooc' # a变为字符串print a 知识点: 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）： 123//这些是java代码int a = 123; // a是整数类型变量a = "mooc"; // 错误：不能把字符串赋给整型变量 和静态语言相比，动态语言更灵活，就是这个原因。请不要把赋值语句的等号等同于数学的等号。比如下面的代码： 12x = 10x = x + 2 如果从数学上理解x = x + 2那无论如何是不成立的. 在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。 最后，知识点: 理解变量在计算机内存中的表示也非常重要。当我们写：a = ‘ABC’时，Python解释器干了两件事情： 在内存中创建了一个’ABC’的字符串； 在内存中创建了一个名为a的变量，并把它指向’ABC’。 也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码： 1234a = 'ABC'b = aa = 'XYZ'print b 最后一行打印出变量b的内容到底是’ABC’呢还是’XYZ’？如果从数学意义上理解，就会错误地得出b和a相同，也应该是’XYZ’，但实际上b的值是’ABC’，让我们一行一行地执行代码，就可以看到到底发生了什么事： 执行a = &#39;ABC&#39;，解释器创建了字符串 &#39;ABC&#39;和变量 a，并把a指向 &#39;ABC&#39;： 执行b = a，解释器创建了变量 b，并把b指向 a 指向的字符串&#39;ABC&#39;： 执行a = &#39;XYZ&#39;，解释器创建了字符串&#39;XYZ&#39;，并把a的指向改为’XYZ’，但b并没有更改： 所以，最后打印变量b的结果自然是’ABC’了。 编程任务： 等差数列可以定义为每一项与它的前一项的差等于一个常数，可以用变量 x1 表示等差数列的第一项，用 d 表示公差，请计算数列 1 4 7 10 13 16 19 … 前 100 项的和。 实现代码: 1234567x1 = 1d = 3n = 100x100 = x1+(100-1)*ds2 = (x1+x100)*100/2s = n*x1+n*(n-1)*d/2print s,s2 等差数列公式： （首项+尾项）*项数/2 项数*首项+项数*(项数-1)*公差/2 运行结果： 114950 14950 定义字符串字符串可以用&#39;&#39;或者&quot;&quot;括起来表示。 如果字符串本身包含&#39;怎么办？比如我们要表示字符串 I&#39;m OK，这时，可以用&quot; &quot;括起来表示： 12"I'm OK"'Learn "Python" in imooc' 类似的，知识点: 如果字符串包含&quot;，我们就可以用&#39; &#39;括起来表示： 如果字符串既包含&#39;又包含&quot;怎么办？ 知识点：转义 这个时候，就需要对字符串的某些特殊字符进行转义，Python字符串用\进行转义。 要表示字符串 Bob said &quot;I&#39;m OK&quot;.由于 &#39; 和&quot;会引起歧义，因此，我们在它前面插入一个\表示这是一个普通字符，不代表字符串的起始，因此，这个字符串又可以表示为 12'Bob said \"I\'m OK\".'# 在要保留原状的字符串前面加上右斜杠 注意：转义字符 \不计入字符串的内容中。 常用的转义字符还有： \n表示换行 \t 表示一个制表符 \\ 表示 \ 字符本身 编程任务： 请将下面两行内容用Python的字符串表示并打印出来： 12 Python was started in 1989 by &quot;Guido&quot;. Python is free and easy to learn. 12s = 'Python was started in 1989 by"Guido".\nPython is free and easy to learn.'print s raw字符串与多行字符串如果一个字符串包含很多需要转义的字符，对每一个字符都进行转义会很麻烦。为了避免这种情况，我们可以在字符串前面加个前缀 r ，表示这是一个 raw 字符串，里面的字符就不需要转义了。例如： 1r'\(~_~)/ \(~_~)/' 解释： 这个例子举得不是很好。可以看出raw加上之后。可能产生误会的\被修改为\\(\\ 表示 \ 字符本身) 不加上r 只有\和(并没有合成转义字符。 加上r。\需要被转义，经过转义后显示出来还是自己。 知识点: 个人小题(r的强大作用) 上图效果可以看出r的强大作用。 但是r&#39;我是一段字符&#39;表示法不能表示多行字符串(r&#39;&#39;&#39;一段字符&#39;&#39;&#39;)，也不能表示包含&#39;和 &quot;的字符串（为什么？） 因为如果r&#39;mtian&#39;yan&#39; r遇到左边第一个&#39;,会继续往后找闭合的标志&#39;然后找到mtian的地方。它任务结束了。代码继续往下执行。当扫到yan这里他就会报错。 ???(更深层待续) 或者r&quot;mtian&quot;yan&quot; 或导致r提前结束掉。后面的就无法继续匹配到对应的。 知识点: 多行字符串，可以用&#39;&#39;&#39;...&#39;&#39;&#39;表示： 12345'''Line 1Line 2Line 3'''#上面这个字符串的表示方法和下面的是完全一样的：'Line 1\nLine 2\nLine 3' 还可以在多行字符串前面添加 r ，把这个多行字符串也变成一个raw字符串： 123r'''Python is created by "Guido".It is free and easy to learn.Let's start learn Python in imooc!''' 编程任务：请把下面的字符串用r&#39;&#39;&#39;...&#39;&#39;&#39;的形式改写，并用print打印出来： 1&apos;\&quot;To be, or not to be\&quot;: that is the question.\nWhether it\&apos;s nobler in the mind to suffer.&apos; 12print r'''"To be,or not to be":that is the question.Whether it's nobler in the mind to suffer.''' 知识点: Unicode字符串字符串还有一个编码问题。 因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），0 - 255被用来表示大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母 A 的编码是65，小写字母 z 的编码是122。 如果要表示中文，显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 类似的，日文和韩文等其他语言也有这个问题。为了统一所有文字的编码，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode通常用两个字节表示一个字符，原有的英文编码从单字节变成双字节，只需要把高字节全部填为0就可以。 因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。 Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： 123print u'中文'中文注意: 不加 u ，中文就不能正常显示。(这个应该是很早版本才会。笔者现在已经无法复现) 转载: http://blog.csdn.net/lxdcyh/article/details/4018054 字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码decode成unicode，再从unicode编码encode成另一种编码。 decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode(&#39;gb2312&#39;)，表示将gb2312编码的字符串str1转换成unicode编码。 encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘gb2312’)，表示将unicode编码的字符串str2转换成gb2312编码 代码中字符串的默认编码与代码文件本身的编码一致。 如：s=’中文’ 如果是在utf8的文件中，该字符串就是utf8编码，如果是在gb2312的文件中，则其编码为gb2312。这种情况下，要进行编码转换，都需要先用decode方法将其转换成unicode编码，再使用encode方法将其转换成其他编码。通常，在没有指定特定的编码方式时，都是使用的系统默认编码创建的代码文件 如果字符串是这样定义：s=u’中文’ 则该字符串的编码就被指定为unicode了，即python的内部编码，而与代码文件本身的编码无关。因此，对于这种情况做编码转换，只需要直接使用encode方法将其转换成指定编码即可。 如果一个字符串已经是unicode了，再进行解码则将出错，因此通常要对其编码方式是否为unicode进行判断： 12isinstance(s, unicode) #用来判断是否为unicode 用非unicode编码形式的str来encode会报错 如何获得系统的默认编码？ 1234#!/usr/bin/env python#coding=utf-8import sysprint sys.getdefaultencoding() 该段程序在Win10(1079)上输出为：ascii 在某些IDE中，字符串的输出总是出现乱码，甚至错误，其实是由于IDE的结果输出控制台自身不能显示字符串的编码，而不是程序本身的问题。 如在UliPad(注:UliPad是wxPython的动力，导向和灵活的编程器)中运行如下代码： 12s=u&quot;中文&quot;print s 会提示：UnicodeEncodeError: ‘ascii’ codec can’t encode characters in position 0-1: ordinal not in range(128)。这是因为UliPad在控制台信息输出窗口是按照ascii编码输出的（系统的默认编码是ascii），而上面代码中的字符串是Unicode编码的，所以输出时产生了错误。 将最后一句改为：print s.encode(&#39;gb2312&#39;) 则能正确输出“中文”两个字。 若最后一句改为：print s.encode(&#39;utf8&#39;) 则输出：/xe4/xb8/xad/xe6/x96/x87，这是控制台信息输出窗口按照ascii编码输出utf8编码的字符串的结果。 unicode(str,&#39;gb2312&#39;)与str.decode(&#39;gb2312&#39;)是一样的，都是将gb2312编码的str转为unicode编码 使用str.__class__可以查看str的编码形式为str类型。 window默认编码gbk；linux默认编码utf8 原理说了半天，最后来个包治百病的吧：(天涯)：下面代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#!/usr/bin/env python #coding=utf-8def getCoding(strInput): ''' 获取编码格式 ''' if isinstance(strInput, unicode): return "unicode" try: strInput.decode("utf8") return 'utf8' except: pass try: strInput.decode("gbk") return 'gbk' except: pass def tran2UTF8(strInput): ''' 转化为utf8格式 ''' strCodingFmt = getCoding(strInput) if strCodingFmt == "utf8": return strInput elif strCodingFmt == "unicode": return strInput.encode("utf8") elif strCodingFmt == "gbk": return strInput.decode("gbk").encode("utf8")def tran2GBK(strInput): ''' 转化为gbk格式 ''' strCodingFmt = getCoding(strInput) if strCodingFmt == "gbk": return strInput elif strCodingFmt == "unicode": return strInput.encode("gbk") elif strCodingFmt == "utf8": return strInput.decode("utf8").encode("gbk")s = "中文"if isinstance(s, unicode): #s=u"中文" print s.encode('gb2312') print "我是Unicode编码的"elif getCoding(s) == "utf8": #s="中文" print s.decode('utf-8').encode('gb2312') print "我是utf-8编码的"else: print s.decode('gbk').encode('gbk') print "我是gbk编码的" 上图结果一：以utf-8格式保存的py文件。图二：以ascii格式保存的py文件。 编码检测包 chardet 知识点：因此，转码的时候一定要先搞明白，字符串str是什么编码，然后decode成unicode，然后再encode成其他编码 插入数据库报错的解决方案:UnicodeDecodeError: ‘ascii’ codec can’t decode byte 123import sysreload(sys)sys.setdefaultencoding(&apos;utf8&apos;) Unicode字符串除了多了一个 u 之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效： 转义： 1234567891011u'中文\n日文\n韩文'#多行：u'''第一行第二行'''#raw+多行：ur'''Python的Unicode字符串支持"中文","日文","韩文"等多种语言''' 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释 1234# -*- coding: utf-8 -*-#简洁版#coding=utf-8 目的是告诉Python解释器，用UTF-8编码读取源代码。然后用Notepad++ 另存为… 并选择UTF-8格式保存。 编程任务：用多行Unicode字符串表示下面的唐诗并打印： 静夜思 床前明月光，疑是地上霜。举头望明月，低头思故乡。 知识点: https://www.python.org/dev/peps/pep-0263/ python定义文件编码到底用哪种？ 12345# coding=&lt;encoding name&gt; #!/usr/bin/python# -*- coding: &lt;encoding name&gt; -*-#!/usr/bin/python# vim: set fileencoding=&lt;encoding name&gt; : 这些都可以只要第一二行能满足如下正则表达式 1^[ \t\v]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+) 12345678910# -*- coding: utf-8 -*-# This Python file uses the following encoding: utf-8# 花式标明print '''静夜思床前明月光，疑是地上霜。举头望明月，低头思故乡。''' 如果不标明文件编码或找不到。python会默认你是ASCII 整数和浮点数Python支持对整数和浮点数直接进行四则混合运算，运算规则和数学上的四则运算规则完全一致。 基本的运算： 1231 + 2 + 3 # ==&gt; 64 * 5 - 6 # ==&gt; 147.5 / 8 + 2.1 # ==&gt; 3.0375 使用括号可以提升优先级，这和数学运算完全一致，注意只能使用小括号，但是括号可以嵌套很多层： 12(1 + 2) * 3 # ==&gt; 9(2.2 + 3.3) / (1.5 * (9 - 0.3)) # ==&gt; 0.42145593869731807 和数学运算不同的地方是，Python的整数运算结果仍然是整数，浮点数运算结果仍然是浮点数： 121 + 2 # ==&gt; 整数 31.0 + 2.0 # ==&gt; 浮点数 3.0 但是整数和浮点数混合运算的结果就变成浮点数了： 11 + 2.0 # ==&gt; 浮点数 3.0 为什么要区分整数运算和浮点数运算呢？ 这是因为整数运算的结果永远是精确的，而浮点数运算的结果不一定精确，因为计算机内存再大，也无法精确表示出无限循环小数，比如 0.1 换成二进制表示就是无限循环小数。 那整数的除法运算遇到除不尽的时候，结果难道不是浮点数吗？我们来试一下： 111 / 4 # ==&gt; 2 令很多初学者惊讶的是，Python的整数除法，即使除不尽，结果仍然是整数，余数直接被扔掉。不过，Python提供了一个求余的运算 % 可以计算余数： 111 % 4 # ==&gt; 3 如果我们要计算 11 / 4 的精确结果，按照“整数和浮点数混合运算的结果是浮点数”的法则，把两个数中的一个变成浮点数再运算就没问题了： 111.0 / 4 # ==&gt; 2.75 编程任务：请计算 2.5 + 10 / 4 ,并解释计算结果为什么不是期望的 5.0 ? 请修复上述运算，使得计算结果是 5.0 1print 2.5 + 10.0 / 4 运行结果： 15.0 布尔类型我们已经了解了Python支持布尔类型的数据，布尔类型只有True和False两种值，但是布尔类型有以下几种运算： 与运算：只有两个布尔值都为 True 时，计算结果才为 True。 1234True and True # ==&gt; TrueTrue and False # ==&gt; FalseFalse and True # ==&gt; FalseFalse and False # ==&gt; False 或运算：只要有一个布尔值为 True，计算结果就是 True。 1234True or True # ==&gt; TrueTrue or False # ==&gt; TrueFalse or True # ==&gt; TrueFalse or False # ==&gt; False 非运算：把True变为False，或者把False变为True： 12not True # ==&gt; Falsenot False # ==&gt; True 布尔运算在计算机中用来做条件判断，根据计算结果为True或者False，计算机可以自动执行不同的后续代码。 在Python中，布尔类型还可以与其他数据类型做 and、or和not运算，请看下面的代码： 知识点：Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True。短路运算 12a = Trueprint a and 'a=T' or 'a=F' 计算结果不是布尔类型，而是字符串 &#39;a=T&#39;，这是为什么呢？ 因为Python把0、空字符串’’和None看成 False，其他数值和非空字符串都看成 True，所以： True and ‘a=T’ 计算结果是 ‘a=T’继续计算 ‘a=T’ or ‘a=F’ 计算结果还是 ‘a=T’要解释上述结果，又涉及到 and 和 or 运算的一条重要法则：短路计算。 在计算 a and b时，如果 a 是 False，则根据与运算法则，整个结果必定为 False，因此返回 a；如果 a 是 True，则整个计算结果必定取决与 b，因此返回 b。 在计算 a or b 时，如果 a 是 True，则根据或运算法则，整个计算结果必定为 True，因此返回 a；如果 a 是 False，则整个计算结果必定取决于 b，因此返回 b。 所以Python解释器在做布尔运算时，只要能提前确定计算结果，它就不会往后算了，直接返回结果。 编码任务：请运行如下代码，并解释打印的结果： 1234a = 'python'print 'hello,', a or 'world'b = ''print 'hello,', b or 'world' 1234567# -*- coding: utf-8 -*-a = 'python'print 'hello,', a or 'world'#a为非空，则输出ab = ''#b为空，输出worldprint 'hello,', b or 'world' 运行结果： 12hello, pythonhello, world Python集合类型:list和tuple创建listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 12&gt;&gt;&gt; ['Michael', 'Bob', 'Tracy']['Michael', 'Bob', 'Tracy'] list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。 构造list非常简单，按照上面的代码，直接用 [ ]把list的所有元素都括起来，就是一个list对象。通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list： 123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates # 打印classmates变量的内容['Michael', 'Bob', 'Tracy'] 由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据： 1&gt;&gt;&gt; L = [&apos;Michael&apos;, 100, True] 一个元素也没有的list，就是空list： 1&gt;&gt;&gt; empty_list = [] 编程任务 假设班里有3名同学：Adam，Lisa和Bart，他们的成绩分别是 95.5，85 和 59，请按照 名字, 分数, 名字, 分数… 的顺序按照分数从高到低用一个list表示，然后打印出来。 12L = ['Adam', 95.5,'Lisa', 85, 'Bart', 59]print L 运行结果: 1[&apos;Adam&apos;, 95.5, &apos;Lisa&apos;, 85, &apos;Bart&apos;, 59] 注：list本身就是有序的。所以直接打印即可。 Python按照索引访问list由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。 需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。 因此，要打印第一名同学的名字，用 L[0]: 12345678910&gt;&gt;&gt; print L[0]Adam#要打印第二名同学的名字，用 L[1]:&gt;&gt;&gt; print L[1]Lisa#要打印第三名同学的名字，用 L[2]:&gt;&gt;&gt; print L[2]Bart 要打印第四名同学的名字，用 L[3]: 1234&gt;&gt;&gt; print L[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range 报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。 所以，使用索引时，千万注意不要越界。 编程任务 三名同学的成绩可以用一个list表示：L = [95.5, 85, 59] 请按照索引分别打印出第一名、第二名、第三名，同时测试 print L[3]。 实现代码： 12345L = [95.5,85,59]print L[0]print L[1]print L[2]print L[3] 运行结果： 1234567Traceback (most recent call last): File &quot;index.py&quot;, line 5, in print L[3]IndexError: list index out of range95.58559 知识点：正序从0开始，逆序从-1开始是最好一个list内容。 当索引数字为负数时，表示逆序读出List中的内容，记住List的最后一个空间的编号为-1开始 倒序访问list我们还是用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 这时，老师说，请分数最低的同学站出来。 要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2： 12&gt;&gt;&gt; print L[2]Bart Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素： 12&gt;&gt;&gt; print L[-1]Bart Bart同学表示躺枪。 类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示： 123456789&gt;&gt;&gt; print L[-2]Lisa&gt;&gt;&gt; print L[-3]Adam&gt;&gt;&gt; print L[-4]Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;IndexError: list index out of rangeL[-4] 报错了，因为倒数第四不存在，一共只有3个元素。 使用倒序索引时，也要注意不要越界。 编程任务 三名同学的成绩可以用一个list表示：L = [95.5, 85, 59] 请按照倒序索引分别打印出倒数第一、倒数第二、倒数第三。 实现代码： 12345L = [95.5, 85, 59]print L[-1]print L[-2]print L[-3]print L[-4] 运行结果： 1234567Traceback (most recent call last): File &quot;index.py&quot;, line 5, in print L[-4]IndexError: list index out of range598595.5 list添加新元素(append insert)现在，班里有3名同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？ 第一个办法是用 list 的 append() 方法，把新同学追加到 list 的末尾： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.append(&apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] append()总是把新的元素添加到 list 的尾部。 如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？ 方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.insert(0, &apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Paul&apos;, &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] L.insert(0, &#39;Paul&#39;) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。 编程任务 假设新来一名学生Paul，Paul 同学的成绩比Bart好，但是比Lisa差，他应该排到第三名的位置，请用代码实现。 代码实现: 123L = ['Adam', 'Lisa', 'Bart']L.insert(2,'paul')print L 运行结果: 1['Adam', 'Lisa', 'paul', 'Bart'] 正向第三名索引号为2.倒数第三名索引号为-3 list删除元素(pop)Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？ 如果Paul同学排在最后一个，我们可以用list的pop()方法删除： 12345&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L.pop()&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。 如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;] 要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉： 1234&gt;&gt;&gt; L.pop(2)&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 两种方式：直接pop()默认删除第一个，括号内指定参数：索引，删除索引位置上。 编码任务1L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;] Paul的索引是2，Bart的索引是3，如果我们要把Paul和Bart都删掉，请解释下面的代码为什么不能正确运行： 12L.pop(2)L.pop(3) 怎样调整代码可以把Paul和Bart都正确删除掉？ 解释：因为语句是按顺序执行的删除了Paul之后。索引号3已经越界。我们要删除的Bart已经变成2了。 知识点：这教育我们删除list时要秉着从前到后顺序。 List替换元素假设现在班里仍然是3名同学： &gt;&gt;&gt; L = [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;] 现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。 另一个办法是直接用Paul把Bart给替换掉： 123&gt;&gt;&gt; L[2] = &apos;Paul&apos;&gt;&gt;&gt; print LL = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;] 对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。 由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作： &gt;&gt;&gt; L[-1] = &#39;Paul&#39; 编程任务 班里的同学按照分数排名是这样的：L = [‘Adam’, ‘Lisa’, ‘Bart’]但是，在一次考试后，Bart同学意外取得第一，而Adam同学考了倒数第一。 请通过对list的索引赋值，生成新的排名。 实现代码： 1234L = ['Adam', 'Lisa', 'Bart']L[0]='Bart'L[-1]='Adam'print L 运行结果： 1[&apos;Bart&apos;, &apos;Lisa&apos;, &apos;Adam&apos;] 创建tupletuple是另一种有序的列表，中文翻译为“ 元组 ”。tuple 和 list 非常类似，但是，知识点：tuple一旦创建完毕，就不能修改了。 同样是表示班里同学的名称，用tuple表示如下： 1&gt;&gt;&gt; t = (&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;) 创建tuple和创建list唯一不同之处是用( )替代了[ ]。 现在，这个 t 就不能改变了，tuple没有 append()方法，也没有insert()和pop()方法。所以，新同学没法直接往 tuple 中添加，老同学想退出 tuple 也不行。 获取 tuple 元素的方式和 list 是一模一样的，我们可以正常使用 t[0]，t[-1]等索引方式访问元素，但是不能赋值成别的元素，不信可以试试： 1234&gt;&gt;&gt; t[0] = &apos;Paul&apos;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &apos;tuple&apos; object does not support item assignment 编程任务 创建一个tuple，顺序包含0 - 9这10个数。 实现代码： 12t = (0,1,2,3,4,5,6,7,8,9)print t 运行结果： 1(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) 创建单元素tupletuple和list一样，可以包含 0 个、1个和任意多个元素。 包含多个元素的 tuple，前面我们已经创建过了。 包含 0 个元素的 tuple，也就是空tuple，直接用 ()表示： 123&gt;&gt;&gt; t = ()&gt;&gt;&gt; print t() 创建包含1个元素的 tuple 呢？来试试： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; print t1 好像哪里不对！t 不是 tuple ，而是整数1。为什么呢？ 知识点：单元素tuple的()被当做优先级。(1)变成整数1.单元素括号结尾加, 因为()既可以表示tuple，又可以作为括号表示运算时的优先级，结果 (1) 被Python解释器计算出结果 1，导致我们得到的不是tuple，而是整数 1。 正是因为用()定义单元素的tuple有歧义，所以 Python 规定，单元素 tuple 要多加一个逗号,，这样就避免了歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; print t(1,) Python在打印单元素tuple时，也自动添加了一个,，为了更明确地告诉你这是一个tuple。 多元素 tuple 加不加这个额外的,效果是一样的： 123&gt;&gt;&gt; t = (1, 2, 3,)&gt;&gt;&gt; print t(1, 2, 3) 编程任务下面代码为什么没有创建出包含一个学生的 tuple： 12t = ('Adam')print t 请修改代码，确保 t 是一个tuple。 因为单元素tuple的括号被当做是优先级标志。要加上额外,标识这是一个元组。 实现代码： 12t = ('Adam',)print t 运行结果: 1(&apos;Adam&apos;,) “可变”的tuple(指向不变。指向的东西可以变)前面我们看到了tuple一旦创建就不能修改。现在，我们来看一个可变的tuple： 1&gt;&gt;&gt; t = (&apos;a&apos;, &apos;b&apos;, [&apos;A&apos;, &apos;B&apos;]) 注意到 t 有 3 个元素：&#39;a&#39;，&#39;b&#39;和一个list：[&#39;A&#39;, &#39;B&#39;]。list作为一个整体是tuple的第3个元素。list对象可以通过 t[2] 拿到： 12345&gt;&gt;&gt; L = t[2]# 然后，我们把list的两个元素改一改：&gt;&gt;&gt; L[0] = 'X'&gt;&gt;&gt; L[1] = 'Y' 再看看tuple的内容： 12&gt;&gt;&gt; print t(&apos;a&apos;, &apos;b&apos;, [&apos;X&apos;, &apos;Y&apos;]) 不是说tuple一旦定义后就不可变了吗？怎么现在又变了？ 别急，我们先看看定义的时候tuple包含的3个元素： 当我们把list的元素’A’和’B’修改为’X’和’Y’后，tuple变为： 表面上看，tuple的元素确实变了，但其实变的不是 tuple 的元素，而是list的元素。 tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 理解了指向不变后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。 编程任务： 定义了tuple：t = (‘a’, ‘b’, [‘A’, ‘B’]) 由于 t 包含一个list元素，导致tuple的内容是可变的。能否修改上述代码，让tuple内容不可变？ 解答：将里面的list替换成一个不可变的元素。比如tuple。 实现代码: 12t = (&apos;a&apos;, &apos;b&apos;, (&apos;A&apos;, &apos;B&apos;))print t 运行结果： 1(&apos;a&apos;, &apos;b&apos;, (&apos;A&apos;, &apos;B&apos;)) Python的条件判断和循环语句if语句计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现： 12345age = 20if age &gt;= 18: print 'your age is', age print 'adult'print 'END' 注意: Python代码的缩进规则。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。 知识点: 缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。 注意: if 语句后接表达式，然后用:表示代码块开始。 如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车： 12345&gt;&gt;&gt; age = 20&gt;&gt;&gt; if age &gt;= 18:... print &apos;your age is&apos;, age... print &apos;adult&apos;... 12your age is 20adult 编程任务 如果成绩达到60分或以上，视为passed。 假设Bart同学的分数是75，请用if语句判断是否能打印出 passed: 实现代码: 123score = 75if score&gt;=60: print 'passed' 运行结果: 1passed if-else当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块： 12if age &gt;= 18: print 'adult' 如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，怎么办？ 方法是再写一个 if: 12if age &lt; 18: print 'teenager' 或者用 not 运算： 12if not age &gt;= 18: print 'teenager' 细心的同学可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if ... else ... 语句把它们统一起来： 1234if age &gt;= 18: print 'adult'else: print 'teenager' 利用 if ... else ...语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。 注意: else 后面有个:。 编程任务 如果成绩达到60分或以上，视为passed，否则视为failed。 假设Bart同学的分数是55，请用if语句打印出 passed 或者 failed: 实现代码： 12345score = 55if score&gt;=60: print 'passed'else: print 'failed' 运行结果: 1failed if-elif-else有的时候，一个 if … else … 还不够用。比如，根据年龄的划分： 条件1：18岁或以上：adult 条件2：6岁或以上：teenager 条件3：6岁以下：kid 我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3： 1234567if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: print &apos;kid&apos; 这样写出来，我们就得到了一个两层嵌套的 if … else … 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby： 12345678910if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: if age &gt;= 3: print &apos;kid&apos; else: print &apos;baby&apos; 这种缩进只会越来越多，代码也会越来越难看。 要避免嵌套结构的 if … else …，我们可以用 if … 多个elif … else … 的结构，一次写完所有的规则： 12345678if age &gt;= 18: print &apos;adult&apos;elif age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 3: print &apos;kid&apos;else: print &apos;baby&apos; elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。 特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。 请思考下面的代码： 1234567age = 8if age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 18: print &apos;adult&apos;else: print &apos;kid&apos; 当 age = 8 时，结果正确，但 age = 20 时，为什么没有打印出 adult？ 如果要修复，应该如何修复？ 知识点解答: 因为当age=20.第一个条件&gt;=6满足就短路了。因此我们在设置条件应该从严格到松泛. 1234567age = 20if age &gt;= 18: print &apos;teenager&apos;elif age &gt;= 6: print &apos;adult&apos;else: print &apos;kid&apos; 编程任务 如果按照分数划定结果： 90分或以上：excellent 80分或以上：good 60分或以上：passed 60分以下：failed 请编写程序根据分数打印结果。 实现代码: 12345678910score = 85if score&gt;=90: print 'excellent'elif score&gt;=80: print 'good'elif score&gt;=60: print 'passed'else: print 'failed' 运行结果: 1good for循环list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list： 1234L = ['Adam', 'Lisa', 'Bart']print L[0]print L[1]print L[2] 如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。 这时，循环就派上用场了。 Python的 for 循环就可以依次把list或tuple的每个元素迭代出来： 123L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]for name in L: print name 注意: name 这个变量是在 for 循环中定义的(这是一个临时变量名字可自定义)，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。 这样一来，遍历一个list或tuple就非常容易了。 编程任务 班里考试后，老师要统计平均成绩，已知4位同学的成绩用list表示如下：L = [75, 92, 59, 68] 请利用for循环计算出平均成绩。 实现代码: 12345L = [75, 92, 59, 68]sum = 0.0for x in L: sum =sum+xprint sum / 4 运行结果： 173.5 while循环和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。 比如要从 0 开始打印不大于 N 的整数： 12345N = 10x = 0while x &lt; N: print x x = x + 1 while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块,否则，退出循环。 在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。 如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。 编程任务 利用while循环计算100以内奇数的和。 实现代码: 123456sum = 0x = 1while x&lt;=100: sum=sum+x x=x+2print sum 知识点: 奇数只需要从1开始不断加2都是奇数。 运行结果： 12500 break退出循环用for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。 比如计算1至100的整数和，我们用while来实现： 12345678sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum 咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。 编程任务 利用 while True 无限循环配合 break 语句，计算 1 + 2 + 4 + 8 + 16 + … 的前20项的和。 实现代码: 12345678910sum = 0x = 1n = 1while True: sum =sum+x x =2*x n =n+1 if n &gt;20: breakprint sum 运行结果: 11048575 continue继续循环在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。 假设我们已经写好了利用for循环计算平均分的代码： 1234567L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L: sum = sum + x n = n + 1print sum / n 现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环： 12345for x in L: if x &lt; 60: continue sum = sum + x n = n + 1 coutinue: 跳过下面的代码。开始下一次循环。 编程任务 对已有的计算 0 - 100 的while循环进行改造，通过增加 continue 语句，使得只计算奇数的和： 12345678sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum 思路: if判断到是偶数，continue跳过。 实现代码: 1234567891011sum = 0x = 0while True: x = x + 1 if x &gt; 100: break if x%2==0: continue sum = sum+x print sum 运行结果: 12500 多重循环(嵌套循环)在循环内部，还可以嵌套循环，我们来看一个例子： 123for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]: print x + y x 每循环一次，y就会循环 3 次，这样，我们可以打印出一个全排列： 123456789A1A2A3B1B2B3C1C2C3 编程任务 对100以内的两位数，请使用一个两重循环打印出所有十位数数字比个位数数字小的数，例如，23（2 &lt; 3）。 代码实现。 123456tens_place = [1,2,3,4,5,6,7,8,9]ones_place = [0,1,2,3,4,5,6,7,8,9]for x in tens_place: for y in ones_place: if x&lt;y: print x*10 + y 运行结果： 12345678910121314151617181923略 重要的数据类型Dict和Set什么是dict我们已经知道，list 和 tuple 可以用来表示顺序集合，例如，班里同学的名字： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 或者考试的成绩列表： 1[95, 85, 59] 但是，要根据名字找到对应的成绩，用两个 list 表示就不方便。 如果把名字和分数关联起来，组成类似的查找表： 123&apos;Adam&apos; ==&gt; 95&apos;Lisa&apos; ==&gt; 85&apos;Bart&apos; ==&gt; 59 给定一个名字，就可以直接查到分数。 Python的 dict 就是专门干这件事的。用 dict 表示名字-成绩的查找表如下： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 我们把名字称为key，对应的成绩称为value，dict就是通过 key来查找 value。 花括号 {} 表示这是一个dict，然后按照 key: value, 写出来即可。最后一个 key: value 的逗号可以省略。 知识点： 区别小课堂 单元素的tuple必须在后面多加一个逗号。 dict最后的逗号可以省略 由于dict也是集合，len() 函数可以计算任意集合的大小： 12&gt;&gt;&gt; len(d)3 知识点：注意: 一个 key-value 算一个，因此，dict大小为3。 编程任务 新来的Paul同学成绩是 75 分，请编写一个dict，把Paul同学的成绩也加进去。 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 实现代码: 1234567d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 75 &#125; 访问dict我们已经能创建一个dict，用于表示名字和成绩的对应关系： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 那么，如何根据名字来查找对应的成绩呢？ 可以简单地使用 d[key] 的形式来查找对应的 value，这和 list 很像，不同之处是，list 必须使用索引返回对应的元素，而dict使用key： 1234567&gt;&gt;&gt; print d[&apos;Adam&apos;]95&gt;&gt;&gt; print d[&apos;Paul&apos;]Traceback (most recent call last): File &quot;index.py&quot;, line 11, in &lt;module&gt; print d[&apos;Paul&apos;]KeyError: &apos;Paul&apos; 注意: 通过 key 访问 dict 的value，只要 key 存在，dict就返回对应的value。如果key不存在，会直接报错：KeyError。 知识点：避免 KeyError 发生，有两个办法： 是先判断一下 key 是否存在，用 in 操作符： 12if &apos;Paul&apos; in d: print d[&apos;Paul&apos;] 如果 ‘Paul’ 不存在，if语句判断为False，自然不会执行 print d[‘Paul’] ，从而避免了错误。 是使用dict本身提供的一个get方法，在Key不存在的时候，返回None： 1234&gt;&gt;&gt; print d.get(&apos;Bart&apos;)59&gt;&gt;&gt; print d.get(&apos;Paul&apos;)None 编程任务根据如下dict：12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 请打印出：Adam: 95Lisa: 85Bart: 59 实现代码: 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125;print &apos;Adam:&apos;,d[&apos;Adam&apos;]print &apos;Lisa:&apos;,d.get(&apos;Lisa&apos;)print &apos;Bart:&apos;,d[&apos;Bart&apos;] 运行结果： 123Adam: 95Lisa: 85Bart: 59 dict的特点知识点：dict查找速度快。list查找速度随着元素增加而逐渐下降。缺点：内存占用大。list慢但内存占用小。 dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样。而list的查找速度随着元素增加而逐渐下降。 不过dict的查找速度快不是没有代价的，dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。 由于dict是按 key 查找，所以，在一个dict中，key不能重复。 dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 当我们试图打印这个dict时： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 打印的顺序不一定是我们创建时的顺序，而且，不同的机器打印的顺序都可能不同，这说明 知识点:dict内部是无序的，不能用dict存储有序的集合。 知识点：dict的第三个特点是作为 key 的元素必须不可变，Python的基本类型如字符串、整数、浮点数都是不可变的，都可以作为 key。 但是list是可变的，就不能作为 key。 可以试试用list作为key时会报什么样的错误。 不可变这个限制仅作用于key，value是否可变无所谓： 12345&#123; &apos;123&apos;: [1, 2, 3], # key 是 str，value是list 123: &apos;123&apos;, # key 是 int，value 是 str (&apos;a&apos;, &apos;b&apos;): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean&#125; 最常用的key还是字符串，因为用起来最方便。 编程任务 请设计一个dict，可以根据分数来查找名字，已知成绩如下： 123Adam: 95,Lisa: 85,Bart: 59. 实现代码: 12345d = &#123; 95:&apos;Adam&apos;, 85:&apos;Lisa&apos;, 59:&apos;Bart&apos;&#125; 运行结果：无 更新dictdict是可变的，也就是说，我们可以随时往dict中添加新的 key-value。比如已有dict： 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 要把新同学’Paul’的成绩 72 加进去，用赋值语句： 1&gt;&gt;&gt; d[&apos;Paul&apos;] = 72 再看看dict的内容： 12&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 59&#125; 如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value： 123&gt;&gt;&gt; d[&apos;Bart&apos;] = 60&gt;&gt;&gt; print d&#123;&apos;Lisa&apos;: 85, &apos;Paul&apos;: 72, &apos;Adam&apos;: 95, &apos;Bart&apos;: 60&#125; 编程任务 请根据Paul的成绩 72 更新下面的dict：123456789d = &#123; 95: &apos;Adam&apos;, 85: &apos;Lisa&apos;, 59: &apos;Bart&apos;&#125; 实现代码: 1234567d = &#123; 95: 'Adam', 85: 'Lisa', 59: 'Bart'&#125;d[72] = 'Paul'print d 运行结果： 1&#123;72: &apos;Paul&apos;, 59: &apos;Bart&apos;, 85: &apos;Lisa&apos;, 95: &apos;Adam&apos;&#125; 遍历dict由于dict也是一个集合，所以，遍历dict和遍历list类似，都可以通过 for 循环实现。 直接使用for循环可以遍历 dict 的 key： 1234567&gt;&gt;&gt; d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125;&gt;&gt;&gt; for key in d:... print key... LisaAdamBart 由于通过 key 可以获取对应的 value，因此，在循环体内，可以获取到value的值。 注：这里的key只是一个约定俗称的变量，可以改为其他名字。但是推荐用key。 编程任务 请用 for 循环遍历如下的dict，打印出 name: score 来。 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125; 实现代码： 1234567d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59&#125;for key in d: print key+&quot;:&quot;,d[key] 运行结果: 123Lisa: 85Adam: 95Bart: 59 什么是setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。 有的时候，我们只想要 dict 的 key，不关心 key 对应的 value，目的就是保证这个集合的元素不会重复，这时，set就派上用场了。 set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。 知识点: 创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： 12345&gt;&gt;&gt; s = set(['A', 'B', 'C'])可以查看 set 的内容：&gt;&gt;&gt; print sset(['A', 'C', 'B']) 请注意，上述打印的形式类似 list， 但它不是 list，仔细看还可以发现，打印的顺序和原始 list 的顺序有可能是不同的，因为set内部存储的元素是无序的。 因为set不能包含重复的元素，所以，当我们传入包含重复元素的 list 会怎么样呢？ 12345&gt;&gt;&gt; s = set([&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;C&apos;])&gt;&gt;&gt; print sset([&apos;A&apos;, &apos;C&apos;, &apos;B&apos;])&gt;&gt;&gt; len(s)3 结果显示，set会自动去掉重复的元素，原来的list有4个元素，但set只有3个元素。 编程任务 请用set表示班里的4位同学：Adam, Lisa, Bart, Paul 实现代码: 12s = set(['Adam', 'Lisa', 'Bart', 'Paul'])print s 运行结果: 1set([&apos;Lisa&apos;, &apos;Paul&apos;, &apos;Adam&apos;, &apos;Bart&apos;]) 访问set由于set存储的是无序集合，所以我们没法通过索引来访问。 访问 set中的某个元素实际上就是判断一个元素是否在set中。 例如，存储了班里同学名字的set： 1&gt;&gt;&gt; s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]) 我们可以用 in 操作符判断： Bart是该班的同学吗？ 12345678910&gt;&gt;&gt; &apos;Bart&apos; in sTrueBill是该班的同学吗？&gt;&gt;&gt; &apos;Bill&apos; in sFalsebart是该班的同学吗？&gt;&gt;&gt; &apos;bart&apos; in sFalse 知识点：大小写很重要，’Bart’ 和 ‘bart’被认为是两个不同的元素。 编程任务 由于上述set不能识别小写的名字，请改进set，使得 ‘adam’ 和 ‘bart’都能返回True。 既然大小写是不同的。那我们的set中就把大小写都包含。 实现代码: 123s = set(['Adam', 'Lisa', 'Bart', 'Paul','adam', 'lisa', 'bart', 'paul'])print 'adam' in sprint 'bart' in s 运行结果. 12TrueTrue set的特点set的内部结构和dict很像，唯一区别是不存储value，因此，判断一个元素是否在set中速度很快。 set存储的元素和dict的key类似，必须是不变对象，因此，任何可变对象是不能放入set中的。 最后，set存储的元素也是没有顺序的。 set的这些特点，可以应用在哪些地方呢？ 星期一到星期日可以用字符串&#39;MON&#39;, &#39;TUE&#39;, ... &#39;SUN&#39;表示。 假设我们让用户输入星期一至星期日的某天，如何判断用户的输入是否是一个有效的星期呢？ 可以用 if 语句判断，但这样做非常繁琐： 12345x = '???' # 用户输入的字符串if x!= 'MON' and x!= 'TUE' and x!= 'WED' ... and x!= 'SUN': print 'input error'else: print 'input ok' 注意：if 语句中的…表示没有列出的其它星期名称，测试时，请输入完整。 如果事先创建好一个set，包含&#39;MON&#39; ~ &#39;SUN&#39;： 1weekdays = set([&apos;MON&apos;, &apos;TUE&apos;, &apos;WED&apos;, &apos;THU&apos;, &apos;FRI&apos;, &apos;SAT&apos;, &apos;SUN&apos;]) 再判断输入是否有效，只需要判断该字符串是否在set中： 123456x = '???' # 用户输入的字符串if x in weekdays: print 'input ok'else: print 'input error'这样一来，代码就简单多了。 编程任务 月份也可以用set表示，请设计一个set并判断用户输入的月份是否有效。月份可以用字符串&#39;Jan&#39;, &#39;Feb&#39;, ...表示。 实现代码: 12345678910111213months = set(['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul','Aug','Sep','Oct','Nov','Dec'])x1 = 'Feb'x2 = 'Sun'if x1 in months: print 'x1: ok'else: print 'x1: error'if x2 in months: print 'x2: ok'else: print 'x2: error' 运行结果: 12x1: okx2: error 遍历set由于 set 也是一个集合，所以，遍历 set 和遍历 list 类似，都可以通过 for 循环实现。 直接使用 for 循环可以遍历 set 的元素： 1234567&gt;&gt;&gt; s = set(['Adam', 'Lisa', 'Bart'])&gt;&gt;&gt; for name in s:... print name... LisaAdamBart 注意: 观察 for 循环在遍历set时，元素的顺序和list的顺序很可能是不同的，而且不同的机器上运行的结果也可能不同。 编程任务 请用 for 循环遍历如下的set，打印出 name: score 来。 1s = set([(&apos;Adam&apos;, 95), (&apos;Lisa&apos;, 85), (&apos;Bart&apos;, 59)]) 上面这个set中的每一个元素又是一个字典。 set([ ])是壳子。 (&#39;Adam&#39;, 95), (&#39;Lisa&#39;, 85), (&#39;Bart&#39;, 59)才是真正的内容 实现代码： 123s = set([('Adam', 95), ('Lisa', 85), ('Bart', 59)])for name,score in s: print name,':',score 运行结果: 123Lisa : 85Adam : 95Bart : 59 更新set(add remove)由于set存储的是一组不重复的无序元素，因此，更新set主要做两件事： 是把新的元素添加到set中 是把已有元素从set中删除。(前提是如果有) 添加元素时，用set的add()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; print sset([1, 2, 3, 4]) 如果添加的元素已经存在于set中，add()不会报错，但是不会加进去了： 1234&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(3)&gt;&gt;&gt; print sset([1, 2, 3]) 删除set中的元素时，用set的remove()方法： 1234&gt;&gt;&gt; s = set([1, 2, 3, 4])&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; print sset([1, 2, 3]) 如果删除的元素不存在set中，remove()会报错： 12345&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.remove(4)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 4 所以用add()可以直接添加，而remove()前需要判断。 编程任务 针对下面的set，给定一个list，对list中的每一个元素，如果在set中，就将其删除，如果不在set中，就添加进去。 12s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;])L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 实现代码： 12345678s = set(['Adam', 'Lisa', 'Paul'])L = ['Adam', 'Lisa', 'Bart', 'Paul']for name in L: if name in s: s.remove(name) else: s.add(name)print s 函数定义与调用什么是函数我们知道圆的面积计算公式为： S = πr² 当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积： 123456r1 = 12.34r2 = 9.08r3 = 73.1s1 = 3.14 * r1 * r1s2 = 3.14 * r2 * r2s3 = 3.14 * r3 * r3 当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。 有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用 s = area_of_circle(x)，而函数 area_of_circle本身只需要写一次，就可以多次调用。 抽象是数学中非常常见的概念。举个例子： 计算数列的和，比如：1 + 2 + 3 + … + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + … + 100记作： 123100∑nn=1 这种抽象记法非常强大，因为我们看到∑就可以理解成求和，而不是还原成低级的加法运算。 而且，这种抽象记法是可扩展的，比如： 123100∑(n²+1)n=1 还原成加法运算就变成了： (1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + ... + (100 x 100 + 1)可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。 写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。 Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。 编程任务 写一个函数 实现代码： 12s = area_of_circle(x)area_of_circle(x) 运行结果： 调用函数,内置函数Python内置了很多有用的函数，我们可以直接调用。 要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数 abs，它接收一个参数。 可以直接从Python的官方网站查看文档：http://docs.python.org/2/library/functions.html#abs 也可以在交互式命令行通过 help(abs)查看abs函数的帮助信息。 调用 abs 函数： 123456&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34 调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个： 1234&gt;&gt;&gt; abs(1, 2)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given) 如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型： 1234&gt;&gt;&gt; abs(&apos;a&apos;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: bad operand type for abs(): &apos;str&apos; 而比较函数 cmp(x, y) 就需要两个参数，如果 x&lt;y，返回 -1，如果 x==y，返回0，如果 x&gt;y，返回 1： 123456&gt;&gt;&gt; cmp(1, 2)-1&gt;&gt;&gt; cmp(2, 1)1&gt;&gt;&gt; cmp(3, 3)0 Python内置的常用函数还包括数据类型转换函数，比如 int()函数可以把其他数据类型转换为整数： 1234&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(12.34)12 str()函数把其他类型转换成 str： 1234&gt;&gt;&gt; str(123)&apos;123&apos;&gt;&gt;&gt; str(1.23)&apos;1.23&apos; 编程任务 sum()函数接受一个list作为参数，并返回list所有元素之和。请计算 1*1 + 2*2 + 3*3 + ... + 100*100。 实现代码： 1234567L = []L = []x = 1while x &lt;= 100: L.append(x * x) x = x + 1print sum(L) 运行结果: 1338350 编写函数在Python中，定义一个函数要使用 def 语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用 return语句返回。 我们以自定义一个求绝对值的 my_abs 函数为例： 12345def my_abs(x): if x &gt;= 0: return x else: return -x 请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。 知识点； 如果没有return语句，函数执行完毕后也会返回结果，只是结果为 None。return None可以简写为return。 编程任务 请定义一个 square_of_sum 函数，它接受一个list，返回list中每个元素平方的和。 实现代码: 12345678def square_of_sum(L): sum = 0 for x in L: sum = x*x+sum return sumprint square_of_sum([1, 2, 3, 4, 5])print square_of_sum([-5, 0, 5, 15, 25]) 运行结果: 1255900 函数之返回”多值”函数可以返回多个值吗？答案是肯定的。 比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标： math包提供了sin()和 cos()函数，我们先用import引用它： 12345import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, ny 这样我们就可以同时获得返回值： 123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print x, y151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值： 123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print r(151.96152422706632, 70.0) 知识点：用print打印返回结果，原来返回值是一个tuple！ 但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，知识点：Python的函数返回多值其实就是返回一个tuple，但写起来更方便。 编程任务 一元二次方程的定义是：ax² + bx + c = 0 请编写一个函数，返回一元二次方程的两个解。 注意：Python的math包提供了sqrt()函数用于计算平方根。 实现代码: 12345678import mathdef quadratic_equation(a, b, c): t = math.sqrt(b*b - 4*a*c) return (-b + t) / (2 * a),( -b - t )/ (2 * a)print quadratic_equation(2, 3, 0)print quadratic_equation(1, -6, 5) 运行结果: 12(0.0, -1.5)(5.0, 1.0) 递归函数在函数内部，可以调用其他函数。知识点: 如果一个函数在内部调用自身本身，这个函数就是递归函数。 举个例子，我们来计算阶乘 n! = 1 * 2 * 3 * ... * n，用函数 fact(n)表示，可以看出： fact(n) = n! = 1 * 2 * 3 * ... * (n-1) * n = (n-1)! * n = fact(n-1) * n所以，fact(n)可以表示为 n * fact(n-1)，只有n=1时需要特殊处理。 于是，fact(n)用递归的方式写出来就是： 1234def fact(n): if n==1: return 1 return n * fact(n - 1) 上面就是一个递归函数。可以试试： 123456&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000 如果我们计算fact(5)，可以根据函数定义看到计算过程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 递归函数的优点是定义简单，逻辑清晰。知识点: 理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 知识点: 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试计算 fact(10000)。 编程任务(天涯) 汉诺塔 (http://baike.baidu.com/view/191666.htm) 的移动也可以看做是递归函数。 我们对柱子编号为a, b, c，将所有圆盘从a移到c可以描述为： 如果a只有一个圆盘，可以直接移动到c； 如果a有N个圆盘，可以看成a有1个圆盘（底盘） + (N-1)个圆盘，首先需要把 (N-1) 个圆盘移动到 b，然后，将 a的最后一个圆盘移动到c，再将b的(N-1)个圆盘移动到c。 请编写一个函数，给定输入 n, a, b, c，打印出移动的步骤： 1move(n, a, b, c) 例如，输入 move(2, ‘A’, ‘B’, ‘C’)，打印出： 123A --&gt; BA --&gt; CB --&gt; C 实现代码： 12345678def move(n, a, b, c): if n ==1: print a, '--&gt;', c return move(n-1, a, c, b) print a, '--&gt;', c move(n-1, b, a, c)move(4, 'A', 'B', 'C') 运行结果: 123456789101112131415A --&gt; BA --&gt; CB --&gt; CA --&gt; BC --&gt; AC --&gt; BA --&gt; BA --&gt; CB --&gt; CB --&gt; AC --&gt; AB --&gt; CA --&gt; BA --&gt; CB --&gt; C 定义默认参数定义函数的时候，还可以有默认参数。 例如Python自带的 int() 函数，其实就有两个参数，我们既可以传一个参数，又可以传两个参数： 1234&gt;&gt;&gt; int(&apos;123&apos;)123&gt;&gt;&gt; int(&apos;123&apos;, 8)83 知识点: int()函数的第二个参数是转换进制，如果不传，默认是十进制 (base=10)，如果传了，就用传入的参数。 可见，函数的默认参数的作用是简化调用，你只需要把必须的参数传进去。但是在需要的时候，又可以传入额外的参数来覆盖默认参数值。 我们来定义一个计算 x 的N次方的函数: 123456def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 假设计算平方的次数最多，我们就可以把 n 的默认值设定为 2： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 这样一来，计算平方就不需要传入两个参数了： 12&gt;&gt;&gt; power(5)25 知识点: 由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面： 123456# OK:def fn1(a, b=1, c=2): pass# Error:def fn2(a=1, b): pass 个人: 这里我们可以把自己想象成计算机。在自己感到为难不知道哪个是哪个的时候。那么恭喜你，计算机也不知道。 编程任务 请定义一个 greet()函数，它包含一个默认参数，如果没有传入，打印 &#39;Hello, world.&#39;，如果传入，打印 &#39;Hello, xxx.&#39; 实现代码: 12345def greet(x = 'World'): print 'Hello,'+x+'.'greet()greet('mtianyan') 运行结果: 12Hello,World.Hello,mtianyan. 知识点: 定义可变参数如果想让一个函数能接受任意个参数，我们就可以定义一个可变参数： 12def fn(*args): print args 可变参数的名字前面有个 * 号，我们可以传入0个、1个或多个参数给可变参数： 12345678&gt;&gt;&gt; fn()()&gt;&gt;&gt; fn('a')('a',)&gt;&gt;&gt; fn('a', 'b')('a', 'b')&gt;&gt;&gt; fn('a', 'b', 'c')('a', 'b', 'c') 可变参数也不是很神秘，Python解释器会把传入的一组参数组装成一个tuple传递给可变参数，因此，在函数内部，直接把变量 args 看成一个 tuple 就好了。 定义可变参数的目的也是为了简化调用。假设我们要计算任意个数的平均值，就可以定义一个可变参数： 12def average(*args): ... 这样，在调用的时候，可以这样写： 123456&gt;&gt;&gt; average()0&gt;&gt;&gt; average(1, 2)1.5&gt;&gt;&gt; average(1, 2, 2, 3, 4)2.4 编程任务 请编写接受可变参数的 average() 函数。 12345678910def average(*args): sum = 0.0 if len(args) == 0: return sum for x in args: sum = sum + x return sum / len(args)print average()print average(1, 2)print average(1, 2, 2, 3, 4) 运行结果: 1230.01.52.4 切片操作对list进行切片取一个list的部分元素是非常常见的操作。比如，一个list如下： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 取前3个元素，应该怎么做？ 笨办法： 12&gt;&gt;&gt; [L[0], L[1], L[2]][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 之所以是笨办法是因为扩展一下，取前N个元素就没辙了。 取前N个元素，也就是索引为0-(N-1)的元素，可以用循环： 1234567&gt;&gt;&gt; r = []&gt;&gt;&gt; n = 3&gt;&gt;&gt; for i in range(n):... r.append(L[i])... &gt;&gt;&gt; r[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。 对应上面的问题，取前3个元素，用一行代码就可以完成切片： 123&gt;&gt;&gt; L[0:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 知识点： [0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12&gt;&gt;&gt; L[:3][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 也可以从索引1开始，取出2个元素出来： 12&gt;&gt;&gt; L[1:3][&apos;Lisa&apos;, &apos;Bart&apos;] 只用一个 : ，表示从头到尾： 12&gt;&gt;&gt; L[:][&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 因此，L[:]实际上复制出了一个新list。 知识点: 切片操作还可以指定第三个参数： 12&gt;&gt;&gt; L[::2][&apos;Adam&apos;, &apos;Bart&apos;] 第三个参数表示每N个取一个，上面的 L[::2] 会每两个元素取出一个来，也就是隔一个取一个。 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 编程任务 range()函数可以创建一个数列： 12&gt;&gt;&gt; range(1, 101)[1, 2, 3, ..., 100] 请利用切片，取出： 前10个数； 3的倍数； 不大于50的5的倍数。 实现代码: 12345L = range(1, 101)print L[:10]print L[2::3]print L[4:50:5] 运行结果: 123[1, 2, 3, 4, 5, 6, 7, 8, 9, 10][3, 6, 9, 12, 15, 18, 21, 24, 27, 30, 33, 36, 39, 42, 45, 48, 51, 54, 57, 60, 63, 66, 69, 72, 75, 78, 81, 84, 87, 90, 93, 96, 99][5, 10, 15, 20, 25, 30, 35, 40, 45, 50] 倒序切片对于list，既然Python支持L[-1]取倒数第一个元素，那么它同样支持倒数切片，试试： 12345678910111213&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart', 'Paul']&gt;&gt;&gt; L[-2:]['Bart', 'Paul']&gt;&gt;&gt; L[:-2]['Adam', 'Lisa']&gt;&gt;&gt; L[-3:-1]['Lisa', 'Bart']&gt;&gt;&gt; L[-4:-1:2]['Adam', 'Bart'] 记住倒数第一个元素的索引是-1。知识点：倒序切片包含起始索引，不包含结束索引。 编程任务 利用倒序切片对 1 - 100 的数列取出： 最后10个数； 最后10个5的倍数。 实现代码： 123L = range(1, 101)print L[-10:]print L[-46::5] 对字符串切片字符串 &#39;xxx&#39;和 Unicode字符串 u&#39;xxx&#39;也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串： 123456&gt;&gt;&gt; &apos;ABCDEFG&apos;[:3]&apos;ABC&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[-3:]&apos;EFG&apos;&gt;&gt;&gt; &apos;ABCDEFG&apos;[::2]&apos;ACEG&apos; 在很多编程语言中，针对字符串提供了很多各种截取函数，其实目的就是对字符串切片。知识点：Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。 编程任务 字符串有个方法 upper() 可以把字符变成大写字母： 12&gt;&gt;&gt; &apos;abc&apos;.upper()&apos;ABC&apos; 但它会把所有字母都变成大写。请设计一个函数，它接受一个字符串，然后返回一个仅首字母变成大写的字符串。 提示：利用切片操作简化字符串操作。 实现代码: 123456def firstCharUpper(s): return s[0].upper() + s[1:]print firstCharUpper('hello')print firstCharUpper('sunday')print firstCharUpper('september') 运行结果： 123HelloSundaySeptember 各种迭代方式什么是迭代在Python中，如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。 在Python中，迭代是通过 for ... in 来完成的，而很多语言比如C或者Java，迭代list是通过下标完成的，比如Java代码： 123for (i=0; i&lt;list.length; i++) &#123; n = list[i];&#125; 可以看出，Python的for循环抽象程度要高于Java的for循环。 因为 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上。 因此，迭代操作就是对于一个集合，无论该集合是有序还是无序，我们用 for 循环总是可以依次取出集合的每一个元素。 注意: 集合是指包含一组元素的数据结构，我们已经介绍的包括： 有序集合：list，tuple，知识点: str和unicode； 无序集合：set 无序集合并且具有 key-value 对：dict 而迭代是一个动词，它指的是一种操作，在Python中，就是 for 循环。 迭代与按下标访问数组最大的不同是，后者是一种具体的迭代实现方式，而前者只关心迭代结果，根本不关心迭代内部是如何实现的。 编程任务 请用for循环迭代数列 1-100 并打印出7的倍数。 实现代码: 123for i in range(1, 101): if i % 7 == 0: print i 运行结果: 1234567891011121314714212835424956637077849198 索引迭代知识点：Python中，迭代永远是取出元素本身，而非元素的索引。 对于有序集合，元素确实是有索引的。有的时候，我们确实想在 for 循环中拿到索引，怎么办？ 方法是使用 enumerate()函数： 12345678&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; for index, name in enumerate(L):... print index, &apos;-&apos;, name... 0 - Adam1 - Lisa2 - Bart3 - Paul 使用 enumerate()函数，我们可以在for循环中同时绑定索引index和元素name。但是，这不是 enumerate() 的特殊语法。实际上，enumerate() 函数把： 1[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] 变成了类似： 1[(0, &apos;Adam&apos;), (1, &apos;Lisa&apos;), (2, &apos;Bart&apos;), (3, &apos;Paul&apos;)] 因此，迭代的每一个元素实际上是一个tuple： 1234for t in enumerate(L): index = t[0] name = t[1] print index, &apos;-&apos;, name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： 12for index, name in enumerate(L): print index, &apos;-&apos;, name 这样不但代码更简单，而且还少了两条赋值语句。 可见，知识点: 索引迭代也不是真的按索引访问，而是由 enumerate() 函数自动把每个元素变成 (index, element) 这样的tuple，再迭代，就同时获得了索引和元素本身。 编程任务(天涯) zip()函数可以把两个 list 变成一个 list： 12&gt;&gt;&gt; zip([10, 20, 30], [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;])[(10, &apos;A&apos;), (20, &apos;B&apos;), (30, &apos;C&apos;)] 在迭代 [&#39;Adam&#39;, &#39;Lisa&#39;, &#39;Bart&#39;, &#39;Paul&#39;]时，如果我们想打印出名次 - 名字（名次从1开始)，请考虑如何在迭代中打印出来。 提示：考虑使用zip()函数和range()函数 实现代码: 123L = ['Adam', 'Lisa', 'Bart', 'Paul']for index, name in zip(range(1, len(L)+1), L): print index, '-', name 运行结果: 12341 - Adam2 - Lisa3 - Bart4 - Paul 迭代dict的value迭代dict的value我们已经了解了dict对象本身就是可迭代对象，用 for 循环直接迭代 dict，可以每次拿到dict的一个key。 如果我们希望迭代 dict 对象的value，应该怎么做？ 知识点：values()把dict转换成一个包含所有value的listdict 对象有一个 values() 方法，这个方法把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 如果仔细阅读Python的文档，还可以发现，dict除了values()方法外，还有一个 itervalues() 方法，用 itervalues() 方法替代 values() 方法，迭代效果完全一样： 12345678d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，知识点: 任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，知识点: 可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 编程任务 给定一个dict：d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 请计算所有同学的平均分。 实现代码: 12345d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59, &apos;Paul&apos;: 74 &#125;sum = 0.0for v in d.itervalues(): sum = sum + vprint sum / len(d) 运行结果: 178.25 迭代dict的key和value我们了解了如何迭代 dict 的key和value，那么，在一个 for 循环中，能否同时迭代 key和value？答案是肯定的。 首先，我们看看 dict 对象的 items()方法返回的值： 123&gt;&gt;&gt; d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;&gt;&gt;&gt; print d.items()[(&apos;Lisa&apos;, 85), (&apos;Adam&apos;, 95), (&apos;Bart&apos;, 59)] 可以看到，items() 方法把dict对象转换成了包含tuple的list，我们对这个list进行迭代，可以同时获得key和value： 123456&gt;&gt;&gt; for key, value in d.items():... print key, &apos;:&apos;, value... Lisa : 85Adam : 95Bart : 59 和 values()有一个 itervalues() 类似，items() 也有一个对应的 iteritems()，知识点： iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 编程任务 请根据dict：d = { ‘Adam’: 95, ‘Lisa’: 85, ‘Bart’: 59, ‘Paul’: 74 } 打印出 name : score，最后再打印出平均分 average : score。 实现代码： 123456d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59, 'Paul': 74 &#125;sum = 0.0for k, v in d.iteritems(): sum = sum + v print k, ':', vprint 'average', ':', sum / len(d) 运行结果： 12345Lisa : 85Paul : 74Adam : 95Bart : 59average : 78.25 列表生成式:快速生成列表生成列表要生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]，我们可以用range(1, 11)： 12&gt;&gt;&gt; range(1, 11)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？ 方法一是循环： 123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(1, 11):... L.append(x * x)... &gt;&gt;&gt; L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 这种写法就是Python特有的列表生成式。利用列表生成式，可以以非常简洁的代码生成 list。 知识点: 写列表生成式时，把要生成的元素 x * x放到前面，后面跟 for 循环，就可以把list创建出来，十分有用，多写几次，很快就可以熟悉这种语法。 编程任务 请利用列表生成式生成列表 [1x2, 3x4, 5x6, 7x8, ..., 99x100] 提示：range(1, 100, 2)可以生成list [1, 3, 5, 7, 9,...] 实现代码： 1print [x * (x + 1) for x in range(1, 100, 2)] 运行结果： 1[2, 12, 30, 56, 90, 132, 182, 240, 306, 380, 462, 552, 650, 756, 870, 992, 1122, 1260, 1406, 1560, 1722, 1892, 2070, 2256, 2450, 2652, 2862, 3080, 3306, 3540, 3782, 4032, 4290, 4556, 4830, 5112, 5402, 5700, 6006, 6320, 6642, 6972, 7310, 7656, 8010, 8372, 8742, 9120, 9506, 9900] 复杂表达式使用for循环的迭代不仅可以迭代普通的list，还可以迭代dict。 假设有如下的dict： 1d = &#123; 'Adam': 95, 'Lisa': 85, 'Bart': 59 &#125; 完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： 12345tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]print '&lt;table&gt;'print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'print '\n'.join(tds)print '&lt;/table&gt;' 个人：&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt; 中： 第一个%s是name的填充位置。 第二个%s为score的填充位置。 有多少个name和score，会通过循环生成多少个。&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;设置表格头print ‘\n’.join(tds)。列表里的项通过\n连接成字符串。 注：字符串可以通过%进行格式化，用指定的参数替代 %s。字符串的join()方法可以把一个 list拼接成一个字符串。 把打印出来的结果保存为一个html文件，就可以在浏览器中看到效果了： 123456&lt;table border="1"&gt;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&lt;tr&gt;&lt;td&gt;Lisa&lt;/td&gt;&lt;td&gt;85&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Adam&lt;/td&gt;&lt;td&gt;95&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Bart&lt;/td&gt;&lt;td&gt;59&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 编程任务(天涯) 在生成的表格中，对于没有及格的同学，请把分数标记为红色。 提示：红色可以用 &lt;td style=&quot;color:red&quot;&gt; 实现。 实现代码: 12345678910d = &#123; &apos;Adam&apos;: 95, &apos;Lisa&apos;: 85, &apos;Bart&apos;: 59 &#125;def generate_tr(name, score): if score &lt; 60: return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td style=&quot;color:red&quot;&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score) return &apos;&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;&apos; % (name, score)tds = [generate_tr(name, score) for name, score in d.iteritems()]print &apos;&lt;table border=&quot;1&quot;&gt;&apos;print &apos;&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;&apos;print &apos;\n&apos;.join(tds)print &apos;&lt;/table&gt;&apos; 运行结果: 条件过滤列表生成式的 for 循环后面还可以加上 if 判断。例如： 12&gt;&gt;&gt; [x * x for x in range(1, 11)][1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 如果我们只想要偶数的平方，不改动 range()的情况下，可以加上 if 来筛选： 12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 编程任务 请编写一个函数，它接受一个 list，然后把list中的所有字符串变成大写后返回，非字符串元素将被忽略。 提示： isinstance(x, str) 可以判断变量 x 是否是字符串； 字符串的 upper() 方法可以返回大写的字母。 实现代码: 123def toUppers(L): return [x.upper() for x in L if isinstance(x, str)]print toUppers(['Hello', 'world', 101]) 运行结果: 1[&apos;HELLO&apos;, &apos;WORLD&apos;] 多层表达式(知识点)for循环可以嵌套，知识点：因此，在列表生成式中，也可以用多层 for 循环来生成列表。 对于字符串 &#39;ABC&#39; 和 &#39;123&#39;，可以使用两层循环，生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in '123']['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 翻译成循环代码就像下面这样： 1234L = []for m in 'ABC': for n in '123': L.append(m + n) 编程任务(天涯) 利用 3 层for循环的列表生成式，找出对称的 3 位数。例如，121 就是对称数，因为从右到左倒过来还是 121。 实现代码: 1print [100 * n1 + 10 * n2 + n3 for n1 in range(1, 10) for n2 in range(10) for n3 in range(10) if n1==n3] 运行结果： 1101, 111, 121, 131, 141, 151, 161, 171, 181, 191, 202, 212, 222, 232, 242, 252, 262, 272, 282, 292, 303, 313, 323, 333, 343, 353, 363, 373, 383, 393, 404, 414, 424, 434, 444, 454, 464, 474, 484, 494, 505, 515, 525, 535, 545, 555, 565, 575, 585, 595, 606, 616, 626, 636, 646, 656, 666, 676, 686, 696, 707, 717, 727, 737, 747, 757, 767, 777, 787, 797, 808, 818, 828, 838, 848, 858, 868, 878, 888, 898, 909, 919, 929, 939, 949, 959, 969, 979, 989, 999]]]></content>
      <categories>
        <category>python从入门到精通</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>零基础入门</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>
