<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>cuzz&#39;s blog</title>
  
  <subtitle>填坑之路(Github托管)</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.cuzz.site/"/>
  <updated>2019-10-20T16:33:32.053Z</updated>
  <id>http://blog.cuzz.site/</id>
  
  <author>
    <name>cuzz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Go语言入门笔记</title>
    <link href="http://blog.cuzz.site/2019/10/11/Go%E8%AF%AD%E8%A8%80%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <id>http://blog.cuzz.site/2019/10/11/Go语言入门笔记/</id>
    <published>2019-10-11T15:59:59.000Z</published>
    <updated>2019-10-20T16:33:32.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="课程导论"><a href="#课程导论" class="headerlink" title="课程导论"></a>课程导论</h2><ul><li>特点<ul><li>没有“对象”，没有继承，没有泛型，没有 try/catch</li><li>有接口，函数式编程，CSP 并发模型（goroutine + channel）</li><li>语法简单</li></ul></li><li>基本语法<ul><li>变量</li><li>选择，循环</li><li>指针，数组，容器</li></ul></li><li>面向接口<ul><li>结构体</li><li>duck typing 的概念</li><li>组合的思想</li></ul></li><li>函数式编程<ul><li>闭包的概念</li></ul></li><li>工程化<ul><li>资源管理，错误处理</li><li>测试和文档</li><li>性能调优</li></ul></li><li>并发编程<ul><li>goroutine 和 channel</li><li>理解调度器</li></ul></li></ul><a id="more"></a> <h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"Hello World!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认变量值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableZeroValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line">    fmt.Println(a, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义变量值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableInitialValue</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b <span class="keyword">int</span> = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> s <span class="keyword">string</span> = <span class="string">"abc"</span></span><br><span class="line">    fmt.Println(a, b, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量推断</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableTypeDeduction</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a, b, c = <span class="number">1</span>, <span class="string">"abc"</span>, <span class="literal">true</span></span><br><span class="line">    fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量推断简写</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">variableShorter</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b, c := <span class="number">1</span>, <span class="string">"abc"</span>, <span class="literal">true</span></span><br><span class="line">    fmt.Println(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量定义不能使用 :=</span></span><br><span class="line"><span class="comment">// b := 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方便定义多个</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    b = <span class="string">"abc"</span></span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    d = <span class="literal">true</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    variableZeroValue()</span><br><span class="line">    variableInitialValue()</span><br><span class="line">    variableTypeDeduction()</span><br><span class="line">    variableShorter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="内建变量类型"><a href="#内建变量类型" class="headerlink" title="内建变量类型"></a>内建变量类型</h3><ul><li>bool, stiring</li><li>(u)int, (u)int8, (u)int16, (u)int32, (u)int64, uintptr</li><li>byte, rune</li><li>float32, float64, complex64, complex128</li></ul><h3 id="常量与枚举"><a href="#常量与枚举" class="headerlink" title="常量与枚举"></a>常量与枚举</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tri</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// 先把 int 转 float64 再转回 int</span></span><br><span class="line">    c = <span class="keyword">int</span>(math.Sqrt(<span class="keyword">float64</span>(a*a + b*b)))</span><br><span class="line">    fmt.Println(c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义常量</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">consts</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> c <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定类型, 下面需要强转为 float64</span></span><br><span class="line">    <span class="comment">// const a, b int = 3, 4</span></span><br><span class="line">    <span class="comment">// c = int(math.Sqrt(float64(a*a + b*b)))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不指定类型, 不需要强转为 float64</span></span><br><span class="line">    <span class="keyword">const</span> a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    c = <span class="keyword">int</span>(math.Sqrt(a*a + b*b))</span><br><span class="line">    fmt.Println(c)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义枚举</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">enums</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//const (</span></span><br><span class="line">    <span class="comment">//cpp = 0</span></span><br><span class="line">    <span class="comment">//java = 1</span></span><br><span class="line">    <span class="comment">//python = 2</span></span><br><span class="line">    <span class="comment">//golang = 3</span></span><br><span class="line">    <span class="comment">//)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 iota 自增加，与上面一样</span></span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        cpp = <span class="literal">iota</span></span><br><span class="line">        java</span><br><span class="line">        python</span><br><span class="line">        golang</span><br><span class="line">        _ <span class="comment">// 跳开 4</span></span><br><span class="line">        javascript</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fmt.Println(cpp, java, python, golang, javascript) <span class="comment">// 0 1 2 3 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// b, kb, mb, gb, tb, pb</span></span><br><span class="line">    <span class="keyword">const</span> (</span><br><span class="line">        b = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>)</span><br><span class="line">        kb</span><br><span class="line">        mb</span><br><span class="line">        gb</span><br><span class="line">        tb</span><br><span class="line">        pb</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    fmt.Println(b, kb, mb, gb, tb, pb) <span class="comment">// 1 1024 1048576 1073741824 1099511627776 1125899906842624</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    tri()</span><br><span class="line">    consts()</span><br><span class="line">    enums()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"io/ioutil"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// if</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">read</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">const</span> filename = <span class="string">"abc.txt"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取文件</span></span><br><span class="line">    contents, err := ioutil.ReadFile(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以这样写</span></span><br><span class="line">    <span class="keyword">if</span> contents, err := ioutil.ReadFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"%s\n"</span>, contents)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> result <span class="keyword">int</span></span><br><span class="line">    <span class="comment">// switch 会自动 break, 除非使用 fallthrough</span></span><br><span class="line">    <span class="keyword">switch</span> op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        result = a + b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">        result = a - b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        result = a * b</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">        result = a / b</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"unsupported operator: "</span> + op)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// switch</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">grade</span><span class="params">(score <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch 后面没有表达式</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">0</span> || score &gt; <span class="number">100</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">"wrong score"</span>)</span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"E"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">70</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"D"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">80</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"C"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt; <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"B"</span></span><br><span class="line">    <span class="keyword">case</span> score &lt;= <span class="number">100</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"A"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    read()</span><br><span class="line">    fmt.Println(eval(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"+"</span>)) <span class="comment">// 3</span></span><br><span class="line">    grade(<span class="number">100</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"bufio"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为二进制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertToBin</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    res := <span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> ; n &gt; <span class="number">0</span>; n /= <span class="number">2</span> &#123;</span><br><span class="line">        lsb := n % <span class="number">2</span></span><br><span class="line">        res = strconv.Itoa(lsb) + res</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printFile</span><span class="params">(fileName <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(fileName)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scanner := bufio.NewScanner(file)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> scanner.Scan() &#123;</span><br><span class="line">        fmt.Println(scanner.Text())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 死循环</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forever</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"forever"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(</span><br><span class="line">        convertToBin(<span class="number">5</span>),</span><br><span class="line">        convertToBin(<span class="number">13</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    printFile(<span class="string">"abc.txt"</span>);</span><br><span class="line">    forever()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"math"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回多个值</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以对返回值命名</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">div2</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(q, r <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b, a % b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回 error</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">eval</span><span class="params">(a, b <span class="keyword">int</span>, op <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"+"</span>:</span><br><span class="line">        <span class="keyword">return</span> a + b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"-"</span>:</span><br><span class="line">        <span class="keyword">return</span> a - b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"*"</span>:</span><br><span class="line">        <span class="keyword">return</span> a * b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"/"</span>:</span><br><span class="line">        <span class="keyword">return</span> a / b, <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>, fmt.Errorf(<span class="string">"unsupported opration: %s"</span>, op)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用函数式编程</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">apply</span><span class="params">(op <span class="keyword">func</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span> <span class="title">int</span>, <span class="title">a</span>, <span class="title">b</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> op(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sum</span><span class="params">(numbers ...<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> numbers &#123;</span><br><span class="line">        sum += numbers[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pow</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(math.Pow(<span class="keyword">float64</span>(a), <span class="keyword">float64</span>(b)))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    i, i2 := div(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(i, i2)</span><br><span class="line"></span><br><span class="line">    q, r := div2(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">    fmt.Println(q, r)</span><br><span class="line"></span><br><span class="line">    res, err := eval(<span class="number">1</span>, <span class="number">2</span>, <span class="string">"&amp;"</span>) <span class="comment">// unsupported opration: &amp;</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(err)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(res)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(apply(pow, <span class="number">2</span>, <span class="number">2</span>)) <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap</span><span class="params">(a *<span class="keyword">int</span>, b *<span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    *b, *a = *a, *b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">swap2</span><span class="params">(a, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b, a</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    swap(&amp;a, &amp;b)</span><br><span class="line">    fmt.Println(a, b) <span class="comment">// 4 3</span></span><br><span class="line"></span><br><span class="line">    a, b = <span class="number">3</span>, <span class="number">4</span></span><br><span class="line">    a, b = swap2(a, b)</span><br><span class="line">    fmt.Println(a, b) <span class="comment">// 4 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组、切片和容器"><a href="#数组、切片和容器" class="headerlink" title="数组、切片和容器"></a>数组、切片和容器</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组定义</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">defineArray</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义数组的方法</span></span><br><span class="line">    <span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    arr2 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;</span><br><span class="line">    arr3 := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(arr1, arr2, arr3) <span class="comment">// [0 0 0 0 0] [1 3 5] [2 4 6 8]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义二维数组</span></span><br><span class="line">    <span class="keyword">var</span> grid [<span class="number">2</span>][<span class="number">3</span>]<span class="keyword">int</span></span><br><span class="line">    fmt.Println(grid) <span class="comment">// [[0 0 0] [0 0 0]]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历数组</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := [...]<span class="keyword">int</span>&#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">        fmt.Println(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 range 可以获取下标</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        fmt.Println(arr[i])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取下标和值</span></span><br><span class="line">    <span class="keyword">for</span> i, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        fmt.Println(i, v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只获取值, 可以使用 _ 来省略变量</span></span><br><span class="line">    <span class="keyword">for</span> _, v := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// [3]int 和 [5]int 是不同的类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray2</span><span class="params">(arr [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组是值类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray3</span><span class="params">(arr [5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(arr) <span class="comment">// [100, 0, 0, 0, 0]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传递指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printArray4</span><span class="params">(arr *[5]<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="number">100</span></span><br><span class="line">    fmt.Println(*arr) <span class="comment">// [100, 0, 0, 0, 0]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    defineArray()</span><br><span class="line">    printArray()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> arr1 [<span class="number">5</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="comment">// arr2 := [3]int&#123;1, 3, 5&#125;</span></span><br><span class="line">    <span class="comment">// arr3 := [...]int&#123;2, 4, 6, 8, 10&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// [3]int 和 [5]int 是不同的类型</span></span><br><span class="line">    printArray2(arr1) <span class="comment">// 在函数里面改变数组的值</span></span><br><span class="line">    <span class="comment">// printArray2(arr2) //  cannot use arr2 (type [3]int) as type [5]int in argument to printArray2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在函数里改变了数组第一个值, 后面打印还是不变，每次传递数组都是一个副本</span></span><br><span class="line">    printArray3(arr1)</span><br><span class="line">    fmt.Println(arr1) <span class="comment">// [0, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递地址过去就会改变</span></span><br><span class="line">    printArray4(&amp;arr1)</span><br><span class="line">    fmt.Println(arr1) <span class="comment">// [100, 0, 0, 0, 0]</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切片</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mySlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">fmt.Println(<span class="string">"arr[2:6] = "</span>, arr[<span class="number">2</span>:<span class="number">6</span>]) <span class="comment">// arr[2:6] =  [2 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="string">"arr[:6] = "</span>, arr[:<span class="number">6</span>])   <span class="comment">// arr[2:6] =  [2 3 4 5]</span></span><br><span class="line">fmt.Println(<span class="string">"arr[2:] = "</span>, arr[<span class="number">2</span>:])   <span class="comment">// arr[2:] =  [2 3 4 5 6 7]</span></span><br><span class="line">fmt.Println(<span class="string">"arr[:] = "</span>, arr[:])     <span class="comment">// arr[:] =  [0 1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">updateSlice</span><span class="params">(slice []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">slice[<span class="number">0</span>] = <span class="number">2019</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extendSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"><span class="comment">// 我们知道 s1 只有 4 个元素, 但是 s2 还是能</span></span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">s2 := s1[<span class="number">3</span>:<span class="number">5</span>]</span><br><span class="line">fmt.Println(s1)                                <span class="comment">// [2 3 4 5]</span></span><br><span class="line">fmt.Println(s2)                                <span class="comment">// [5 6]</span></span><br><span class="line">fmt.Printf(<span class="string">"len=%d, cap=%d"</span>, <span class="built_in">len</span>(s1), <span class="built_in">cap</span>(s1)) <span class="comment">// len=4, cap=6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">appendSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素如果超过了 cap, 系统会重新分配更大的底层数组</span></span><br><span class="line"><span class="comment">// 由于值的传递关系, 必须接受 append 的返回值</span></span><br><span class="line">s1 := arr[<span class="number">2</span>:<span class="number">6</span>]</span><br><span class="line">s2 := <span class="built_in">append</span>(s1, <span class="number">100</span>)</span><br><span class="line">s3 := <span class="built_in">append</span>(s2, <span class="number">100</span>)</span><br><span class="line">s4 := <span class="built_in">append</span>(s3, <span class="number">100</span>)</span><br><span class="line">s5 := <span class="built_in">append</span>(s4, <span class="number">100</span>)</span><br><span class="line">fmt.Println(s1, s2, s3, s4, s5) <span class="comment">// [2 3 4 5] [2 3 4 5 100] [2 3 4 5 100 100] [2 3 4 5 100 100 100] [2 3 4 5 100 100 100 100]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 slice</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0. 创建一个空的 slice</span></span><br><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line"><span class="comment">// 发现 cap 是从 1 2 4 8 16 32... 扩大</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">1</span>+<span class="number">2</span>*i)</span><br><span class="line">printSlice(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建一个带有值的 slice</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">printSlice(s1) <span class="comment">// len=5, cap=5, slice=[1 2 3 4 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建一个 cap = 16</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)</span><br><span class="line">printSlice(s2) <span class="comment">// len=16, cap=16, slice=[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建一个 len = 10, cap = 32</span></span><br><span class="line">s3 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">32</span>) <span class="comment">// len=10, cap=32, slice=[0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line">printSlice(s3)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copySlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">src := []<span class="keyword">int</span>&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">dst := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">16</span>)</span><br><span class="line">fmt.Println(dst) <span class="comment">// [0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line"><span class="built_in">copy</span>(dst, src)</span><br><span class="line">fmt.Println(dst) <span class="comment">// [1 2 3 0 0 0 0 0 0 0 0 0 0 0 0 0]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteSlice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 删除下标为3的元素</span></span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">s = <span class="built_in">append</span>(s[:<span class="number">3</span>], s[<span class="number">4</span>:]...) <span class="comment">// s[4:]... 转换为可变参数</span></span><br><span class="line">fmt.Println(s) <span class="comment">// [0 1 2 4 5 6 7 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除第一个</span></span><br><span class="line">s1 := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">s1 = s1[<span class="number">1</span>:]</span><br><span class="line">fmt.Println(s1) <span class="comment">// [1 2 3 4 5 6 7 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除最后一个</span></span><br><span class="line">s2 := []<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">s2 = s2[:<span class="built_in">len</span>(s2) - <span class="number">1</span>]</span><br><span class="line">fmt.Println(s2) <span class="comment">// [0 1 2 3 4 5 6 7]</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printSlice</span><span class="params">(s []<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">fmt.Printf(<span class="string">"len=%d, cap=%d, slice=%v \n"</span>, <span class="built_in">len</span>(s), <span class="built_in">cap</span>(s), s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">mySlice()</span><br><span class="line"></span><br><span class="line">arr := [...]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;</span><br><span class="line">slice1 := arr[:]</span><br><span class="line">fmt.Println(<span class="string">"Before update: "</span>, slice1) <span class="comment">// Before update: [0 1 2 3 4 5 6 7]</span></span><br><span class="line">updateSlice(slice1)</span><br><span class="line">fmt.Println(<span class="string">"After update: "</span>, slice1) <span class="comment">// After update: [2019 1 2 3 4 5 6 7]</span></span><br><span class="line"></span><br><span class="line">extendSlice()</span><br><span class="line"></span><br><span class="line">appendSlice()</span><br><span class="line"></span><br><span class="line">createSlice()</span><br><span class="line"></span><br><span class="line">copySlice()</span><br><span class="line"></span><br><span class="line">deleteSlice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;课程导论&quot;&gt;&lt;a href=&quot;#课程导论&quot; class=&quot;headerlink&quot; title=&quot;课程导论&quot;&gt;&lt;/a&gt;课程导论&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;特点&lt;ul&gt;
&lt;li&gt;没有“对象”，没有继承，没有泛型，没有 try/catch&lt;/li&gt;
&lt;li&gt;有接口，函数式编程，CSP 并发模型（goroutine + channel）&lt;/li&gt;
&lt;li&gt;语法简单&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;基本语法&lt;ul&gt;
&lt;li&gt;变量&lt;/li&gt;
&lt;li&gt;选择，循环&lt;/li&gt;
&lt;li&gt;指针，数组，容器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;面向接口&lt;ul&gt;
&lt;li&gt;结构体&lt;/li&gt;
&lt;li&gt;duck typing 的概念&lt;/li&gt;
&lt;li&gt;组合的思想&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;函数式编程&lt;ul&gt;
&lt;li&gt;闭包的概念&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;工程化&lt;ul&gt;
&lt;li&gt;资源管理，错误处理&lt;/li&gt;
&lt;li&gt;测试和文档&lt;/li&gt;
&lt;li&gt;性能调优&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;并发编程&lt;ul&gt;
&lt;li&gt;goroutine 和 channel&lt;/li&gt;
&lt;li&gt;理解调度器&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Go" scheme="http://blog.cuzz.site/categories/Go/"/>
    
    
      <category term="Go" scheme="http://blog.cuzz.site/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Java8的深入与实战</title>
    <link href="http://blog.cuzz.site/2019/08/11/Java8%E7%9A%84%E6%B7%B1%E5%85%A5%E4%B8%8E%E5%AE%9E%E6%88%98/"/>
    <id>http://blog.cuzz.site/2019/08/11/Java8的深入与实战/</id>
    <published>2019-08-11T15:59:59.000Z</published>
    <updated>2019-10-19T16:46:20.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lambda-表达式和函数式接口"><a href="#Lambda-表达式和函数式接口" class="headerlink" title="Lambda 表达式和函数式接口"></a>Lambda 表达式和函数式接口</h2><p>Lambda 表达式定义：</p><blockquote><p>Lambda: In programming languages such as Lisp, Python and Ruby lambda is an operator used to denote <strong>anonymous functions</strong> or <strong>closures</strong>, following the usage of lambda calculus.</p></blockquote><p>为何需要使用 Lambda 表达式：</p><ul><li>在 Java 中，我们无法将函数作为一个参数传递给一个方法，也无法声明一个返回一个函数的方法。</li><li>在 JavaScript 中，函数的参数是一个函数，返回值是另一个函数的情况是非常常见的，JavaScript 是一门典型的函数式语言。</li></ul><a id="more"></a><p>我们通过一个例子来引入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/11 14:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> val : list) &#123;</span><br><span class="line">            System.out.println(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        list.forEach(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 3 种遍历集合的方式，第一就是简单的遍历，第二种是我们是常说的增强 for 循环遍历。第三种就是 Java 8 新增的方法，先看看 Consumer 这个接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注解上是一个函数式接口，我们看看这个接口的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * An informative annotation type used to indicate that an interface</span></span><br><span class="line"><span class="comment"> * type declaration is intended to be a &lt;i&gt;functional interface&lt;/i&gt; as</span></span><br><span class="line"><span class="comment"> * defined by the Java Language Specification.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Conceptually, a functional interface has exactly one abstract</span></span><br><span class="line"><span class="comment"> * method.  Since &#123;<span class="doctag">@linkplain</span> java.lang.reflect.Method#isDefault()</span></span><br><span class="line"><span class="comment"> * default methods&#125; have an implementation, they are not abstract.  If</span></span><br><span class="line"><span class="comment"> * an interface declares an abstract method overriding one of the</span></span><br><span class="line"><span class="comment"> * public methods of &#123;<span class="doctag">@code</span> java.lang.Object&#125;, that also does</span></span><br><span class="line"><span class="comment"> * &lt;em&gt;not&lt;/em&gt; count toward the interface's abstract method count</span></span><br><span class="line"><span class="comment"> * since any implementation of the interface will have an</span></span><br><span class="line"><span class="comment"> * implementation from &#123;<span class="doctag">@code</span> java.lang.Object&#125; or elsewhere.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 有且只有一个抽象方法的接口，如果有重写 Object 中的方法，那也是可以的。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Note that instances of functional interfaces can be created with</span></span><br><span class="line"><span class="comment"> * lambda expressions, method references, or constructor references.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 函数式接口可以通过 lambda 表达式、方法引用和构造方法引用来创建。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a type is annotated with this annotation type, compilers are</span></span><br><span class="line"><span class="comment"> * required to generate an error message unless:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;ul&gt;</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The type is an interface type and not an annotation type, enum, or class.</span></span><br><span class="line"><span class="comment"> * &lt;li&gt; The annotated type satisfies the requirements of a functional interface.</span></span><br><span class="line"><span class="comment"> * &lt;/ul&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;However, the compiler will treat any interface meeting the</span></span><br><span class="line"><span class="comment"> * definition of a functional interface as a functional interface</span></span><br><span class="line"><span class="comment"> * regardless of whether or not a &#123;<span class="doctag">@code</span> FunctionalInterface&#125;</span></span><br><span class="line"><span class="comment"> * annotation is present on the interface declaration.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 编译器会对满足定义函数式接口的接口当做函数式接口，不管它有没有 <span class="doctag">@FunctionalInterface</span> 注解声明。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 4.3.2. The Class Object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.8 Functional Interfaces</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@jls</span> 9.4.3 Interface Method Body</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FunctionalInterface &#123;&#125;</span><br></pre></td></tr></table></figure><p>函数式接口可以通过 lambda 表达式、方法引用和构造方法引用来创建。</p><ul><li>lambda 表达式：() -&gt; System.out.println(i)</li><li>方法引用：System.out::print</li><li>构造方法引用：new::ArrayList</li></ul><p>用一个例子来说明什么是函数式接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cons</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/11 16:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Cons func)</span> </span>&#123;</span><br><span class="line">        func.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">        test2.test(() -&gt; System.out.println(<span class="string">"xxx"</span>));</span><br><span class="line"></span><br><span class="line">        Cons func = () -&gt; System.out.println(<span class="string">"yyy"</span>);</span><br><span class="line">        test2.test(func);</span><br><span class="line">        System.out.println(func.getClass());                 <span class="comment">// 输出 class com.cuzz.Test2$$Lambda$2/2074407503</span></span><br><span class="line">        System.out.println(func.getClass().getSuperclass()); <span class="comment">// 输出 class java.lang.Object</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说明3点：</p><ul><li>函数式接口只有一个非重写 Object 的抽象方法</li><li>lambda 表达式就是一个匿名类</li><li>对于一个函数式接口，我们并不关心这个抽象方法的名称。</li></ul><h2 id="从Consumer深入理解函数式接口和方法引用"><a href="#从Consumer深入理解函数式接口和方法引用" class="headerlink" title="从Consumer深入理解函数式接口和方法引用"></a>从Consumer深入理解函数式接口和方法引用</h2><p>我们回到这个例子当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        list.forEach(<span class="keyword">new</span> Consumer&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer integer)</span> </span>&#123;</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先看看 Iterable#forEach 这个方法，是 Iterable 这个接口这的默认方法，在 Java 8 中接口中是允许默认方法。对于 Iterable#forEach 是对每个元素执行给定的动作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an iterator over elements of type &#123;<span class="doctag">@code</span> T&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> an Iterator.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs the given action for each element of the &#123;<span class="doctag">@code</span> Iterable&#125;</span></span><br><span class="line"><span class="comment">     * until all elements have been processed or the action throws an</span></span><br><span class="line"><span class="comment">     * exception.  Unless otherwise specified by the implementing class,</span></span><br><span class="line"><span class="comment">     * actions are performed in the order of iteration (if an iteration order</span></span><br><span class="line"><span class="comment">     * is specified).  Exceptions thrown by the action are relayed to the</span></span><br><span class="line"><span class="comment">     * caller.</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * 对每个元素执行给定的动作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@implSpec</span></span></span><br><span class="line"><span class="comment">     * &lt;p&gt;The default implementation behaves as if:</span></span><br><span class="line"><span class="comment">     * &lt;pre&gt;&#123;<span class="doctag">@code</span></span></span><br><span class="line"><span class="comment">     *     for (T t : this)</span></span><br><span class="line"><span class="comment">     *         action.accept(t);</span></span><br><span class="line"><span class="comment">     * &#125;&lt;/pre&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> action The action to be performed for each element</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified action is null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;T&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Spliterators.spliteratorUnknownSize(iterator(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看 Consumer 是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents an operation that accepts a single input argument and returns no</span></span><br><span class="line"><span class="comment"> * result. Unlike most other functional interfaces, &#123;<span class="doctag">@code</span> Consumer&#125; is expected</span></span><br><span class="line"><span class="comment"> * to operate via side-effects.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 表示一个操作接受单一输入参数，无返回结果。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #accept(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the operation</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs, in sequence, this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation. If performing either</span></span><br><span class="line"><span class="comment">     * operation throws an exception, it is relayed to the caller of the</span></span><br><span class="line"><span class="comment">     * composed operation.  If performing this operation throws an exception,</span></span><br><span class="line"><span class="comment">     * the &#123;<span class="doctag">@code</span> after&#125; operation will not be performed.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the operation to perform after this operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed &#123;<span class="doctag">@code</span> Consumer&#125; that performs in sequence this</span></span><br><span class="line"><span class="comment">     * operation followed by the &#123;<span class="doctag">@code</span> after&#125; operation</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> after&#125; is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; &#123; accept(t); after.accept(t); &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>lambda 表达式的作用：</strong></p><ul><li>lambda 表达式为 Java 添加了缺失的函数式编程特性，使我们能将函数当做一等公民看待。</li><li>在将函数作为一等公民的语言中，lambda 表达式的类型是函数。但在 Java 中，lambda 表达式是对象，它们必须依附于一类特别的对象（函数式接口）；</li></ul><h2 id="Lambda-表达式的深入"><a href="#Lambda-表达式的深入" class="headerlink" title="Lambda 表达式的深入"></a>Lambda 表达式的深入</h2><p>对于 lambda 表达式需要根据上下文来推断，我们并不知道<code>() -&gt; {}</code> 是什么，不知道对应的参数，方法是什么，只用通过前面的 Cons 定义才知道。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cons1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Cons2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/11 16:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Cons1 cons1 = () -&gt; &#123;&#125;;</span><br><span class="line">        Cons2 cons2 = () -&gt; &#123;&#125;;</span><br><span class="line">        System.out.println(cons1.getClass().getInterfaces()[<span class="number">0</span>]);  <span class="comment">// interface com.cuzz.Cons1</span></span><br><span class="line">        System.out.println(cons2.getClass().getInterfaces()[<span class="number">0</span>]);  <span class="comment">// interface com.cuzz.Cons2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先看一个排序的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/12 23:09</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"cuzz"</span>, <span class="string">"faker"</span>, <span class="string">"mlxg"</span>);</span><br><span class="line">        </span><br><span class="line">        Collections.sort(list, (String s1, String s2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> s2.compareTo(s1);</span><br><span class="line">        &#125;);  <span class="comment">// 1</span></span><br><span class="line">        </span><br><span class="line">        Collections.sort(list, (s1, s2) -&gt; s2.compareTo(s1)); <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 1 到 2 简化了很多，修饰符 String 和 return 都可以省略。<strong>Java Lambda 表达式是一种匿名函数，它没有声明方法，也没有访问修饰符、返回值和名字。</strong></p><p><strong>Lambda 表达式作用：</strong></p><ul><li>传递行为，而不仅仅是值</li><li>提升抽象层次</li><li>API 重用性好</li><li>更加灵活</li></ul><p><strong>Lambda 基本语法：</strong></p><ul><li>Java 中的 Lambda 表达式基本语法<ul><li>如：<code>(argument) -&gt; {body}</code></li><li>省略类型：<code>(arg1, arg2, ...) -&gt; {body}</code></li><li>有类型：<code>(type1 arg1, type2 arg2, ...) -&gt; {body}</code></li></ul></li><li>Lambda 示例说明<ul><li><code>(int a, int b) -&gt; {return a + b;}</code></li><li><code>() -&gt; System.out.println(&quot;hello world&quot;)</code></li><li><code>(String s) -&gt; {System.out.println(s);}</code></li><li><code>() -&gt; 42</code></li><li><code>() -&gt; {return &quot;cuzz&quot;};</code></li></ul></li><li>Lambda结构<ul><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断，如：<code>(int a)</code> 与 <code>(a)</code> 效果相同</li><li>所有的参数需包含在圆括号内，参数之间用逗号相隔。如：<code>(a, b)</code> 或 <code>(String a, int b float c)</code></li><li>空圆括号表示参数集为空，如：<code>() -&gt; 42</code></li><li>当只有一个参数，且其类型可推导时，圆括号可以省略，如：<code>a -&gt; return a * a</code></li><li>Lambda 表达式的主题可以包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有一条语句，花括号可以省略，匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，表达式必须使用花括号</li></ul></li></ul><h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>直接先看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts one argument and produces a result.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a function that always returns its input argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of the input and output objects to the function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a function that always returns its input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Function&lt;T, T&gt; <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t -&gt; t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 Function 有一个抽象方法和两个默认方法以及一个静态方法。</p><p><strong>（1） Function#apply</strong></p><p>Stream#map 里就是接受一个 Function，对于 Function 意思就是从一个映射到另一个。下面例子就是把字符串映射到大写。对于 String::toUpperCase 使用的是方法引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/11 23:13</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"cuzz"</span>, <span class="string">"faker"</span>, <span class="string">"mlxg"</span>);</span><br><span class="line"></span><br><span class="line">        list.stream().map(item -&gt; item.toUpperCase()).forEach(item -&gt; System.out.println(item));</span><br><span class="line">        list.stream().map(String::toUpperCase).forEach(System.out::println);</span><br><span class="line">        Function&lt;String, String&gt; function = String::toUpperCase;</span><br><span class="line">        System.out.println(function.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/13 0:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest function= <span class="keyword">new</span> FunctionTest();</span><br><span class="line">        <span class="keyword">int</span> res1 = function.compute(<span class="number">100</span>, target -&gt; target * target);</span><br><span class="line">        <span class="keyword">int</span> res2 = function.compute(<span class="number">100</span>, target -&gt; target + <span class="number">1</span>);</span><br><span class="line">        System.out.println(res1); <span class="comment">// 10000</span></span><br><span class="line">        System.out.println(res2); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res3 = function.pow(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">int</span> res4 = function.addOne(<span class="number">100</span>);</span><br><span class="line">        System.out.println(res3); <span class="comment">// 10000</span></span><br><span class="line">        System.out.println(res4); <span class="comment">// 101</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addOne</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>看看 #compute 这个方法，第二个参数传递的是行为，而不是具体的值。</strong> 我们本来要定义两个方法，pow 和 addOne 现在把这种行为传递进来。</p><p><strong>（2）Function#compose 和 Function#andThen</strong> </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment"> * function to its input, and then applies this function to the result.</span></span><br><span class="line"><span class="comment"> * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment"> * the caller of the composed function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of input to the &#123;<span class="doctag">@code</span> before&#125; function, and to the</span></span><br><span class="line"><span class="comment"> *           composed function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> before the function to apply before this function is applied</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed function that first applies the &#123;<span class="doctag">@code</span> before&#125;</span></span><br><span class="line"><span class="comment"> * function and then applies this function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if before is null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #andThen(Function)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment"> * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment"> * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment"> * the caller of the composed function.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment"> *           composed function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment"> * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #compose(Function)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>compose方法是一个默认方法，这个方法接收一个 function 作为参数，将参数 function 执行的结果作为参数给调用的 function，以此来实现两个function组合的功能。 </li><li>andThen 方法也是接收一个 function 作为参数，与 compse  不同的是，先执行本身的 apply 方法，将执行的结果作为参数给参数中的 function。 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/20 23:59</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: #compose and #andThen test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FunctionTest2 test = <span class="keyword">new</span> FunctionTest2();</span><br><span class="line">        System.out.println(test.compute1(<span class="number">2</span>, value -&gt; value * <span class="number">2</span>, value -&gt; value * value)); <span class="comment">// 8</span></span><br><span class="line">        System.out.println(test.compute2(<span class="number">2</span>, value -&gt; value * <span class="number">2</span>, value -&gt; value * value)); <span class="comment">// 16</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute1</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.compose(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute2</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function1, Function&lt;Integer, Integer&gt; function2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function1.andThen(function2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现 compute1 是先执行第二个 Function 再执行第一，compute2 相反。</p><h2 id="BiFunction"><a href="#BiFunction" class="headerlink" title="BiFunction"></a>BiFunction</h2><p>先看源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a function that accepts two arguments and produces a result.</span></span><br><span class="line"><span class="comment"> * This is the two-arity specialization of &#123;<span class="doctag">@link</span> Function&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #apply(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the first argument to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;U&gt; the type of the second argument to the function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;R&gt; the type of the result of the function</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Function</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BiFunction</span>&lt;<span class="title">T</span>, <span class="title">U</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given arguments.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the first function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> u the second function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t, U u)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed function that first applies this function to</span></span><br><span class="line"><span class="comment">     * its input, and then applies the &#123;<span class="doctag">@code</span> after&#125; function to the result.</span></span><br><span class="line"><span class="comment">     * If evaluation of either function throws an exception, it is relayed to</span></span><br><span class="line"><span class="comment">     * the caller of the composed function.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; the type of output of the &#123;<span class="doctag">@code</span> after&#125; function, and of the</span></span><br><span class="line"><span class="comment">     *           composed function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> after the function to apply after this function is applied</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed function that first applies this function and then</span></span><br><span class="line"><span class="comment">     * applies the &#123;<span class="doctag">@code</span> after&#125; function</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if after is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">BiFunction&lt;T, U, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(after);</span><br><span class="line">        <span class="keyword">return</span> (T t, U u) -&gt; after.apply(apply(t, u));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我看一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/21 7:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BiFunctionTest test = <span class="keyword">new</span> BiFunctionTest();</span><br><span class="line">        <span class="comment">// 加法</span></span><br><span class="line">        System.out.println(test.add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(test.compute(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a + b));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 减法</span></span><br><span class="line">        System.out.println(test.subtract(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">        System.out.println(test.compute(<span class="number">1</span>, <span class="number">2</span>, (a, b) -&gt; a - b));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; biFunction)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> biFunction.apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">subtract</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以前我们定义一个四则运算需要需要先定义方法，现在通过 BiFunction 可以把这种行为传递进来。</p><h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p><strong>（1）源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Represents a predicate (boolean-valued function) of one argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;This is a &lt;a href="package-summary.html"&gt;functional interface&lt;/a&gt;</span></span><br><span class="line"><span class="comment"> * whose functional method is &#123;<span class="doctag">@link</span> #test(Object)&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; the type of the input to the predicate</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> false&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ANDed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * AND of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">and</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) &amp;&amp; other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that represents the logical negation of this</span></span><br><span class="line"><span class="comment">     * predicate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">negate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; !test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a composed predicate that represents a short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and another.  When evaluating the composed</span></span><br><span class="line"><span class="comment">     * predicate, if this predicate is &#123;<span class="doctag">@code</span> true&#125;, then the &#123;<span class="doctag">@code</span> other&#125;</span></span><br><span class="line"><span class="comment">     * predicate is not evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;Any exceptions thrown during evaluation of either predicate are relayed</span></span><br><span class="line"><span class="comment">     * to the caller; if evaluation of this predicate throws an exception, the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@code</span> other&#125; predicate will not be evaluated.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other a predicate that will be logically-ORed with this</span></span><br><span class="line"><span class="comment">     *              predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a composed predicate that represents the short-circuiting logical</span></span><br><span class="line"><span class="comment">     * OR of this predicate and the &#123;<span class="doctag">@code</span> other&#125; predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if other is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Predicate&lt;T&gt; <span class="title">or</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; other)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(other);</span><br><span class="line">        <span class="keyword">return</span> (t) -&gt; test(t) || other.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; the type of arguments to the predicate</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetRef the object reference with which to compare for equality,</span></span><br><span class="line"><span class="comment">     *               which may be &#123;<span class="doctag">@code</span> null&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a predicate that tests if two arguments are equal according</span></span><br><span class="line"><span class="comment">     * to &#123;<span class="doctag">@link</span> Objects#equals(Object, Object)&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &lt;T&gt; <span class="function">Predicate&lt;T&gt; <span class="title">isEqual</span><span class="params">(Object targetRef)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">null</span> == targetRef)</span><br><span class="line">                ? Objects::isNull</span><br><span class="line">                : object -&gt; targetRef.equals(object);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- more --><p><strong>（2）例子</strong></p><p>以前我们根据不同的条件筛选数据需要些多个方法，现在只要先定义一个这种接受行为的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/21 23:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: Predicate test</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        PredicateTest test = <span class="keyword">new</span> PredicateTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找奇数</span></span><br><span class="line">        test.findOdd(list);</span><br><span class="line">        test.conditionFilter(list, i -&gt; i % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找偶数</span></span><br><span class="line">        test.findEven(list);</span><br><span class="line">        test.conditionFilter(list, i -&gt; i % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate.test(i)) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findOdd</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findEven</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）Predicate#and 和 Predicate#or</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        PredicateTest test = <span class="keyword">new</span> PredicateTest();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找 大于 3 的奇数</span></span><br><span class="line">        test.conditionFilter2(list, i -&gt; i &gt; <span class="number">3</span>, i -&gt; i % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionFilter2</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate1, Predicate&lt;Integer&gt; predicate2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (predicate1.and(predicate2).test(i)) &#123;</span><br><span class="line">                System.out.print(i + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><p><strong>（1）不接受参数，返回一个值。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Represents a supplier of results.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;There is no requirement that a new or distinct result be returned each</span><br><span class="line"> * time the supplier is invoked.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This is a &lt;a href=&quot;package-summary.html&quot;&gt;functional interface&lt;/a&gt;</span><br><span class="line"> * whose functional method is &#123;@link #get()&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @param &lt;T&gt; the type of results supplied by this supplier</span><br><span class="line"> *</span><br><span class="line"> * @since 1.8</span><br><span class="line"> */</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface Supplier&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Gets a result.</span><br><span class="line">     *</span><br><span class="line">     * @return a result</span><br><span class="line">     */</span><br><span class="line">    T get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（2）例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/8/22 23:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupplierTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Supplier&lt;Student&gt; supplier1 = () -&gt; <span class="keyword">new</span> Student();</span><br><span class="line">        Supplier&lt;Student&gt; supplier2 = Student::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"cuzz"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p>参考：<a href="https://blog.csdn.net/wisgood/article/details/52503052" target="_blank" rel="noopener"> 使用 Java 8 Optional 的正确姿势 </a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Lambda-表达式和函数式接口&quot;&gt;&lt;a href=&quot;#Lambda-表达式和函数式接口&quot; class=&quot;headerlink&quot; title=&quot;Lambda 表达式和函数式接口&quot;&gt;&lt;/a&gt;Lambda 表达式和函数式接口&lt;/h2&gt;&lt;p&gt;Lambda 表达式定义：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Lambda: In programming languages such as Lisp, Python and Ruby lambda is an operator used to denote &lt;strong&gt;anonymous functions&lt;/strong&gt; or &lt;strong&gt;closures&lt;/strong&gt;, following the usage of lambda calculus.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为何需要使用 Lambda 表达式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 Java 中，我们无法将函数作为一个参数传递给一个方法，也无法声明一个返回一个函数的方法。&lt;/li&gt;
&lt;li&gt;在 JavaScript 中，函数的参数是一个函数，返回值是另一个函数的情况是非常常见的，JavaScript 是一门典型的函数式语言。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="http://blog.cuzz.site/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java8" scheme="http://blog.cuzz.site/tags/Java8/"/>
    
      <category term="lambda" scheme="http://blog.cuzz.site/tags/lambda/"/>
    
  </entry>
  
  <entry>
    <title>面试高频题</title>
    <link href="http://blog.cuzz.site/2019/07/23/%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98/"/>
    <id>http://blog.cuzz.site/2019/07/23/面试高频题/</id>
    <published>2019-07-23T15:59:59.000Z</published>
    <updated>2019-10-19T16:46:20.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何控制线程打印顺序"><a href="#如何控制线程打印顺序" class="headerlink" title="如何控制线程打印顺序"></a>如何控制线程打印顺序</h2><h3 id="使用-join-方法"><a href="#使用-join-方法" class="headerlink" title="使用 join 方法"></a>使用 join 方法</h3><p>如下面代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"thread1"</span>));</span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"thread2"</span>));</span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"thread3"</span>));</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.start();</span><br><span class="line">        thread2.join();</span><br><span class="line">        thread3.start();</span><br><span class="line">        thread3.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a> <p>通过 join 方法去保证多线程的顺序的特性，join 主要让主线程等待子线程结束后才能继续运行。</p><p><img src="面试高频题/微信截图_20190717155358.png" alt="微信截图_20190717155358"></p><h3 id="使用-Executors-new"><a href="#使用-Executors-new" class="headerlink" title="使用 Executors.new"></a>使用 Executors.new</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"thread1"</span>));</span><br><span class="line">        <span class="keyword">final</span> Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"thread2"</span>));</span><br><span class="line">        <span class="keyword">final</span> Thread thread3 = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"thread3"</span>));</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        executorService.submit(thread1);</span><br><span class="line">        executorService.submit(thread2);</span><br><span class="line">        executorService.submit(thread3);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看源码就知道了，使用阻塞队列来维护任务，是任务有序进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an Executor that uses a single worker thread operating</span></span><br><span class="line"><span class="comment"> * off an unbounded queue. (Note however that if this single</span></span><br><span class="line"><span class="comment"> * thread terminates due to a failure during execution prior to</span></span><br><span class="line"><span class="comment"> * shutdown, a new one will take its place if needed to execute</span></span><br><span class="line"><span class="comment"> * subsequent tasks.)  Tasks are guaranteed to execute</span></span><br><span class="line"><span class="comment"> * sequentially, and no more than one task will be active at any</span></span><br><span class="line"><span class="comment"> * given time. Unlike the otherwise equivalent</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> newFixedThreadPool(1)&#125; the returned executor is</span></span><br><span class="line"><span class="comment"> * guaranteed not to be reconfigurable to use additional threads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the newly created single-threaded Executor</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Java-中的-volatile-和-synchronized"><a href="#Java-中的-volatile-和-synchronized" class="headerlink" title="Java 中的 volatile 和 synchronized"></a>Java 中的 volatile 和 synchronized</h2><ul><li>JMM（Java Memory Mode）：解决并发过程中可见性、原子性和有序性的问题。</li><li>并发过程中的两个关键问题<ul><li>线程之间如何通信<ul><li>共享内存：隐身通信 </li><li>消息传递：显示通信，如 wait() / notify() / notifyall()</li></ul></li><li>线程之间如何同步<ul><li>线程同步指的是：程序用于控制不同线程先后顺序的机制。</li><li>在消息传递的并发模型中，由于消息的发送必需在消息接受之前，所以是隐式同步。</li></ul></li></ul></li><li>定位内存可见行问题<ul><li>什么是内存共享</li></ul></li><li>synchronized：可重入锁、互斥性和可见性</li><li>volatile：可以做到原子性、可见性不能做到复合操作的原子性</li><li>volatile 保证可见性原理<ul><li>对于 volatile 修饰的变量进行写操作的时候，JVM 会向处理器发送一条 Lock 前缀的指令，会把这个变量所在缓存行的数据写回系统内存。</li><li>在多处理器的情况下，各个处理器会通过总线传过的的值来发现自己保存的值是不是过期了，实现缓存一致性。当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</li></ul></li><li>synchronized 是关键字属于 JVM 层面，反应在字节码上是 monitorenter 和 monitorexit，其底层是通过 monitor 对象来完成，其实 wait/notify 等方法也是依赖 monitor 对象只有在同步快或方法中才能调用 wait/notify 等方法。</li></ul><h2 id="新建一个线程的几种方式"><a href="#新建一个线程的几种方式" class="headerlink" title="新建一个线程的几种方式"></a>新建一个线程的几种方式</h2><ul><li>Thread</li><li>Rannable</li><li>Callable/Future</li><li>ExectutorService</li></ul><h2 id="分布式锁的实现"><a href="#分布式锁的实现" class="headerlink" title="分布式锁的实现"></a><a href="http://www.hollischuang.com/archives/1716" target="_blank" rel="noopener">分布式锁的实现</a></h2><ul><li>通过数据库实现</li><li>使用 zookeeper 实现</li><li>基于 redis 实现</li></ul><h2 id="如果通过一个-swap-交换两个数"><a href="#如果通过一个-swap-交换两个数" class="headerlink" title="如果通过一个 swap 交换两个数"></a>如果通过一个 swap 交换两个数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"before : a = "</span> + a + <span class="string">", "</span> + <span class="string">"b = "</span> + b);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"after  : a = "</span> + a + <span class="string">", "</span> + <span class="string">"b = "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, Integer b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = a;</span><br><span class="line">        a = b;</span><br><span class="line">        b = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// before : a = 1, b = 2</span></span><br><span class="line"><span class="comment">// after  : a = 1, b = 2</span></span><br></pre></td></tr></table></figure><p>发现并没有交换，因为 Java 使用的值传递，传递的只是一个副本，如果是基本类型就基本类型副本，如果是引用类型就是引用类型的副本。</p><p>查看源码，发现 Integer 这个类有一个 final 成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The value of the &#123;<span class="doctag">@code</span> Integer&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>我们知道 final 修饰的变量不能修改，但是我们可以通过反射修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>; <span class="comment">// 同 Integer.valueOf(1)</span></span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        System.out.println(<span class="string">"before : a = "</span> + a + <span class="string">", "</span> + <span class="string">"b = "</span> + b);</span><br><span class="line">        swap(a, b);</span><br><span class="line">        System.out.println(<span class="string">"after  : a = "</span> + a + <span class="string">", "</span> + <span class="string">"b = "</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Integer a, Integer b)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">        Field field = Integer.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>); <span class="comment">// 访问私有变量</span></span><br><span class="line">        Integer temp = <span class="keyword">new</span> Integer(a.intValue()); <span class="comment">// 因为 -128 ~ 127 会缓冲，所以要 new 出来</span></span><br><span class="line">        field.set(a, b.intValue());</span><br><span class="line">        field.set(b, temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="comment">// before : a = 1, b = 2</span></span><br><span class="line"><span class="comment">// after  : a = 2, b = 1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何控制线程打印顺序&quot;&gt;&lt;a href=&quot;#如何控制线程打印顺序&quot; class=&quot;headerlink&quot; title=&quot;如何控制线程打印顺序&quot;&gt;&lt;/a&gt;如何控制线程打印顺序&lt;/h2&gt;&lt;h3 id=&quot;使用-join-方法&quot;&gt;&lt;a href=&quot;#使用-join-方法&quot; class=&quot;headerlink&quot; title=&quot;使用 join 方法&quot;&gt;&lt;/a&gt;使用 join 方法&lt;/h3&gt;&lt;p&gt;如下面代码所示：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadDemo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; InterruptedException &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Thread thread1 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;thread1&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Thread thread2 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;thread2&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; Thread thread3 = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Thread(() -&amp;gt; System.out.println(&lt;span class=&quot;string&quot;&gt;&quot;thread3&quot;&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread1.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread1.join();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread2.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread2.join();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread3.start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        thread3.join();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="面试" scheme="http://blog.cuzz.site/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="join" scheme="http://blog.cuzz.site/tags/join/"/>
    
      <category term="volatile" scheme="http://blog.cuzz.site/tags/volatile/"/>
    
      <category term="synchronized" scheme="http://blog.cuzz.site/tags/synchronized/"/>
    
      <category term="分布式锁" scheme="http://blog.cuzz.site/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务框架Seata</title>
    <link href="http://blog.cuzz.site/2019/07/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6Seata/"/>
    <id>http://blog.cuzz.site/2019/07/10/分布式事务框架Seata/</id>
    <published>2019-07-10T15:59:59.000Z</published>
    <updated>2019-10-19T16:46:20.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分布式基础"><a href="#分布式基础" class="headerlink" title="分布式基础"></a>分布式基础</h2><h3 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h3><p>CAP 定理指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可兼得。在分布式系统中，分区容错性是必须需要实现的。所以只能在一致性和可用性之间进行权衡（AP 或者 CP）。</p><h3 id="BASE-理论"><a href="#BASE-理论" class="headerlink" title="BASE 理论"></a>BASE 理论</h3><p>BASE 是 Basically Available（基本可用）、Soft state（软状态）和 Eventually consistent（最终一致性）三个短语的缩写。是对 CAP 中 AP 的一个扩展</p><ol><li>BA 基本可用：分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。</li><li>S 软状态：允许系统中存在中间状态，这个状态不影响系统可用性，这里指的是 CAP 中的不一致。</li><li>E 最终一致：最终一致是指经过一段时间后，所有节点数据都将会达到一致。</li></ol><p>BASE 解决了 CAP 中理论没有网络延迟，在 BASE 中用软状态和最终一致，保证了延迟后的一致性。</p><p>BASE 和 ACID 是相反的，它完全不同于 ACID 的强一致性模型，而是通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态。</p><h3 id="分布式事务实现方式"><a href="#分布式事务实现方式" class="headerlink" title="分布式事务实现方式"></a><a href="https://github.com/doocs/advanced-java/blob/master/docs/distributed-system/distributed-transaction.md" target="_blank" rel="noopener">分布式事务实现方式</a></h3><ul><li><strong>XA 方案(两阶段提交)</strong></li><li><strong>TCC 方案</strong></li><li>本地消息表</li><li>可靠消息最终一致性方案</li><li>最大努力通知方案</li></ul><h2 id="Seata简介"><a href="#Seata简介" class="headerlink" title="Seata简介"></a>Seata简介</h2><p>Seata (Simple Extensible Autonomous Transaction Architecture) 是阿里巴巴开源的分布式事务中间件，，解决微服务场景下面临的分布式事务问题。</p><p>具体看 <a href="https://github.com/seata/seata" target="_blank" rel="noopener">Seata</a> 官网：</p><p><img src="https://camo.githubusercontent.com/b3a71332ae0a91db7f8616286a69b879fcbea672/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f6c61726b2f302f323031382f706e672f31383836322f313534353239363739313037342d33626365376263652d303235652d343563332d393338362d3762393531333564616465382e706e67" alt="Seata solution"></p><p><strong>Seata主要由三个重要组件组成：</strong></p><ul><li>Transaction Coordinator(TC)：管理全局的分支事务的状态，用于全局性事务的提交和回滚。</li><li>Transaction Manager(TM)：事务管理器，用于开启全局事务、提交或者回滚全局事务，是全局事务的开启者。</li><li>Resource Manager(RM)：资源管理器，用于分支事务上的资源管理，向 TC 注册分支事务，上报分支事务的状态，接受 TC 的命令来提交或者回滚分支事务。</li></ul><h2 id="Seata-两种模式"><a href="#Seata-两种模式" class="headerlink" title="Seata 两种模式"></a>Seata 两种模式</h2><p>Seata 关注的就是微服务架构下的数据一致性问题，是一整套的分布式事务解决方案。Seata 框架包含两种模式，一种是 AT 模式。AT 模式主要从数据分片的角度，关注多 DB 访问的数据一致性，当然也包括多服务下的多 DB 数据访问一致性问题。</p><p>另外一个就是 TCC 模式，TCC 模式主要关注业务拆分，在按照业务横向扩展资源时，解决微服务间调用的一致性问题，保证读资源访问的事务属性。</p><h3 id="AT-模式"><a href="#AT-模式" class="headerlink" title="AT 模式"></a>AT 模式</h3><p>AT 模式是通过两段提交的方式实现，AT 模式下，把每个数据库被当做是一个 Resource，Seata 里称为 DataSource Resource。业务通过 JDBC 标准接口访问数据库资源时，Seata 框架会对所有请求进行拦截，做一些操作。每个本地事务提交时，Seata RM（Resource Manager，资源管理器） 都会向 TC（Transaction Coordinator，事务协调器） 注册一个分支事务。当请求链路调用完成后，发起方通知 TC 提交或回滚分布式事务，进入二阶段调用流程。此时，TC 会根据之前注册的分支事务回调到对应参与者去执行对应资源的第二阶段。TC 是怎么找到分支事务与资源的对应关系呢？每个资源都有一个全局唯一的资源 ID，并且在初始化时用该 ID 向 TC 注册资源。在运行时，每个分支事务的注册都会带上其资源 ID。这样 TC 就能在二阶段调用时正确找到对应的资源。</p><p>这就是我们的 AT 模式。简单总结一下，就是把每个数据库当做一个 Resource，在本地事务提交时会去注册一个分支事务。</p><p>这种模式是对业务零入侵，并发没那么高。</p><h3 id="TCC-模式"><a href="#TCC-模式" class="headerlink" title="TCC 模式"></a>TCC 模式</h3><p><strong>TCC 模型是把锁的粒度完全交给业务处理，它需要每个子事务业务都实现Try-Confirm / Cancel 接口。</strong></p><blockquote><p>TCC 模式本质也是 2PC ，只是 TCC 在应用层控制。</p></blockquote><ul><li>Try:<ul><li>尝试执行业务</li><li>完成所有业务检查（一致性）</li><li>预留必须业务资源（准隔离性）</li></ul></li><li>Confirm:<ul><li>确认执行业务；</li><li>真正执行业务，不作任何业务检查</li><li>只使用Try阶段预留的业务资源</li><li>Confirm 操作满足幂等性</li></ul></li><li>Cancel:<ul><li>取消执行业务</li><li>释放Try阶段预留的业务资源</li><li>Cancel操作满足幂等性</li></ul></li></ul><p><strong>这三个阶段，都会按本地事务的方式执行。不同于 XA 的 prepare ，TCC 无需将 XA 的投票期间的所有资源挂起，因此极大的提高了吞吐量。</strong></p><p>那么对应到 TCC 模式里，也是一样的，Seata 框架把每组 TCC 接口当做一个 Resource，称为 TCC Resource。这套 TCC 接口可以是 RPC，也以是服务内 JVM 调用。在业务启动时，Seata 框架会自动扫描识别到 TCC 接口的调用方和发布方。如果是 RPC 的话，就是 sofa:reference、sofa:service、dubbo:reference、dubbo:service 等。</p><p>扫描到 TCC 接口的调用方和发布方之后。如果是发布方，会在业务启动时向 TC 注册 TCC Resource，与 DataSource Resource 一样，每个资源也会带有一个资源 ID。</p><p>如果是调用方，Seata 框架会给调用方加上切面，与 AT 模式一样，在运行时，该切面会拦截所有对 TCC 接口的调用。每调用一次 Try 接口，切面会先向 TC 注册一个分支事务，然后才去执行原来的 RPC 调用。当请求链路调用完成后，TC 通过分支事务的资源 ID 回调到正确的参与者去执行对应 TCC 资源的 Confirm 或 Cancel 方法。</p><p>在讲完了整个框架模型以后，大家可能会问 TCC 三个接口怎么实现。因为框架本身很简单，主要是扫描 TCC 接口，注册资源，拦截接口调用，注册分支事务，最后回调二阶段接口。最核心的实际上是 TCC 接口的实现逻辑。下面我将根据蚂蚁金服内部多年的实践来为大家分析怎么实现一个完备的 TCC 接口。</p><h2 id="运行-Demo"><a href="#运行-Demo" class="headerlink" title="运行 Demo"></a>运行 Demo</h2><p><a href="https://github.com/seata/seata-samples" target="_blank" rel="noopener">官方Demo</a></p><p>下面是 dubbo 的例子，运行后报错可以看到回滚信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">INFO [rpcDispatch_RMROLE_4_8] - onMessage:xid=10.116.22.63:8091:2016481020,branchId=2016481022,branchType=AT,resourceId=jdbc:mysql://localhost:3306/fescar_demo?serverTimezone=UTC,applicationData=null</span><br><span class="line"> INFO [rpcDispatch_RMROLE_4_8] - Branch Rollbacking: 10.116.22.63:8091:2016481020 2016481022 jdbc:mysql://localhost:3306/fescar_demo?serverTimezone=UTC</span><br><span class="line"> INFO [rpcDispatch_RMROLE_4_8] - xid 10.116.22.63:8091:2016481020 branch 2016481022, undo_log deleted with GlobalFinished</span><br><span class="line"> INFO [rpcDispatch_RMROLE_4_8] - Branch Rollbacked result: PhaseTwo_Rollbacked</span><br><span class="line">DEBUG [rpcDispatch_RMROLE_4_8] - branch rollback result:xid=10.116.22.63:8091:2016481020,branchId=2016481022,branchStatus=PhaseTwo_Rollbacked,result code =Success,getMsg =null</span><br><span class="line"> INFO [rpcDispatch_RMROLE_4_8] - RmRpcClient sendResponse xid=10.116.22.63:8091:2016481020,branchId=2016481022,branchStatus=PhaseTwo_Rollbacked,result code =Success,getMsg =null</span><br><span class="line">DEBUG [rpcDispatch_RMROLE_4_8] - send response:xid=10.116.22.63:8091:2016481020,branchId=2016481022,branchStatus=PhaseTwo_Rollbacked,result code =Success,getMsg =null,channel:[id: 0xc8027ef7, L:/127.0.0.1:62873 - R:/127.0.0.1:8091]</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>数据库驱动与 Mysql 版本一致</li><li>数据库 rul 添加时区 <code>jdbc.account.url=jdbc:mysql://localhost:3306/fescar_demo?serverTimezone=UTC</code></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://mp.weixin.qq.com/s/Nb3qeOXXW1xa-qFr-uNi9g" target="_blank" rel="noopener">Seata AT 模式分布式事务源码分析</a></p><p><a href="https://mp.weixin.qq.com/s/G9vkficqBSpmtGITgsJPgw" target="_blank" rel="noopener">分布式事务 Seata TCC 模式深度解析</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分布式基础&quot;&gt;&lt;a href=&quot;#分布式基础&quot; class=&quot;headerlink&quot; title=&quot;分布式基础&quot;&gt;&lt;/a&gt;分布式基础&lt;/h2&gt;&lt;h3 id=&quot;CAP-定理&quot;&gt;&lt;a href=&quot;#CAP-定理&quot; class=&quot;headerlink&quot; title=&quot;C
      
    
    </summary>
    
      <category term="分布式" scheme="http://blog.cuzz.site/categories/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    
      <category term="Seata" scheme="http://blog.cuzz.site/tags/Seata/"/>
    
  </entry>
  
  <entry>
    <title>关于null的思考</title>
    <link href="http://blog.cuzz.site/2019/06/03/%E5%85%B3%E4%BA%8Enull%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://blog.cuzz.site/2019/06/03/关于null的思考/</id>
    <published>2019-06-03T11:54:59.000Z</published>
    <updated>2019-10-19T16:46:20.782Z</updated>
    
    <content type="html"><![CDATA[<p>写代码的时候有个地方需要把 <code>Integer</code> 类型强转为 <code>String</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer firstEventType = eventTask.getEventType1();</span><br><span class="line">String firstEventTypeName = eventTypeService.queryDescByCode(String.valueOf(firstEventType));</span><br></pre></td></tr></table></figure><p>当我点开 <code>String#valueof</code> 这个静态方式时</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们没有获取到 firstEventType 这个值时，为 null，此时它返回给我们的是字符串 <strong>“null”</strong> ，有时候就不符合我们的业务场景，最好是提前做空值判断。</p><a id="more"></a> <p>看下面一个例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(String.valueOf(i));    <span class="comment">// 输出 null</span></span><br><span class="line">System.out.println(String.valueOf(<span class="keyword">null</span>)); <span class="comment">// 空指针</span></span><br></pre></td></tr></table></figure><p><strong>感觉很奇怪，竟然输出结果不一样。</strong></p><p>看看这两个重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (obj == <span class="keyword">null</span>) ? <span class="string">"null"</span> : obj.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> data[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>凭直觉来看以为<code>String.valueOf(null)</code> 会选择第一做为 <code>valueOf(Object obj)</code> 这个从载方法，然而选择的是<code>valueOf(char data[])</code> 所以会报空指针异常。</p><p>下面是查到官方文档 <a href="https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5" target="_blank" rel="noopener">https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.12.2.5</a></p><blockquote><p>如果第一个方法处理的任何调用都可以传递给另一个没有编译时类型错误的调用，那么一个方法比另一个方法更具体。</p></blockquote><p>从意思来看 <code>valueOf(char data[])</code> 比 <code>valueOf(Object obj)</code> 更具体。</p><p>我们非常痛恨的 null 到底是什么</p><p>Java 语言定义</p><blockquote><p>There is also a special null type, the type of the expression null, which has no name. Because the null type has no name, it is impossible to declare a variable of the null type or to cast to the null type. The null reference is the only possible value of an expression of null type. The null reference can always be cast to any reference type. <strong>In practice, the programmer can ignore the null type</strong> and just pretend that null is merely a special literal that can be of any reference type.</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写代码的时候有个地方需要把 &lt;code&gt;Integer&lt;/code&gt; 类型强转为 &lt;code&gt;String&lt;/code&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Integer firstEventType = eventTask.getEventType1();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;String firstEventTypeName = eventTypeService.queryDescByCode(String.valueOf(firstEventType));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当我点开 &lt;code&gt;String#valueof&lt;/code&gt; 这个静态方式时&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; String &lt;span class=&quot;title&quot;&gt;valueOf&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Object obj)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; (obj == &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) ? &lt;span class=&quot;string&quot;&gt;&quot;null&quot;&lt;/span&gt; : obj.toString();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当我们没有获取到 firstEventType 这个值时，为 null，此时它返回给我们的是字符串 &lt;strong&gt;“null”&lt;/strong&gt; ，有时候就不符合我们的业务场景，最好是提前做空值判断。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="http://blog.cuzz.site/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
  </entry>
  
  <entry>
    <title>JVM 面试</title>
    <link href="http://blog.cuzz.site/2019/05/10/JVM%E9%9D%A2%E8%AF%95/"/>
    <id>http://blog.cuzz.site/2019/05/10/JVM面试/</id>
    <published>2019-05-10T15:29:22.000Z</published>
    <updated>2019-10-19T16:46:20.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JVM-垃圾回收的时候如何确定垃圾？知道什么是-GC-Roots"><a href="#JVM-垃圾回收的时候如何确定垃圾？知道什么是-GC-Roots" class="headerlink" title="JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ?"></a>JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC Roots ?</h2><ul><li>什么是垃圾<ul><li>简单来说就是内存中已经不在被使用到的空间就是垃圾</li></ul></li><li>要进行垃圾回收，如何判断一个对象是否可以被回收？<ul><li>引用计数法</li><li>枚举根节点做可达性分析</li></ul></li></ul><p>为了解决引用计数法的循环引用问题，Java 使用了可达性算法。</p><p><img src="JVM面试/1350633405_4538.jpg" alt="img"></p><p>跟踪收集器采用的为集中式的管理方式，全局记录对象之间的引用状态，执行时从一些列GC  Roots的对象做为起点，从这些节点向下开始进行搜索所有的引用链，当一个对象到GC  Roots 没有任何引用链时，则证明此对象是不可用的。</p><p>图中，对象Object6、Object7、Object8虽然互相引用，但他们的GC Roots是不可到达的，所以它们将会被判定为是可回收的对象。</p><p>哪些对象可以作为 GC Roots 的对象：</p><ul><li>虚拟机栈（栈帧中的局部变量区，也叫局部变量表）中引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法去常量引用的对象</li><li>本地方法栈中 JNI (Native方法)引用的对象</li></ul><h2 id="你说你做过-JVM-调优和参数配置，请问如果盘点查看-JVM-系统默认值？"><a href="#你说你做过-JVM-调优和参数配置，请问如果盘点查看-JVM-系统默认值？" class="headerlink" title="你说你做过 JVM 调优和参数配置，请问如果盘点查看 JVM 系统默认值？"></a>你说你做过 JVM 调优和参数配置，请问如果盘点查看 JVM 系统默认值？</h2><h3 id="JVM-的参数类型"><a href="#JVM-的参数类型" class="headerlink" title="JVM 的参数类型"></a>JVM 的参数类型</h3><ul><li>标配参数<ul><li>-version</li><li>-help </li></ul></li><li>X 参数（了解）<ul><li>-Xint：解释执行</li><li>-Xcomp：第一次使用就编译成本地代码</li><li>-Xmixed：混合模式</li></ul></li><li><p>XX 参数</p><ul><li>Boolean 类型：-XX：+ 或者 - 某个属性值（+ 表示开启，- 表示关闭）<ul><li>-XX:+PrintGCDetails：打印 GC 收集细节</li><li>-XX:-PrintGCDetails：不打印 GC 收集细节</li><li>-XX:+UseSerialGC：使用了串行收集器</li><li>-XX:-UseSerialGC：不使用了串行收集器</li></ul></li><li>KV 设置类型：-XX:key=value<ul><li>-XX:MetaspaceSize=128m</li><li>-XX:MaxTenuringThreshold=15</li></ul></li><li><p>jinfo 举例，如何查看当前运行程序的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloGC</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello GC..."</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以使用 <code>jps -l</code> 命令，查出进程 id</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1923 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">1988 sun.tools.jps.Jps</span><br><span class="line">1173 org.jetbrains.kotlin.daemon.KotlinCompileDaemon</span><br><span class="line">32077 com.intellij.idea.Main</span><br><span class="line">1933 com.cuzz.jvm.HelloGC</span><br><span class="line">32382 org.jetbrains.idea.maven.server.RemoteMavenServer</span><br></pre></td></tr></table></figure><p>在使用 <code>jinfo -flag PrintGCDetails 1933</code> 命令查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-PrintGCDetails</span><br></pre></td></tr></table></figure><p>可以看出默认是不打印 GC 收集细节<br>也可是使用<code>jinfo -flags 1933</code> 查看所以的参数</p></li><li>两个经典参数：-Xms 和 - Xmx（如 -Xms1024m）<ul><li>-Xms 等价于 -XX:InitialHeapSize</li><li>-Xmx 等价于 -XX:MaxHeapSize</li></ul></li></ul></li></ul><h3 id="盘点家底查看-JVM-默认值"><a href="#盘点家底查看-JVM-默认值" class="headerlink" title="盘点家底查看 JVM 默认值"></a>盘点家底查看 JVM 默认值</h3><ul><li><p>查看初始默认值：-XX:+PrintFlagsInitial</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">cuzz@cuzz-pc:~/Project/demo$ java -XX:+PrintFlagsInitial</span><br><span class="line">[Global flags]</span><br><span class="line">     intx ActiveProcessorCount                      = -1                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeDecrementScaleFactor          = 4                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizeMajorGCDecayTimeScale         = 10                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePausePolicy                   = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyCollectionCostMargin    = 50                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyInitializingSteps       = 20                                  &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyOutputInterval          = 0                                   &#123;product&#125;</span><br><span class="line">    uintx AdaptiveSizePolicyWeight                  = 10                                  &#123;product&#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></li><li><p>查看修改更新：-XX:+PrintFlagsFinal</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool UsePSAdaptiveSurvivorSizePolicy           = true                                &#123;product&#125;</span><br><span class="line">bool UseParNewGC                               = false                               &#123;product&#125;</span><br><span class="line">bool UseParallelGC                            := true                                &#123;product&#125;</span><br><span class="line">bool UseParallelOldGC                          = true                                &#123;product&#125;</span><br><span class="line">bool UsePerfData                               = true                                &#123;product&#125;</span><br><span class="line">bool UsePopCountInstruction                    = true                                &#123;product&#125;</span><br><span class="line">bool UseRDPCForConstantTableBase               = false                               &#123;C2 product&#125;</span><br></pre></td></tr></table></figure><p>= 与 := 的区别是，一个是默认，一个是人物改变或者 jvm 加载时改变的参数</p></li><li>打印命令行参数(可以看默认垃圾回收器)：-XX:+PrintCommandLineFlags<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cuzz@cuzz-pc:~/Project/demo$ java -XX:+PrintCommandLineFlags</span><br><span class="line">-XX:InitialHeapSize=128789376 -XX:MaxHeapSize=2060630016 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseParallelGC</span><br></pre></td></tr></table></figure></li></ul><h2 id="你平时工作用过的-JVM-常用的基本配置参数有哪些？"><a href="#你平时工作用过的-JVM-常用的基本配置参数有哪些？" class="headerlink" title="你平时工作用过的 JVM 常用的基本配置参数有哪些？"></a>你平时工作用过的 JVM 常用的基本配置参数有哪些？</h2><ul><li>-Xms<ul><li>初始大小内存，默认为物理内存 1/64</li><li>等价于 -XX:InitialHeapSize</li></ul></li><li>-Xmx<ul><li>最大分配内存，默认为物理内存的 1/4</li><li>等价于 -XX:MaxHeapSize</li></ul></li><li>-Xss<ul><li>设置单个线程栈的大小，一般默认为 512-1024k</li><li>等价于 -XX:ThreadStackSize</li></ul></li><li>-Xmn<ul><li>设置年轻代的大小</li><li><strong>整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小</strong>，持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。</li></ul></li><li>-XX:MetaspaceSize<ul><li>设置元空间大小（元空间的本质和永久代类似，都是对 JVM 规范中的方法区的实现，不过元空间于永久代之间最大区别在于，<strong>元空间并不在虚拟中，而是使用本地内存</strong>，因此默认情况下，元空间的大小仅受本地内存限制）</li><li>元空间默认比较小，我们可以调大一点</li></ul></li><li><p>-XX:+PrintGCDetails</p><ul><li><p>输出详细 GC 收集日志信息</p><ul><li>设置 JVM 参数为： -Xms10m -Xmx10m -XX:+PrintGCDetails</li><li><p>代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class HelloGC &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        byte[] bytes = new byte[20 * 1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1231K-&gt;448K(2560K)] 1231K-&gt;456K(9728K), 0.0015616 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 448K-&gt;384K(2560K)] 456K-&gt;392K(9728K), 0.0016999 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 384K-&gt;0K(2560K)] [ParOldGen: 8K-&gt;358K(7168K)] 392K-&gt;358K(9728K), [Metaspace: 3028K-&gt;3028K(1056768K)], 0.0066696 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 358K-&gt;358K(9728K), 0.0005321 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 358K-&gt;340K(7168K)] 358K-&gt;340K(9728K), [Metaspace: 3028K-&gt;3028K(1056768K)], 0.0051543 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 81K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 3% used [0x00000000ffd00000,0x00000000ffd14668,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 340K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 4% used [0x00000000ff600000,0x00000000ff655188,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3060K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 336K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.cuzz.jvm.HelloGC.main(HelloGC.java:12)</span><br></pre></td></tr></table></figure></li></ul></li><li><p>GC<br><img src="JVM面试/a9a0eb99b30cf3fd8973f464eb4678bf50f760cc.jpg" alt="img"></p></li><li>FullGC<br><img src="JVM面试/e04f3f3b68cff61027e5ba8eba9613bb7c69a08a.jpg" alt="img"></li></ul></li><li>-XX:SurvivorRatio<ul><li>设置新生代中 eden 和 S0/S1 空间比例</li><li>默认 -XX:SurvivorRatio=8，Eden : S0 : S1 = 8 : 1 : 1</li></ul></li><li>-XX:NewRatio<ul><li>配置年轻代和老年代在堆结构的占比</li><li>默认 -XX:NewRatio=2 新生代占1，老年代占2，年轻代占整个堆的 1/3</li></ul></li><li>-XX:MaxTenuringThreshold<ul><li>设置垃圾最大年龄</li></ul></li></ul><h2 id="强引用、软引用、弱引用和虚引用分别是什么？"><a href="#强引用、软引用、弱引用和虚引用分别是什么？" class="headerlink" title="强引用、软引用、弱引用和虚引用分别是什么？"></a>强引用、软引用、弱引用和虚引用分别是什么？</h2><p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p><ul><li>强引用<ul><li>特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</li></ul></li><li><p>软引用</p><ul><li>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。</li><li>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</li><li><p>代码验证<br>我设置 JVM 参数为 <code>-Xms10m -Xmx10m -XX:+PrintGCDetails</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        SoftReference&lt;Object&gt; softReference = <span class="keyword">new</span> SoftReference&lt;&gt;(obj);</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 分配 20 M</span></span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"软引用："</span> + softReference.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [PSYoungGen: 1234K-&gt;448K(2560K)] 1234K-&gt;456K(9728K), 0.0016748 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 448K-&gt;384K(2560K)] 456K-&gt;392K(9728K), 0.0018398 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 384K-&gt;0K(2560K)] [ParOldGen: 8K-&gt;358K(7168K)] 392K-&gt;358K(9728K), [Metaspace: 3030K-&gt;3030K(1056768K)], 0.0057246 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] 358K-&gt;358K(9728K), 0.0006038 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [PSYoungGen: 0K-&gt;0K(2560K)] [ParOldGen: 358K-&gt;340K(7168K)] 358K-&gt;340K(9728K), [Metaspace: 3030K-&gt;3030K(1056768K)], 0.0115080 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] </span><br><span class="line">软引用：null</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at com.cuzz.jvm.SoftReferenceDemo.main(SoftReferenceDemo.java:21)</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 98K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 4% used [0x00000000ffd00000,0x00000000ffd18978,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 340K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 4% used [0x00000000ff600000,0x00000000ff6552f8,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3067K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 336K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>发现当内存不够的时候就会被回收。</p></li></ul></li><li><p>弱引用</p><ul><li>特点：弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</li><li>应用场景：弱应用同样可用于内存敏感的缓存。</li><li><p>代码验证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(obj);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line"></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"GC之后...."</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@1540e19d</span><br><span class="line">java.lang.Object@1540e19d</span><br><span class="line">GC之后....</span><br><span class="line">null</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>值得注意的是<code>String name = &quot;cuzz&quot;</code> 这种会放入永久代，以及 <code>Integer age = 1</code> 在 int 中 -128 到 127 会被缓存，所以是强引用，然后 GC 也不会被回收。</p></li><li><p>引用队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceQueueDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">        ReferenceQueue&lt;Object&gt; referenceQueue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">        WeakReference&lt;Object&gt; weakReference = <span class="keyword">new</span> WeakReference&lt;&gt;(obj, referenceQueue);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        System.out.println(weakReference);</span><br><span class="line"></span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"GC之后...."</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">        System.out.println(weakReference.get());</span><br><span class="line">        System.out.println(weakReference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object@1540e19d</span><br><span class="line">java.lang.Object@1540e19d</span><br><span class="line">java.lang.ref.WeakReference@677327b6</span><br><span class="line">GC之后....</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">java.lang.ref.WeakReference@677327b6</span><br></pre></td></tr></table></figure><p>会把该对象的包装类即<code>weakReference</code>放入到<code>ReferenceQueue</code>里面，我们可以从queue中获取到相应的对象信息，同时进行额外的处理。比如反向操作，数据清理等。</p></li></ul></li><li>虚引用<ul><li>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue);<br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</li><li>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。</li></ul></li></ul><h2 id="请谈谈你对-OOM-的认识？"><a href="#请谈谈你对-OOM-的认识？" class="headerlink" title="请谈谈你对 OOM 的认识？"></a>请谈谈你对 OOM 的认识？</h2><ul><li>java.lang.StackOverflowError<ul><li>在一个函数中调用自己就会产生这个错误</li></ul></li><li>java.lang.OutOfMemoryError : Java heap space<ul><li>new 一个很大对象</li></ul></li><li>java.lang.OutOfMemoryError : GC overhead limit exceeded<ul><li>执行垃圾收集的时间比例太大， 有效的运算量太小，默认情况下,，如果GC花费的时间超过 <strong>98%</strong>， 并且GC回收的内存少于 <strong>2%</strong>， JVM就会抛出这个错误。</li></ul></li><li><p>java.lang.OutOfMemoryError : Direct buffer memory<br>配置参数：-Xms10m -Xmx10m -XX:+PrintGCDetails -XX:MaxDirectMemorySize=5m</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectBufferDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"maxDirectMemory : "</span> + sun.misc.VM.maxDirectMemory() / (<span class="number">1024</span> * <span class="number">1024</span>) + <span class="string">"MB"</span>);</span><br><span class="line">        ByteBuffer byteBuffer = ByteBuffer.allocateDirect(<span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">maxDirectMemory : 5MB</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1315K-&gt;464K(2560K)] 1315K-&gt;472K(9728K), 0.0008907 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 464K-&gt;0K(2560K)] [ParOldGen: 8K-&gt;359K(7168K)] 472K-&gt;359K(9728K), [Metaspace: 3037K-&gt;3037K(1056768K)], 0.0060466 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] </span><br><span class="line">Exception in thread &quot;main&quot; java.lang.OutOfMemoryError: Direct buffer memory</span><br><span class="line">at java.nio.Bits.reserveMemory(Bits.java:694)</span><br><span class="line">at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123)</span><br><span class="line">at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311)</span><br><span class="line">at com.cuzz.jvm.DirectBufferDemo.main(DirectBufferDemo.java:17)</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 2560K, used 56K [0x00000000ffd00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 2048K, 2% used [0x00000000ffd00000,0x00000000ffd0e170,0x00000000fff00000)</span><br><span class="line">  from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000)</span><br><span class="line">  to   space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 7168K, used 359K [0x00000000ff600000, 0x00000000ffd00000, 0x00000000ffd00000)</span><br><span class="line">  object space 7168K, 5% used [0x00000000ff600000,0x00000000ff659e28,0x00000000ffd00000)</span><br><span class="line"> Metaspace       used 3068K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 336K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure></li><li><p>java.lang.OutOfMemoryError : unable to create new native thread</p><ul><li>创建线程数太多了</li></ul></li><li>java.lang.OutOfMemoryError : Metaspace<ul><li>Java 8 之后的版本使用元空间（Metaspace）代替了永久代，元空间是方法区在 HotSpot 中的实现，它与持久代最大的区别是：元空间并不在虚拟机中的内存中而是使用本地内存。</li><li>元空间存放的信息：<ul><li>虚拟机加载的类信息</li><li>常量池</li><li>静态变量</li><li>即时编译后的代码</li></ul></li></ul></li></ul><p>具体的实现可以看看这个帖子：<a href="http://www.dataguru.cn/thread-351920-1-1.html" target="_blank" rel="noopener">几种手动OOM的方式</a></p><h2 id="GC-垃圾回收算法和垃圾收集器的关系？谈谈你的理解？"><a href="#GC-垃圾回收算法和垃圾收集器的关系？谈谈你的理解？" class="headerlink" title="GC 垃圾回收算法和垃圾收集器的关系？谈谈你的理解？"></a>GC 垃圾回收算法和垃圾收集器的关系？谈谈你的理解？</h2><ul><li>四种 GC 垃圾回收算法<ul><li>引用计数</li><li>复制回收</li><li>标记清除</li><li>标记整理</li></ul></li><li>GC 算法是内存回收的方法论，垃圾收集其就是算法的落实的实现。</li><li>目前为止还没有完美的收集器的出现，更加没有万能的收集器，只是针对具体应用最适合的收集器，进行分代收集。</li><li>串行垃圾回收器（Serial）<ul><li>它为单线程环境设计且只使用一个线程进行垃圾回收，会暂停所有的用户线程，所以不适合服务环境。</li></ul></li><li>并行垃圾回收器（Parallel）<ul><li>多个垃圾收集线程并行工作，此时用户线程是暂停的，用于科学计算、大数据处理等弱交互场景。</li></ul></li><li>并发垃圾回收器（CMS）<ul><li>用户线程和垃圾收集线程同时执行（不一定是并行，可能是交替执行），不需要停顿用户线程，互联网公司多用它，适用对相应时间有要求的场景。</li></ul></li><li>G1 垃圾回收器<ul><li>G1 垃圾回收器将堆内存分割成不同的区域然后并发的对其进行垃圾回收。</li></ul></li></ul><h2 id="怎么查看服务器默认垃圾收集器是哪个？生产是如何配置垃圾收集器？谈谈你对垃圾收集器的理解？"><a href="#怎么查看服务器默认垃圾收集器是哪个？生产是如何配置垃圾收集器？谈谈你对垃圾收集器的理解？" class="headerlink" title="怎么查看服务器默认垃圾收集器是哪个？生产是如何配置垃圾收集器？谈谈你对垃圾收集器的理解？"></a>怎么查看服务器默认垃圾收集器是哪个？生产是如何配置垃圾收集器？谈谈你对垃圾收集器的理解？</h2><ul><li>怎么查看服务器默认垃圾收集器是哪个？<ul><li>Java -XX:+PrintCommandLineFlags</li></ul></li><li>Java 的 GC 回收的类型主要有：<ul><li>UseSerialGC，UseParallelGC，UseConcMarkSweepGC，UseParNewGC，UseParallelOldGC，UseG1GC</li><li>Java 8 以后基本不使用 Serial Old</li></ul></li><li>垃圾收集器<br><img src="JVM面试/timg.jpg" alt="timg"></li><li>参数说明<ul><li>DefNew : Default New Generation</li><li>Tenured : Old</li><li>ParNew : Parallel New Generation</li><li>PSYoungGen : Parallel Scavenge</li><li>ParOldGen : Parallel Old Generation</li></ul></li><li>Server/Client 模式分别是什么意思<ul><li>最主要的差别在于：-Server模式启动时，速度较慢，但是一旦运行起来后，性能将会有很大的提升。</li><li>当虚拟机运行在-client模式的时候，使用的是一个代号为C1的轻量级编译器, 而-server模式启动的虚拟机采用相对重量级，代号为C2的编译器，C2比C1编译器编译的相对彻底，服务起来之后,性能更高。</li><li>所以通常用于做服务器的时候我们用服务端模式，如果你的电脑只是运行一下java程序，就客户端模式就可以了。当然这些都是我们做程序优化程序才需要这些东西的，普通人并不关注这些专业的东西了。其实服务器模式即使编译更彻底，然后垃圾回收优化更好，这当然吃的内存要多点相对于客户端模式。</li></ul></li><li>新生代<ul><li>串行 GC (Serial/ Serital Copying)</li><li>并行 GC (ParNew)</li><li>并行回收 GC (Parallel/ Parallel Scanvenge)</li></ul></li><li>老年代<ul><li>串行 GC (Serial Old/ Serial MSC)</li><li>并行 GC (Parallel Old/ Parallel MSC)</li><li>并发标记清除 GC (CMS)<ul><li>是一种以获取最短回收停顿时间为目标的收集器，适合应用在互联网站或者 B/S 系统的服务器上，这个类应用尤其重视服务器的响应速度，希望系统停顿时间最短。</li><li>CMS 非常适合堆内存大、CPU 核数多的服务器端应用，也是 G1 出现之前大型应用首选收集器。</li><li>并发停顿比较少，并发指的是与用户线程一起执行。</li><li>过程<ul><li>初始标记（initail mark）：只是标记一下 GC Roots 能直接关联的对象，速度很快，需要暂停所有的工作线程</li><li>并发标记（concurrent mark 和用户线程一起）：进行 GC Roots 的跟踪过程，和用户线程一起工作，不需要暂停工作线程。</li><li>重新标记（remark）：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。</li><li>并发清除（concurrent sweep 和用户线程一起）：清除 GC 不可达对象，和用户线程一起工作，不需要暂停工作线程，基于标记结果，直接清除。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程和用户线程可以一起并发工作，所以总体来看 CMS 收集器的内存回收和用户线程是一起并发地执行。</li></ul></li><li>优缺点<ul><li>优点：并发收集停顿低</li><li>缺点：并发执行对 CPU 资源压力大，采用的标记清除算法会导致大量碎片</li></ul></li><li>由于并发进行， CMS 在收集与应用线程会同时增加对堆内存的占用，也就是说，CMS 必须要在老年代堆用尽之前完成垃圾回收，否者 CMS 回收失败，将触发担保机制，串行老年代收集器将会以 STW 的方式进行一次 GC，从而造成较大的停顿时间。</li><li>标记清除算法无法整理空间碎片，老年代空间会随着应用时长被逐渐耗尽，最后将不得不通过担保机制对堆内存进行压缩。CMS 也提供了参数 -XX:CMSFullGCsBeForeCompaction (默认0，即每次都进行内存整理) 来指定多少次 CMS 收集之后，进行一次压</li></ul></li></ul></li><li>垃圾收集器配置代码总结<ul><li>配置新生代收集器，老年代收集器会自动配置上。<br><img src="JVM面试/1558237229584.png" alt="1558237229584"></li></ul></li><li>如何选择垃圾收集器<ul><li>单 CPU 或者小内存，单机程序：-XX:UseSerialGC</li><li>多 CPU 需要最大吞吐量，如后台计算型应用：-XX:UseParallelGC 或者 -XX:UseParallelOldGC</li><li>多 CPU 追求低停顿时间，需要快速响应，如互联网应用：-XX:+UseConcMarkSweepGC</li></ul></li></ul><h2 id="G1-垃圾收集器你了解吗？"><a href="#G1-垃圾收集器你了解吗？" class="headerlink" title="G1 垃圾收集器你了解吗？"></a>G1 垃圾收集器你了解吗？</h2><ul><li>以前收集器的特点<ul><li>年轻代和老年代是各自独立且连续的内存块</li><li>年轻代收集器使用 eden + S0 + S1 进行复制算法</li><li>老年代收集必须扫描整个老年代区域</li><li>都是以尽可能的少而快速地执行 GC 为设计原则</li></ul></li><li>G1 是什么<ul><li>G1 是一种面向服务端的垃圾收集器，应用在多核处理器和大容量内存环境中，在实现高吞吐量的同时，尽可能的满足垃圾收集器的暂停时间要求。</li><li>像 CMS 收集器一样，能与应用程序线程并发执行，整理空闲空间更快，需要更多的时间来预测 GC 停顿时间，不希望牺牲大量的吞吐性能，不需要更大的 JAVA Heap。</li><li>G1 收集器的设计目的是取代 CMS 收集器，同时与 CMS 相比，G1 垃圾收集器是一个有整理内存过程的垃圾收集器，不会产生很多内存碎片。G1 的 Stop The World 更可控，G1 在停顿上添加了预测机制，用户可以指定期望的停顿时间。</li><li>G1 是在 2012 年才在 jdk.1.7u4 中可以呀用，在 jdk9 中将 G1 变成默认垃圾收集器来代替 CMS。它是以款面向服务应用的收集器。</li><li>主要改变是 Eden、Survivor 和 Tenured 等内存区域不再是连续的，而是变成了一个个大小一样的 region，每个 region 从 1M 到 32M 不等，一个 region 有可能属于 Eden、Survivor 或者 Tenured 内存区域。</li></ul></li><li>特点<ul><li>G1 能充分利用多 CPU、多核环境硬件优势，尽量缩短 STW。</li><li>G1 整体采用标记-整理算法，局部是通过是通过复制算法，<strong>不会产生内存碎片</strong>。</li><li>宏观上看 G1 之中不在区分年轻代和老年代，被内存划分为多个独立的子区域。</li><li>G1 收集器里面讲整个的内存区域混合在一起，<strong>但其本身依然在小范围内要进行年轻代和老年代的区分</strong>。保留了新生代和老年代，但她们不在是物理隔离，而是一部分 Region 的集合且不需要 Region 是连续的，也就是说依然会采用不同的 GC 方式来处理不同的区域。</li><li>G1 虽然也是分代收集器，但整个内存分区不存在物理上的年轻代和老年代的区别，也不需要完全独立的 Survivor to space 堆做复制准备。G1 只有逻辑上的分代概念，或者说每个分区都可能随 G1 的运行在不同代之间前后切换。</li></ul></li><li><p>底层原理</p><ul><li><p>Region 区域化垃圾收集器：最大好处是化整为零，避免全内存扫描，只需要按照区域来进行扫描即可。</p></li><li><h3 id="Region"><a href="#Region" class="headerlink" title="Region"></a>Region</h3><p><img src="JVM面试/5611237-f643066bd97c7703.png" alt="5611237-f643066bd97c7703"><br>G1的内存结构和传统的内存空间划分有比较的不同。G1将内存划分成了多个大小相等的Region（默认是512K），Region逻辑上连续，物理内存地址不连续。同时每个Region被标记成E、S、O、H，分别表示Eden、Survivor、Old、Humongous。其中E、S属于年轻代，O与H属于老年代。<br>H表示Humongous。从字面上就可以理解表示大的对象（下面简称H对象）。<strong>当分配的对象大于等于Region大小的一半</strong>的时候就会被认为是巨型对象。H对象默认分配在老年代，可以防止GC的时候大对象的内存拷贝。通过如果发现堆内存容不下H对象的时候，会触发一次GC操作。 </p></li><li>回收步骤<ul><li>参看：<a href="https://www.jianshu.com/p/548c67aa1bc0" target="_blank" rel="noopener">G1从入门到放弃</a></li></ul></li><li>四步过程<br><img src="JVM面试/u=1236259389,1737476709&amp;fm=26&amp;gp=0.jpg" alt="u=1236259389,1737476709&amp;fm=26&amp;gp=0"></li></ul></li></ul><h2 id="生产环境服务器变慢，诊断思路和性能评估谈谈？"><a href="#生产环境服务器变慢，诊断思路和性能评估谈谈？" class="headerlink" title="生产环境服务器变慢，诊断思路和性能评估谈谈？"></a>生产环境服务器变慢，诊断思路和性能评估谈谈？</h2><ul><li>整机：top</li><li>CPU：vmstat</li><li>内存：free</li><li>硬盘：df</li><li>磁盘IO：iostat</li><li>网络IO：ifstat</li></ul><h2 id="假如生产环境出现-CPU-过高，请谈谈你的分析思路和定位？"><a href="#假如生产环境出现-CPU-过高，请谈谈你的分析思路和定位？" class="headerlink" title="假如生产环境出现 CPU 过高，请谈谈你的分析思路和定位？"></a>假如生产环境出现 CPU 过高，请谈谈你的分析思路和定位？</h2><ul><li>先用 top 命令找出 CPU 占比最高的</li><li>ps -ef 或者 jps 进一步定位，得知是一个怎么样的一个后台程序</li><li>定位到具体的线程或代码<ul><li>ps -mp 11111 -o THREAD,tid,time</li><li>-m 显示所有的线程</li><li>-p 进程使用cpu的时间</li><li>-o 该参数后是用户自定义格式</li></ul></li><li>将需要的线程 ID 转化为 16 进制格式</li><li>jstat &lt;进程ID&gt; | grep &lt;线程ID(16进制)&gt; -A60</li></ul><h2 id="对于-JDK-自带的-JVM-监控和性能分析工具用过哪些？一般机是怎么用到的？"><a href="#对于-JDK-自带的-JVM-监控和性能分析工具用过哪些？一般机是怎么用到的？" class="headerlink" title="对于 JDK 自带的 JVM 监控和性能分析工具用过哪些？一般机是怎么用到的？"></a>对于 JDK 自带的 JVM 监控和性能分析工具用过哪些？一般机是怎么用到的？</h2><p>下一篇重点介绍。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://time.geekbang.org/column/article/6970" target="_blank" rel="noopener">强引用、软引用、弱引用、幻象引用有什么区别？(评论)</a></li><li><a href="https://www.jianshu.com/p/548c67aa1bc0" target="_blank" rel="noopener">G1从入门到放弃</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;JVM-垃圾回收的时候如何确定垃圾？知道什么是-GC-Roots&quot;&gt;&lt;a href=&quot;#JVM-垃圾回收的时候如何确定垃圾？知道什么是-GC-Roots&quot; class=&quot;headerlink&quot; title=&quot;JVM 垃圾回收的时候如何确定垃圾？知道什么是 GC R
      
    
    </summary>
    
      <category term="面试" scheme="http://blog.cuzz.site/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="JVM" scheme="http://blog.cuzz.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>2019春招总结</title>
    <link href="http://blog.cuzz.site/2019/05/07/2019%E6%98%A5%E6%8B%9B%E6%80%BB%E7%BB%93/"/>
    <id>http://blog.cuzz.site/2019/05/07/2019春招总结/</id>
    <published>2019-05-07T15:59:59.000Z</published>
    <updated>2019-05-14T14:10:03.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>3 月份开始准备春招到现在已经 2 个多月了， 总结一下这个两个月的面试的一些情况，下面是我这个月面过的一些公司。</p><a id="more"></a><table><thead><tr><th style="text-align:center">时间</th><th style="text-align:center">公司</th><th style="text-align:center">地点</th></tr></thead><tbody><tr><td style="text-align:center">2019/3/5 15:30</td><td style="text-align:center">腾讯</td><td style="text-align:center">视频</td></tr><tr><td style="text-align:center">2019/3/9 19:30</td><td style="text-align:center">腾讯</td><td style="text-align:center">视频</td></tr><tr><td style="text-align:center">2019/3/11 15:00</td><td style="text-align:center">氦科技</td><td style="text-align:center">现场</td></tr><tr><td style="text-align:center">2019/3/12 14:00</td><td style="text-align:center">航班管家</td><td style="text-align:center">现场</td></tr><tr><td style="text-align:center">2019/3/15 15:00</td><td style="text-align:center">字节跳动</td><td style="text-align:center">视频</td></tr><tr><td style="text-align:center">2019/3/19 15:00</td><td style="text-align:center">阿里巴巴</td><td style="text-align:center">电话</td></tr><tr><td style="text-align:center">2019/3/21 15:00</td><td style="text-align:center">阿里巴巴</td><td style="text-align:center">电话</td></tr><tr><td style="text-align:center">2019/3/28 15:00</td><td style="text-align:center">阿里巴巴</td><td style="text-align:center">电话</td></tr><tr><td style="text-align:center">2019/3/29 19:00</td><td style="text-align:center">快手</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/1 19:00</td><td style="text-align:center">虎牙</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/3 19:00</td><td style="text-align:center">拼多多</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/5 19:00</td><td style="text-align:center">腾讯</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/6 19:00</td><td style="text-align:center">百度</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/10 19:00</td><td style="text-align:center">华为</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/12 19:00</td><td style="text-align:center">阿里巴巴</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/14 19:00</td><td style="text-align:center">完美世界</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/15 10:00</td><td style="text-align:center">华为</td><td style="text-align:center">现场</td></tr><tr><td style="text-align:center">2019/4/15 15:00</td><td style="text-align:center">作业帮</td><td style="text-align:center">笔试</td></tr><tr><td style="text-align:center">2019/4/21 19:00</td><td style="text-align:center">菜鸟</td><td style="text-align:center">电话</td></tr><tr><td style="text-align:center">2019/5/6 17:00</td><td style="text-align:center">去哪儿</td><td style="text-align:center">现场</td></tr><tr><td style="text-align:center">2019/5/7 19:00</td><td style="text-align:center">菜鸟</td><td style="text-align:center">电话</td></tr></tbody></table><h2 id="一些面试没有答出的的题目"><a href="#一些面试没有答出的的题目" class="headerlink" title="一些面试没有答出的的题目"></a>一些面试没有答出的的题目</h2><p>有的面试已经过去很久了，我就把我印象比较深的题目列出来</p><ul><li>HashMap 为什么使用红黑树而不使用平衡树？（菜鸟）</li><li>6大设计原则，什么是高内聚低耦合（菜鸟）</li><li>衡量垃圾收集器的指标有哪些，说说CMS收集器，CMS 为什么需要暂停 - stop the world？（菜鸟）</li><li>知道 C++ 的析构函数吗？在 JAVA 中调用 finalize 的会怎样？那你知道  finalize 有什么作用？（菜鸟）</li><li>说说一致性Hash算法，它解决了什么问题？（菜鸟）</li><li>Dubbo 有哪些传输协议？（阿里）</li><li>最短路径？（阿里）</li><li>HTTPS 加密过程，是怎么保证信息可靠的？（头条）</li><li>Dubbo 有哪些负载均衡策略？（头条）</li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>其实很多都是笔试挂了，自己刷了剑指offer 还有 leetcode 一些题，还是很难通过一些大公司的笔试题，最近在实习刷的比较少，有时候没手感，看到题目都是懵逼状态，所以还是要坚持刷题。</p><p>阿里面试时直接打电话过来，我一般都没有时间准备就开始面试了，最可惜的是阿里第三面的时候，我认为第三面会问比较多项目，然而他问了很多计算机基础的知识，比如红黑树、最短路径问题等，这些我都没答好，所以就凉凉了，自己在这方面还是比较薄弱，需要加强。</p><p>当然也收到了几个 offer，经历了这段面试，自己也学到了挺多，至少不再畏惧面试了，也知道了大厂需要什么样的人才，继续努力，秋招再来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;3 月份开始准备春招到现在已经 2 个多月了， 总结一下这个两个月的面试的一些情况，下面是我这个月面过的一些公司。&lt;/p&gt;
    
    </summary>
    
      <category term="日记" scheme="http://blog.cuzz.site/categories/%E6%97%A5%E8%AE%B0/"/>
    
    
      <category term="面试" scheme="http://blog.cuzz.site/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发编程</title>
    <link href="http://blog.cuzz.site/2019/04/16/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    <id>http://blog.cuzz.site/2019/04/16/Java并发编程/</id>
    <published>2019-04-16T15:59:59.000Z</published>
    <updated>2019-10-19T16:46:20.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="请谈谈你对-volatile-的理解"><a href="#请谈谈你对-volatile-的理解" class="headerlink" title="请谈谈你对 volatile 的理解"></a>请谈谈你对 volatile 的理解</h2><h3 id="volatile-是-Java-虚拟机提供的轻量级的同步机制"><a href="#volatile-是-Java-虚拟机提供的轻量级的同步机制" class="headerlink" title="volatile 是 Java 虚拟机提供的轻量级的同步机制"></a>volatile 是 Java 虚拟机提供的轻量级的同步机制</h3><ul><li>保证可见性</li><li>禁止指令排序</li><li>不保证原子性</li></ul><a id="more"></a><h3 id="JMM（Java-内存模型）-你谈谈"><a href="#JMM（Java-内存模型）-你谈谈" class="headerlink" title="JMM（Java 内存模型） 你谈谈"></a>JMM（Java 内存模型） 你谈谈</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li>JMM 本身是一种抽象的概念并不是真实存在，它描述的是一组规定或则规范，通过这组规范定义了程序中的访问方式。</li><li>JMM 同步规定<ul><li>线程解锁前，必须把共享变量的值刷新回主内存</li><li>线程加锁前，必须读取主内存的最新值到自己的工作内存</li><li>加锁解锁是同一把锁</li></ul></li><li>由于 JVM 运行程序的实体是线程，而每个线程创建时 JVM 都会为其创建一个工作内存，工作内存是每个线程的私有数据区域，而 Java 内存模型中规定所有变量的储存在主内存，主内存是共享内存区域，所有的线程都可以访问，但线程对变量的操作（读取赋值等）必须都工作内存进行看。</li><li>首先要将变量从主内存拷贝的自己的工作内存空间，然后对变量进行操作，操作完成后再将变量写回主内存，不能直接操作主内存中的变量，工作内存中存储着主内存中的变量副本拷贝，前面说过，工作内存是每个线程的私有数据区域，因此不同的线程间无法访问对方的工作内存，线程间的通信(传值)必须通过主内存来完成。</li><li>内存模型图<br><img src="Java并发编程/搜狗截图20190416211412.png" alt="搜狗截图20190416211412"></li></ul><h4 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h4><ul><li><p>可见性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/4/16 21:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 可见性代码实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" coming..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            data.addOne();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" updated..."</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (data.a == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// looping</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" job is done..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不加 volatile 关键字，则主线程会进入死循环，加 volatile 则主线程能够退出，说明加了 volatile 关键字变量，当有一个线程修改了值，会马上被另一个线程感知到，当前值作废，从新从主内存中获取值。对其他线程可见，这就叫可见性。</p></li><li><p>原子性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// test01();</span></span><br><span class="line">       test02();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试原子性</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Data data = <span class="keyword">new</span> Data();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">1000</span>; j++) &#123;</span><br><span class="line">                    data.addOne();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认有 main 线程和 gc 线程</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">2</span>) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(data.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现并不能输入 20000</p></li><li><p>有序性</p><ul><li>计算机在执行程序时，为了提高性能，编译器个处理器常常会对指令做重排，一般分为以下 3 种<ul><li>编译器优化的重排</li><li>指令并行的重排</li><li>内存系统的重排</li></ul></li><li>单线程环境里面确保程序最终执行的结果和代码执行的结果一致</li><li>处理器在进行重排序时必须考虑指令之间的数据依赖性</li><li>多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证用的变量能否一致性是无法确定的，结果无法预测</li><li><p>代码示例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReSortSeqDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        a = <span class="number">1</span>;           <span class="comment">// flag = true;</span></span><br><span class="line">                         <span class="comment">// ----线程切换----</span></span><br><span class="line">        flag = <span class="keyword">true</span>;     <span class="comment">// a = 1;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            a = a + <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">"a = "</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个线程同时执行，method01 和 method02 如果线程 1 执行 method01 重排序了，然后切换的线程 2 执行 method02 就会出现不一样的结果。</p></li></ul></li></ul><h4 id="禁止指令排序"><a href="#禁止指令排序" class="headerlink" title="禁止指令排序"></a>禁止指令排序</h4><p>volatile 实现禁止指令重排序的优化，从而避免了多线程环境下程序出现乱序的现象</p><p>先了解一个概念，内存屏障（Memory Barrier）又称内存栅栏，是一个 CPU 指令，他的作用有两个：</p><ul><li>保证特定操作的执行顺序</li><li>保证某些变量的内存可见性（利用该特性实现 volatile 的内存可见性）</li></ul><p>由于编译器个处理器都能执行指令重排序优化，如果在指令间插入一条 Memory Barrier 则会告诉编译器和 CPU，不管什么指令都不能个这条 Memory Barrier 指令重排序，也就是说通过插入内存屏障禁止在内存屏障前后执行重排序优化。内存屏障另一个作用是强制刷出各种 CPU 缓存数据，因此任何 CPU 上的线程都能读取到这些数据的最新版本。</p><p>下面是保守策略下，volatile写插入内存屏障后生成的指令序列示意图： </p><p><img src="Java并发编程/0e75180bf35c40e2921493d0bf6bd684_th.png" alt="0e75180bf35c40e2921493d0bf6bd684_th"></p><p>下面是在保守策略下，volatile读插入内存屏障后生成的指令序列示意图： </p><p><img src="Java并发编程/21ebc7e8190c4966948c4ef4424088be_th.png" alt="21ebc7e8190c4966948c4ef4424088be_th"></p><h4 id="线程安全性保证"><a href="#线程安全性保证" class="headerlink" title="线程安全性保证"></a>线程安全性保证</h4><ul><li>工作内存与主内存同步延迟现象导致可见性问题<ul><li>可以使用 synchronzied 或 volatile 关键字解决，它们可以使用一个线程修改后的变量立即对其他线程可见</li></ul></li><li>对于指令重排导致可见性问题和有序性问题<ul><li>可以利用 volatile 关键字解决，因为 volatile 的另一个作用就是禁止指令重排序优化</li></ul></li></ul><h3 id="你在哪些地方用到过-volatile"><a href="#你在哪些地方用到过-volatile" class="headerlink" title="你在哪些地方用到过 volatile"></a>你在哪些地方用到过 volatile</h3><h4 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h4><ul><li><p>多线程环境下可能存在的安全问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NotThreadSafe</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton01 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton01</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  construction..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton01 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton01();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt; Singleton01.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现构造器里的内容会多次输出</p></li><li><p>双重锁单例</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton02 instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton02</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"  construction..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton02 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton01.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton02();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            executorService.execute(()-&gt; Singleton02.getInstance());</span><br><span class="line">        &#125;</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>如果没有加 volatile 就不一定是线程安全的，原因是指令重排序的存在，加入 volatile 可以禁止指令重排。</p></li><li><p>原因是在于某一个线程执行到第一次检测，读取到的 instance 不为 null 时，<strong>instance 的引用对象可能还没有完成初始化。</strong></p></li><li><p><code>instance = new Singleton()</code> 可以分为以下三步完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  // 1.分配对象空间</span><br><span class="line">instance(memory);     // 2.初始化对象</span><br><span class="line">instance = memory;    // 3.设置instance指向刚分配的内存地址，此时instance != null</span><br></pre></td></tr></table></figure></li><li><p>步骤 2 和步骤 3 不存在依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，因此这种优化是允许的。</p></li><li><p>发生重排</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">memory = allocate();  <span class="comment">// 1.分配对象空间</span></span><br><span class="line">instance = memory;    <span class="comment">// 3.设置instance指向刚分配的内存地址，此时instance != null，但对象还没有初始化完成</span></span><br><span class="line">instance(memory);     <span class="comment">// 2.初始化对象</span></span><br></pre></td></tr></table></figure></li><li><p>所以不加 volatile 返回的实例不为空，但可能是未初始化的实例</p></li></ul></li></ul><h2 id="CAS-你知道吗？"><a href="#CAS-你知道吗？" class="headerlink" title="CAS 你知道吗？"></a>CAS 你知道吗？</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CASDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">666</span>);</span><br><span class="line">        <span class="comment">// 获取真实值，并替换为相应的值</span></span><br><span class="line">        <span class="keyword">boolean</span> b = atomicInteger.compareAndSet(<span class="number">666</span>, <span class="number">2019</span>);</span><br><span class="line">        System.out.println(b); <span class="comment">// true</span></span><br><span class="line">        <span class="keyword">boolean</span> b1 = atomicInteger.compareAndSet(<span class="number">666</span>, <span class="number">2020</span>);</span><br><span class="line">        System.out.println(b1); <span class="comment">// false</span></span><br><span class="line">        atomicInteger.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CAS-底层原理？谈谈对-UnSafe-的理解？"><a href="#CAS-底层原理？谈谈对-UnSafe-的理解？" class="headerlink" title="CAS 底层原理？谈谈对 UnSafe 的理解？"></a>CAS 底层原理？谈谈对 UnSafe 的理解？</h3><h4 id="getAndIncrement"><a href="#getAndIncrement" class="headerlink" title="getAndIncrement();"></a>getAndIncrement();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>引出一个问题：UnSafe 类是什么？</p><h4 id="UnSafe-类"><a href="#UnSafe-类" class="headerlink" title="UnSafe 类"></a>UnSafe 类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6214790243416807050L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapInt for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取下面 value 的地址偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Unsafe 是 CAS 的核心类，由于 Java 方法无法直接访问底层系统，而需要通过本地（native）方法来访问， Unsafe 类相当一个后门，基于该类可以直接操作特定内存的数据。Unsafe 类存在于 sun.misc 包中，其内部方法操作可以像 C 指针一样直接操作内存，因为 Java 中 CAS 操作执行依赖于 Unsafe 类。 </li><li>变量 vauleOffset，表示该变量值在内存中的偏移量，因为 Unsafe 就是根据内存偏移量来获取数据的。</li><li>变量 value 用 volatile 修饰，保证了多线程之间的内存可见性。</li></ul><h4 id="CAS-是什么"><a href="#CAS-是什么" class="headerlink" title="CAS 是什么"></a>CAS 是什么</h4><ul><li><p>CAS    的全称 Compare-And-Swap，它是一条 CPU 并发。</p></li><li><p>它的功能是判断内存某一个位置的值是否为预期，如果是则更改这个值，这个过程就是原子的。</p></li><li><p>CAS 并发原体现在 JAVA 语言中就是 sun.misc.Unsafe 类中的各个方法。调用 UnSafe 类中的 CAS 方法，JVM 会帮我们实现出 CAS 汇编指令。这是一种完全依赖硬件的功能，通过它实现了原子操作。由于 CAS 是一种系统源语，源语属于操作系统用语范畴，是由若干条指令组成，用于完成某一个功能的过程，并且原语的执行必须是连续的，在执行的过程中不允许被中断，也就是说 CAS 是一条原子指令，不会造成所谓的数据不一致的问题。 </p></li><li><p>分析一下 getAndAddInt 这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// unsafe.getAndAddInt</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object obj, <span class="keyword">long</span> valueOffset, <span class="keyword">long</span> expected, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        temp = <span class="keyword">this</span>.getIntVolatile(obj, valueOffset);  <span class="comment">// 获取快照值</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="keyword">this</span>.compareAndSwap(obj, valueOffset, temp, temp + val));  <span class="comment">// 如果此时 temp 没有被修改，就能退出循环，否则重新获取</span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="CAS-的缺点？"><a href="#CAS-的缺点？" class="headerlink" title="CAS 的缺点？"></a>CAS 的缺点？</h3><ul><li>循环时间长开销很大<ul><li>如果 CAS 失败，会一直尝试，如果 CAS 长时间一直不成功，可能会给 CPU 带来很大的开销（比如线程数很多，每次比较都是失败，就会一直循环），所以希望是线程数比较小的场景。</li></ul></li><li>只能保证一个共享变量的原子操作<ul><li>对于多个共享变量操作时，循环 CAS 就无法保证操作的原子性。</li></ul></li><li>引出 ABA 问题</li></ul><h2 id="原子类-AtomicInteger-的-ABA-问题谈一谈？原子更新引用知道吗？"><a href="#原子类-AtomicInteger-的-ABA-问题谈一谈？原子更新引用知道吗？" class="headerlink" title="原子类 AtomicInteger 的 ABA 问题谈一谈？原子更新引用知道吗？"></a>原子类 AtomicInteger 的 ABA 问题谈一谈？原子更新引用知道吗？</h2><ul><li><p>原子引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User cuzz = <span class="keyword">new</span> User(<span class="string">"cuzz"</span>, <span class="number">18</span>);</span><br><span class="line">        User faker = <span class="keyword">new</span> User(<span class="string">"faker"</span>, <span class="number">20</span>);</span><br><span class="line">        AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">        atomicReference.set(cuzz);</span><br><span class="line">        System.out.println(atomicReference.compareAndSet(cuzz, faker)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(atomicReference.get()); <span class="comment">// User(userName=faker, age=20)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>ABA 问题是怎么产生的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: learn-demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: ABA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-04-21 23:31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 保证上面线程先执行</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>);</span><br><span class="line">            System.out.println(atomicReference.get()); <span class="comment">// 2019</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当有一个值从 A 改为 B 又改为 A，这就是 ABA 问题。</p></li><li><p>时间戳原子引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cuzz.thread;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReference;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicStampedReference;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: learn-demo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: ABA</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2019-04-21 23:31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 的版本号为："</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span> );</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>, atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + <span class="number">1</span> );</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 的版本号为："</span> + stamp);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">boolean</span> b = atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>, stamp, stamp + <span class="number">1</span>);</span><br><span class="line">            System.out.println(b); <span class="comment">// false</span></span><br><span class="line">            System.out.println(atomicStampedReference.getReference()); <span class="comment">// 100</span></span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先保证两个线程的初始版本为一致，后面修改是由于版本不一样就会修改失败。</p></li></ul><h2 id="我们知道-ArrayList-是线程不安全，请编写一个不安全的案例并给出解决方案？"><a href="#我们知道-ArrayList-是线程不安全，请编写一个不安全的案例并给出解决方案？" class="headerlink" title="我们知道 ArrayList 是线程不安全，请编写一个不安全的案例并给出解决方案？"></a>我们知道 ArrayList 是线程不安全，请编写一个不安全的案例并给出解决方案？</h2><ul><li><p>故障现象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                list.add(random.nextInt(<span class="number">10</span>));</span><br><span class="line">                System.out.println(list);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现报 <code>java.util.ConcurrentModificationException</code> </p></li><li><p>导致原因</p><ul><li>并发修改导致的异常</li></ul></li><li><p>解决方案</p><ul><li><code>new Vector();</code></li><li><code>Collections.synchronizedList(new ArrayList&lt;&gt;());</code></li><li><code>new CopyOnWriteArrayList&lt;&gt;();</code></li></ul></li><li><p>优化建议</p><ul><li>在读多写少的时候推荐使用 CopeOnWriteArrayList 这个类</li></ul></li></ul><h2 id="java-中锁你知道哪些？请手写一个自旋锁？"><a href="#java-中锁你知道哪些？请手写一个自旋锁？" class="headerlink" title="java 中锁你知道哪些？请手写一个自旋锁？"></a>java 中锁你知道哪些？请手写一个自旋锁？</h2><h3 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h3><ul><li>是什么<ul><li><strong>公平锁：</strong>是指多个线程按照申请的顺序来获取值</li><li><strong>非公平锁：</strong>是值多个线程获取值的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发的情况下，可能会造成优先级翻转或者饥饿现象</li></ul></li><li>两者区别<ul><li><strong>公平锁：</strong>在并发环境中，每一个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个就占有锁，否者就会加入到等待队列中，以后会按照 FIFO 的规则获取锁</li><li><strong>非公平锁：</strong>一上来就尝试占有锁，如果失败在进行排队</li></ul></li></ul><h3 id="可重入锁和不可重入锁"><a href="#可重入锁和不可重入锁" class="headerlink" title="可重入锁和不可重入锁"></a>可重入锁和不可重入锁</h3><ul><li><p>是什么</p><ul><li><strong>可重入锁：</strong>指的是同一个线程外层函数获得锁之后，内层仍然能获取到该锁，在同一个线程在外层方法获取锁的时候，在进入内层方法或会自动获取该锁       </li><li><strong>不可重入锁：</strong> 所谓不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞 </li></ul></li><li><p>代码实现</p><ul><li><p>可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    Thread lockedBy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lockedCount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span> (isLocked &amp;&amp; lockedBy != thread) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">        lockedCount++;</span><br><span class="line">        lockedBy = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() == lockedBy) &#123;</span><br><span class="line">            lockedCount--;</span><br><span class="line">            <span class="keyword">if</span> (lockedCount == <span class="number">0</span>) &#123;</span><br><span class="line">                isLocked = <span class="keyword">false</span>;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"><span class="comment">//    NotReentrantLock lock = new NotReentrantLock();</span></span><br><span class="line">    ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        doAdd();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        System.out.println(<span class="string">"ReentrantLock"</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        count.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现可以输出 ReentrantLock，我们设计两个线程调用 print() 方法，第一个线程调用 print() 方法获取锁，进入 lock() 方法，由于初始 lockedBy 是 null，所以不会进入 while 而挂起当前线程，而是是增量 lockedCount 并记录 lockBy 为第一个线程。接着第一个线程进入 doAdd() 方法，由于同一进程，所以不会进入 while 而挂起，接着增量 lockedCount，当第二个线程尝试lock，由于 isLocked=true，所以他不会获取该锁，直到第一个线程调用两次 unlock() 将 lockCount 递减为0，才将标记为 isLocked 设置为 false。</p></li><li><p>不可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotReentrantLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (isLocked) &#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isLocked = <span class="keyword">false</span>;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line">    NotReentrantLock lock = <span class="keyword">new</span> NotReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        doAdd();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        count.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前线程执行print()方法首先获取lock，接下来执行doAdd()方法就无法执行doAdd()中的逻辑，必须先释放锁。这个例子很好的说明了不可重入锁。</p></li></ul></li><li><p>synchronized 和 ReentrantLock 都是可重入锁</p><ul><li><p>synchronzied </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronziedDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        doAdd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"doAdd..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronziedDemo synchronziedDemo = <span class="keyword">new</span> SynchronziedDemo();</span><br><span class="line">        synchronziedDemo.print(); <span class="comment">// doAdd...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面可以说明 synchronized 是可重入锁。</p></li><li><p>ReentrantLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        doAdd();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        lock.lock();</span><br><span class="line">        System.out.println(<span class="string">"doAdd..."</span>);</span><br><span class="line">        lock.unlock();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReentrantLockDemo reentrantLockDemo = <span class="keyword">new</span> ReentrantLockDemo();</span><br><span class="line">        reentrantLockDemo.print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面例子可以说明 ReentrantLock 是可重入锁，而且在 #doAdd 方法中加两次锁和解两次锁也可以。</p></li></ul></li></ul><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><ul><li><p>是指定尝试获取锁的线程不会立即堵塞，而是<strong>采用循环的方式去尝试获取锁</strong>，这样的好处是减少线程上线文切换的消耗，缺点就是循环会消耗 CPU。</p></li><li><p>手动实现自旋锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpinLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicReference&lt;Thread&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lock</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">" coming..."</span>);</span><br><span class="line">        <span class="keyword">while</span> (!atomicReference.compareAndSet(<span class="keyword">null</span>, Thread.currentThread())) &#123;</span><br><span class="line">            <span class="comment">// loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        atomicReference.compareAndSet(thread, <span class="keyword">null</span>);</span><br><span class="line">        System.out.println(thread + <span class="string">" unlock..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SpinLock spinLock = <span class="keyword">new</span> SpinLock();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"hahaha"</span>);</span><br><span class="line">            spinLock.unlock();</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            spinLock.lock();</span><br><span class="line">            System.out.println(<span class="string">"hehehe"</span>);</span><br><span class="line">            spinLock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread[Thread-0,5,main] coming...</span><br><span class="line">Thread[Thread-1,5,main] coming...</span><br><span class="line">hahaha</span><br><span class="line">Thread[Thread-0,5,main] unlock...</span><br><span class="line">hehehe</span><br><span class="line">Thread[Thread-1,5,main] unlock...</span><br></pre></td></tr></table></figure><p>获取锁的时候，如果原子引用为空就获取锁，不为空表示有人获取了锁，就循环等待。</p></li></ul><h3 id="独占锁（写锁）-共享锁（读锁）"><a href="#独占锁（写锁）-共享锁（读锁）" class="headerlink" title="独占锁（写锁）/共享锁（读锁）"></a>独占锁（写锁）/共享锁（读锁）</h3><ul><li><p>是什么</p><ul><li><strong>独占锁：</strong>指该锁一次只能被一个线程持有</li><li><strong>共享锁：</strong>该锁可以被多个线程持有</li></ul></li><li><p>对于 ReentrantLock 和 synchronized 都是独占锁；对与 ReentrantReadWriteLock 其读锁是共享锁而写锁是独占锁。读锁的共享可保证并发读是非常高效的，读写、写读和写写的过程是互斥的。</p></li><li><p>读写锁例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">    WriteLock writeLock = lock.writeLock();</span><br><span class="line">    ReadLock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            writeLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在写入..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(key, value);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 写入完成，写入结果是 "</span> + value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            readLock.lock();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 正在读..."</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            Object res = map.get(key);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" 读取完成，读取结果是 "</span> + res);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyCache cache = <span class="keyword">new</span> MyCache();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                cache.put(temp + <span class="string">""</span>, temp + <span class="string">""</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> temp = i;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                cache.get(temp + <span class="string">""</span>);</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 正在写入...</span><br><span class="line">Thread-0 写入完成，写入结果是 0</span><br><span class="line">Thread-1 正在写入...</span><br><span class="line">Thread-1 写入完成，写入结果是 1</span><br><span class="line">Thread-2 正在写入...</span><br><span class="line">Thread-2 写入完成，写入结果是 2</span><br><span class="line">Thread-3 正在写入...</span><br><span class="line">Thread-3 写入完成，写入结果是 3</span><br><span class="line">Thread-4 正在写入...</span><br><span class="line">Thread-4 写入完成，写入结果是 4</span><br><span class="line">Thread-5 正在读...</span><br><span class="line">Thread-7 正在读...</span><br><span class="line">Thread-8 正在读...</span><br><span class="line">Thread-6 正在读...</span><br><span class="line">Thread-9 正在读...</span><br><span class="line">Thread-5 读取完成，读取结果是 0</span><br><span class="line">Thread-7 读取完成，读取结果是 2</span><br><span class="line">Thread-8 读取完成，读取结果是 3</span><br><span class="line">Thread-6 读取完成，读取结果是 1</span><br><span class="line">Thread-9 读取完成，读取结果是 4</span><br></pre></td></tr></table></figure><p>能保证<strong>读写</strong>、<strong>写读</strong>和<strong>写写</strong>的过程是互斥的时候是独享的，<strong>读读</strong>的时候是共享的。</p></li></ul><h2 id="CountDownLatch-CyclicBarrier-Semaphore-使用过吗？"><a href="#CountDownLatch-CyclicBarrier-Semaphore-使用过吗？" class="headerlink" title="CountDownLatch/CyclicBarrier/Semaphore 使用过吗？"></a>CountDownLatch/CyclicBarrier/Semaphore 使用过吗？</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒。CountDownLatch 主要有两个方法，当一个或多个线程调用 await 方法时，调用线程会被堵塞，其他线程调用 countDown 方法会将计数减一（调用 countDown 方法的线程不会堵塞），当计数其值变为零时，因调用 await 方法被堵塞的线程会被唤醒，继续执行。</p><p>假设我们有这么一个场景，教室里有班长和其他6个人在教室上自习，怎么保证班长等其他6个人都走出教室在把教室门给关掉。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLanchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 离开了教室..."</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"班长把门给关了，离开了教室..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 离开了教室...</span><br><span class="line">1 离开了教室...</span><br><span class="line">2 离开了教室...</span><br><span class="line">3 离开了教室...</span><br><span class="line">班长把门给关了，离开了教室...</span><br><span class="line">5 离开了教室...</span><br><span class="line">4 离开了教室...</span><br></pre></td></tr></table></figure><p>发现班长都没有等其他人理他教室就把门给关了，此时我们就可以使用 CountDownLatch 来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLanchDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">6</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 离开了教室..."</span>);</span><br><span class="line">            &#125;, String.valueOf(i)).start();</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"班长把门给关了，离开了教室..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0 离开了教室...</span><br><span class="line">1 离开了教室...</span><br><span class="line">2 离开了教室...</span><br><span class="line">3 离开了教室...</span><br><span class="line">4 离开了教室...</span><br><span class="line">5 离开了教室...</span><br><span class="line">班长把门给关了，离开了教室...</span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>我们假设有这么一个场景，每辆车只能坐个人，当车满了，就发车。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>, () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"车满了，开始出发..."</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 开始上车..."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    cyclicBarrier.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 开始上车...</span><br><span class="line">Thread-1 开始上车...</span><br><span class="line">Thread-3 开始上车...</span><br><span class="line">Thread-4 开始上车...</span><br><span class="line">车满了，开始出发...</span><br><span class="line">Thread-5 开始上车...</span><br><span class="line">Thread-7 开始上车...</span><br><span class="line">Thread-2 开始上车...</span><br><span class="line">Thread-6 开始上车...</span><br><span class="line">车满了，开始出发...</span><br></pre></td></tr></table></figure></p><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>假设我们有 3 个停车位，6 辆车去抢<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreDemo</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">3</span>);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">          <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  semaphore.acquire(); <span class="comment">// 获取一个许可</span></span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">" 抢到车位..."</span>);</span><br><span class="line">                  Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                  System.out.println(Thread.currentThread().getName() + <span class="string">" 离开车位"</span>);</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  semaphore.release(); <span class="comment">// 释放一个许可</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125;).start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-1 抢到车位...</span><br><span class="line">Thread-2 抢到车位...</span><br><span class="line">Thread-0 抢到车位...</span><br><span class="line">Thread-2 离开车位</span><br><span class="line">Thread-0 离开车位</span><br><span class="line">Thread-3 抢到车位...</span><br><span class="line">Thread-1 离开车位</span><br><span class="line">Thread-4 抢到车位...</span><br><span class="line">Thread-5 抢到车位...</span><br><span class="line">Thread-3 离开车位</span><br><span class="line">Thread-5 离开车位</span><br><span class="line">Thread-4 离开车位</span><br></pre></td></tr></table></figure></p><h2 id="堵塞队列你知道吗？"><a href="#堵塞队列你知道吗？" class="headerlink" title="堵塞队列你知道吗？"></a>堵塞队列你知道吗？</h2><h3 id="阻塞队列有哪些"><a href="#阻塞队列有哪些" class="headerlink" title="阻塞队列有哪些"></a>阻塞队列有哪些</h3><ul><li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）对元素进行排序。</li><li>LinkedBlokcingQueue：是一个基于链表结构的阻塞队列，此队列按 FIFO（先进先出）对元素进行排序，吞吐量通常要高于 ArrayBlockingQueue。</li><li>SynchronousQueue：是一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于 LinkedBlokcingQueue。</li></ul><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p><img src="Java并发编程/1234sdafsdf.png" alt="img"></p><ul><li>阻塞队列，顾名思义，首先它是一个队列，而一个阻塞队列在数据结构中所起的作用大致如图所示：</li><li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞。</li><li><p>当阻塞队列是满时，往队列里添加元素的操作将会被阻塞。</p></li><li><p>核心方法</p><p>| 方法\行为 |  抛异常   |     特定的值      |  阻塞  |            超时             |<br>| :——-: | :——-: | :—————: | :—-: | :————————-: |<br>| 插入方法  |  add(o)   |     offer(o)      | put(o) | offer(o, timeout, timeunit) |<br>| 移除方法  |           | poll()、remove(o) | take() |   poll(timeout, timeunit)   |<br>| 检查方法  | element() |      peek()       |        |                             |</p></li><li><p>行为解释：</p><ul><li><p>抛异常：如果操作不能马上进行，则抛出异常</p></li><li><p>特定的值：如果操作不能马上进行，将会返回一个特殊的值，一般是 true 或者 false</p></li><li><p>阻塞：如果操作不能马上进行，操作会被阻塞</p></li><li><p>超时：如果操作不能马上进行，操作会被阻塞指定的时间，如果指定时间没执行，则返回一个特殊值，一般是 true 或者 false</p></li></ul></li><li><p>插入方法：</p><ul><li>add(E e)：添加成功返回true，失败抛 IllegalStateException 异常</li><li>offer(E e)：成功返回 true，如果此队列已满，则返回 false</li><li>put(E e)：将元素插入此队列的尾部，如果该队列已满，则一直阻塞</li></ul></li><li><p>删除方法：</p><ul><li>remove(Object o) ：移除指定元素,成功返回true，失败返回false</li><li>poll()：获取并移除此队列的头元素，若队列为空，则返回 null</li><li>take()：获取并移除此队列头元素，若没有元素则一直阻塞</li></ul></li><li><p>检查方法：</p><ul><li>element() ：获取但不移除此队列的头元素，没有元素则抛异常</li><li>peek() :获取但不移除此队列的头；若队列为空，则返回 null</li></ul></li></ul><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue，实际上它不是一个真正的队列，因为它不会为队列中元素维护存储空间。与其他队列不同的是，它维护一组线程，这些线程在等待着把元素加入或移出队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronousQueueDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SynchronousQueue&lt;Integer&gt; synchronousQueue = <span class="keyword">new</span> SynchronousQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                synchronousQueue.put(<span class="number">1</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                synchronousQueue.put(<span class="number">2</span>);</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                synchronousQueue.put(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Integer val = synchronousQueue.take();</span><br><span class="line">                System.out.println(val);</span><br><span class="line">                Integer val2 = synchronousQueue.take();</span><br><span class="line">                System.out.println(val2);</span><br><span class="line">                Integer val3 = synchronousQueue.take();</span><br><span class="line">                System.out.println(val3);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>生产者消费者模式</li><li>线程池</li><li>消息中间件</li></ul><h2 id="synchronized-和-Lock-有什么区别？"><a href="#synchronized-和-Lock-有什么区别？" class="headerlink" title="synchronized 和 Lock 有什么区别？"></a>synchronized 和 Lock 有什么区别？</h2><ul><li>原始结构<ul><li>synchronized 是关键字属于 JVM 层面，反应在字节码上是 monitorenter 和 monitorexit，其底层是通过 monitor 对象来完成，其实 wait/notify 等方法也是依赖 monitor 对象只有在同步快或方法中才能调用 wait/notify 等方法。</li><li>Lock 是具体类（java.util.concurrent.locks.Lock）是 api 层面的锁。</li></ul></li><li>使用方法<ul><li>synchronized 不需要用户手动去释放锁，当 synchronized 代码执行完后系统会自动让线程释放对锁的占用。</li><li>ReentrantLock 则需要用户手动的释放锁，若没有主动释放锁，可能导致出现死锁的现象，lock() 和 unlock() 方法需要配合 try/finally 语句来完成。</li></ul></li><li>等待是否可中断<ul><li>synchronized 不可中断，除非抛出异常或者正常运行完成。</li><li>ReentrantLock 可中断，设置超时方法 tryLock(long timeout, TimeUnit unit)，lockInterruptibly() 放代码块中，调用 interrupt() 方法可中断。</li></ul></li><li>加锁是否公平<ul><li>synchronized 非公平锁</li><li>ReentrantLock 默认非公平锁，构造方法中可以传入 boolean 值，true 为公平锁，false 为非公平锁。</li></ul></li><li>锁可以绑定多个 Condition<ul><li>synchronized 没有 Condition。</li><li>ReentrantLock 用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像 synchronized 要么随机唤醒一个线程要么唤醒全部线程。</li></ul></li></ul><h2 id="线程池使用过吗？谈谈对-ThreadPoolExector-的理解？"><a href="#线程池使用过吗？谈谈对-ThreadPoolExector-的理解？" class="headerlink" title="线程池使用过吗？谈谈对 ThreadPoolExector 的理解？"></a>线程池使用过吗？谈谈对 ThreadPoolExector 的理解？</h2><h3 id="为什使用线程池，线程池的优势？"><a href="#为什使用线程池，线程池的优势？" class="headerlink" title="为什使用线程池，线程池的优势？"></a>为什使用线程池，线程池的优势？</h3><p>线程池用于多线程处理中，它可以根据系统的情况，可以有效控制线程执行的数量，优化运行效果。线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，那么超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。</p><p>主要特点为：</p><ul><li>线程复用</li><li>控制最大并发数量</li><li>管理线程</li></ul><p>主要优点</p><ul><li>降低资源消耗，通过重复利用已创建的线程来降低线程创建和销毁造成的消耗。</li><li>提高相应速度，当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅仅会消耗系统资源，还会降低体统的稳定性，使用线程可以进行统一分配，调优和监控。</li></ul><h3 id="创建线程的几种方式"><a href="#创建线程的几种方式" class="headerlink" title="创建线程的几种方式"></a>创建线程的几种方式</h3><ul><li><p>继承 Thread</p></li><li><p>实现 Runnable 接口</p></li><li><p>实现 Callable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 在 FutureTask 中传入 Callable 的实现类</span></span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 把 futureTask 放入线程中</span></span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="comment">// 获取结果</span></span><br><span class="line">        Integer res = futureTask.get();</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="线程池如果使用？"><a href="#线程池如果使用？" class="headerlink" title="线程池如果使用？"></a>线程池如果使用？</h3><h4 id="架构说明"><a href="#架构说明" class="headerlink" title="架构说明"></a>架构说明</h4><p><img src="Java并发编程/u=947447203,3545120712&amp;fm=26&amp;gp=0.jpg" alt="img"></p><h4 id="编码实现"><a href="#编码实现" class="headerlink" title="编码实现"></a>编码实现</h4><ul><li>Executors.newSingleThreadExecutor()：只有一个线程的线程池，因此所有提交的任务是顺序执行</li><li>Executors.newCachedThreadPool()：线程池里有很多线程需要同时执行，老的可用线程将被新的任务触发重新执行，如果线程超过60秒内没执行，那么将被终止并从池中删除</li><li>Executors.newFixedThreadPool()：拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待</li><li>Executors.newScheduledThreadPool()：用来调度即将执行的任务的线程池</li><li>Executors.newWorkStealingPool()： newWorkStealingPool适合使用在很耗时的操作，但是newWorkStealingPool不是ThreadPoolExecutor的扩展，它是新的线程池类ForkJoinPool的扩展，但是都是在统一的一个Executors类中实现，由于能够合理的使用CPU进行对任务操作（并行操作），所以适合使用在很耗时的任务中</li></ul><h4 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h4><p>ThreadPoolExecutor作为java.util.concurrent包对外提供基础实现，以内部线程池的形式对外提供管理任务执行，线程调度，线程池管理等等服务。</p><h3 id="线程池的几个重要参数介绍？"><a href="#线程池的几个重要参数介绍？" class="headerlink" title="线程池的几个重要参数介绍？"></a>线程池的几个重要参数介绍？</h3><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">作用</th></tr></thead><tbody><tr><td style="text-align:left">corePoolSize</td><td style="text-align:left">核心线程池大小</td></tr><tr><td style="text-align:left">maximumPoolSize</td><td style="text-align:left">最大线程池大小</td></tr><tr><td style="text-align:left">keepAliveTime</td><td style="text-align:left">线程池中超过 corePoolSize 数目的空闲线程最大存活时间；可以allowCoreThreadTimeOut(true) 使得核心线程有效时间</td></tr><tr><td style="text-align:left">TimeUnit</td><td style="text-align:left">keepAliveTime 时间单位</td></tr><tr><td style="text-align:left">workQueue</td><td style="text-align:left">阻塞任务队列</td></tr><tr><td style="text-align:left">threadFactory</td><td style="text-align:left">新建线程工厂</td></tr><tr><td style="text-align:left">RejectedExecutionHandler</td><td style="text-align:left">当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理</td></tr></tbody></table><p>说说线程池的底层工作原理？</p><p><strong>重点讲解：</strong> 其中比较容易让人误解的是：corePoolSize，maximumPoolSize，workQueue之间关系。</p><ol><li><p>当线程池小于corePoolSize时，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</p></li><li><p>当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。 </p></li><li><p>当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。 </p></li><li><p>当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。 </p></li><li><p>当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。</p></li><li><p>当设置allowCoreThreadTimeOut(true) 时，线程池中 corePoolSize 线程空闲时间达到 keepAliveTime 也将关闭。</p></li></ol><p><img src="Java并发编程/92ad4409-2ab4-388b-9fb1-9fc4e0d832cd.jpg" alt="img"></p><h2 id="线程池用过吗？生产上你如何设置合理参数？"><a href="#线程池用过吗？生产上你如何设置合理参数？" class="headerlink" title="线程池用过吗？生产上你如何设置合理参数？"></a>线程池用过吗？生产上你如何设置合理参数？</h2><h3 id="线程池的拒绝策略你谈谈？"><a href="#线程池的拒绝策略你谈谈？" class="headerlink" title="线程池的拒绝策略你谈谈？"></a>线程池的拒绝策略你谈谈？</h3><ul><li>是什么<ul><li>等待队列已经满了，再也塞不下新的任务，同时线程池中的线程数达到了最大线程数，无法继续为新任务服务。</li></ul></li><li>拒绝策略<ul><li>AbortPolicy：处理程序遭到拒绝将抛出运行时 RejectedExecutionException </li><li>CallerRunsPolicy：线程调用运行该任务的 execute 本身。此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li><li>DiscardPolicy：不能执行的任务将被删除 </li><li>DiscardOldestPolicy：如果执行程序尚未关闭，则位于工作队列头部的任务将被删除，然后重试执行程序（如果再次失败，则重复此过程）</li></ul></li></ul><h3 id="你在工作中单一的、固定数的和可变的三种创建线程池的方法，你用哪个多，超级大坑？"><a href="#你在工作中单一的、固定数的和可变的三种创建线程池的方法，你用哪个多，超级大坑？" class="headerlink" title="你在工作中单一的、固定数的和可变的三种创建线程池的方法，你用哪个多，超级大坑？"></a>你在工作中单一的、固定数的和可变的三种创建线程池的方法，你用哪个多，超级大坑？</h3><p>如果读者对Java中的阻塞队列有所了解的话，看到这里或许就能够明白原因了。</p><p>Java中的BlockingQueue主要有两种实现，分别是ArrayBlockingQueue 和 LinkedBlockingQueue。</p><p>ArrayBlockingQueue是一个用数组实现的有界阻塞队列，必须设置容量。</p><p>LinkedBlockingQueue是一个用链表实现的有界阻塞队列，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。</p><p>这里的问题就出在：不设置的话，将是一个无边界的阻塞队列，最大长度为Integer.MAX_VALUE。也就是说，如果我们不设置LinkedBlockingQueue的容量的话，其默认容量将会是Integer.MAX_VALUE。</p><p>而newFixedThreadPool中创建LinkedBlockingQueue时，并未指定容量。此时，LinkedBlockingQueue就是一个无边界队列，对于一个无边界队列来说，是可以不断的向队列中加入任务的，这种情况下就有可能因为任务过多而导致内存溢出问题。</p><p>上面提到的问题主要体现在newFixedThreadPool和newSingleThreadExecutor两个工厂方法上，并不是说newCachedThreadPool和newScheduledThreadPool这两个方法就安全了，这两种方式创建的最大线程数可能是Integer.MAX_VALUE，而创建这么多线程，必然就有可能导致OOM。</p><h3 id="你在工作中是如何使用线程池的，是否自定义过线程池使用？"><a href="#你在工作中是如何使用线程池的，是否自定义过线程池使用？" class="headerlink" title="你在工作中是如何使用线程池的，是否自定义过线程池使用？"></a>你在工作中是如何使用线程池的，是否自定义过线程池使用？</h3><p>自定义线程池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Executor executor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1L</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">5</span>), </span><br><span class="line">                Executors.defaultThreadFactory(), </span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.DiscardPolicy());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合理配置线程池你是如果考虑的？"><a href="#合理配置线程池你是如果考虑的？" class="headerlink" title="合理配置线程池你是如果考虑的？"></a>合理配置线程池你是如果考虑的？</h3><ul><li>CPU 密集型<ul><li>CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</li><li>CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。</li></ul></li><li>IO 密集型<ul><li>由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2 。</li><li>也可以使用公式：CPU 核数 / (1 - 阻塞系数)；其中阻塞系数在 0.8 ～ 0.9 之间。</li></ul></li></ul><h2 id="死锁编码以及定位分析"><a href="#死锁编码以及定位分析" class="headerlink" title="死锁编码以及定位分析"></a>死锁编码以及定位分析</h2><ul><li><p>产生死锁的原因</p><ul><li>死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种相互等待的现象，如果无外力的干涉那它们都将无法推进下去，如果系统的资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。</li></ul></li><li><p>代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String lockA = <span class="string">"lockA"</span>;</span><br><span class="line">        String lockB = <span class="string">"lockB"</span>;</span><br><span class="line"></span><br><span class="line">        DeadLockDemo deadLockDemo = <span class="keyword">new</span> DeadLockDemo();</span><br><span class="line">        Executor executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executor.execute(() -&gt; deadLockDemo.method(lockA, lockB));</span><br><span class="line">        executor.execute(() -&gt; deadLockDemo.method(lockB, lockA));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String lock1, String lock2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"--获取到："</span> + lock1 + <span class="string">"; 尝试获取："</span> + lock2);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                System.out.println(<span class="string">"获取到两把锁!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>解决</p><ul><li><p>jps -l 命令查定位进程号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">28519 org.jetbrains.jps.cmdline.Launcher</span><br><span class="line">32376 com.intellij.idea.Main</span><br><span class="line">28521 com.cuzz.thread.DeadLockDemo</span><br><span class="line">27836 org.jetbrains.kotlin.daemon.KotlinCompileDaemon</span><br><span class="line">28591 sun.tools.jps.Jps</span><br></pre></td></tr></table></figure></li><li><p>jstack 28521 找到死锁查看</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">2019-05-07 00:04:15</span><br><span class="line">Full thread dump Java HotSpot(TM) 64-Bit Server VM (25.191-b12 mixed mode):</span><br><span class="line"></span><br><span class="line">&quot;Attach Listener&quot; #13 daemon prio=9 os_prio=0 tid=0x00007f7acc001000 nid=0x702a waiting on condition [0x0000000000000000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">// ...</span><br><span class="line">Found one Java-level deadlock:</span><br><span class="line">=============================</span><br><span class="line">&quot;pool-1-thread-2&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f7ad4006478 (object 0x00000000d71f60b0, a java.lang.String),</span><br><span class="line">  which is held by &quot;pool-1-thread-1&quot;</span><br><span class="line">&quot;pool-1-thread-1&quot;:</span><br><span class="line">  waiting to lock monitor 0x00007f7ad4003be8 (object 0x00000000d71f60e8, a java.lang.String),</span><br><span class="line">  which is held by &quot;pool-1-thread-2&quot;</span><br><span class="line"></span><br><span class="line">Java stack information for the threads listed above:</span><br><span class="line">===================================================</span><br><span class="line">&quot;pool-1-thread-2&quot;:</span><br><span class="line">        at com.cuzz.thread.DeadLockDemo.method(DeadLockDemo.java:34)</span><br><span class="line">        - waiting to lock &lt;0x00000000d71f60b0&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x00000000d71f60e8&gt; (a java.lang.String)</span><br><span class="line">        at com.cuzz.thread.DeadLockDemo.lambda$main$1(DeadLockDemo.java:21)</span><br><span class="line">        at com.cuzz.thread.DeadLockDemo$$Lambda$2/2074407503.run(Unknown Source)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">&quot;pool-1-thread-1&quot;:</span><br><span class="line">        at com.cuzz.thread.DeadLockDemo.method(DeadLockDemo.java:34)</span><br><span class="line">        - waiting to lock &lt;0x00000000d71f60e8&gt; (a java.lang.String)</span><br><span class="line">        - locked &lt;0x00000000d71f60b0&gt; (a java.lang.String)</span><br><span class="line">        at com.cuzz.thread.DeadLockDemo.lambda$main$0(DeadLockDemo.java:20)</span><br><span class="line">        at com.cuzz.thread.DeadLockDemo$$Lambda$1/558638686.run(Unknown Source)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)</span><br><span class="line">        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)</span><br><span class="line">        at java.lang.Thread.run(Thread.java:748)</span><br><span class="line"></span><br><span class="line">Found 1 deadlock.</span><br></pre></td></tr></table></figure><p>最后发现一个死锁。</p></li></ul></li></ul><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p><a href="http://blog.cuzz.site/2019/05/10/JVM面试/">JVM 面试</a></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://www.sohu.com/a/152785317_99908665" target="_blank" rel="noopener">Java内存模型-volatile </a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;请谈谈你对-volatile-的理解&quot;&gt;&lt;a href=&quot;#请谈谈你对-volatile-的理解&quot; class=&quot;headerlink&quot; title=&quot;请谈谈你对 volatile 的理解&quot;&gt;&lt;/a&gt;请谈谈你对 volatile 的理解&lt;/h2&gt;&lt;h3 id=&quot;volatile-是-Java-虚拟机提供的轻量级的同步机制&quot;&gt;&lt;a href=&quot;#volatile-是-Java-虚拟机提供的轻量级的同步机制&quot; class=&quot;headerlink&quot; title=&quot;volatile 是 Java 虚拟机提供的轻量级的同步机制&quot;&gt;&lt;/a&gt;volatile 是 Java 虚拟机提供的轻量级的同步机制&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;保证可见性&lt;/li&gt;
&lt;li&gt;禁止指令排序&lt;/li&gt;
&lt;li&gt;不保证原子性&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="面试" scheme="http://blog.cuzz.site/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="并发编程" scheme="http://blog.cuzz.site/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者</title>
    <link href="http://blog.cuzz.site/2019/04/06/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85/"/>
    <id>http://blog.cuzz.site/2019/04/06/生产者消费者/</id>
    <published>2019-04-06T14:56:12.000Z</published>
    <updated>2019-05-01T07:09:07.468Z</updated>
    
    <content type="html"><![CDATA[<p>维基百科解释：</p><blockquote><p>In <a href="https://en.wikipedia.org/wiki/Computing" target="_blank" rel="noopener">computing</a>, the <strong>producer–consumer problem</strong><a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem#cite_note-ostep1-1" target="_blank" rel="noopener">[1]</a><a href="https://en.wikipedia.org/wiki/Producer%E2%80%93consumer_problem#cite_note-ostep2-2" target="_blank" rel="noopener">[2]</a> (also known as the <strong>bounded-buffer problem</strong>) is a classic example of a multi-<a href="https://en.wikipedia.org/wiki/Process_(computing" target="_blank" rel="noopener">process</a>) <a href="https://en.wikipedia.org/wiki/Synchronization_(computer_science" target="_blank" rel="noopener">synchronization</a>) problem. The problem describes two processes, the producer and the consumer, who share a common, fixed-size <a href="https://en.wikipedia.org/wiki/Buffer_(computer_science" target="_blank" rel="noopener">buffer</a>) used as a <a href="https://en.wikipedia.org/wiki/Queue_(data_structure" target="_blank" rel="noopener">queue</a>). The producer’s job is to generate data, put it into the buffer, and start again. At the same time, the consumer is consuming the data (i.e., removing it from the buffer), one piece at a time. The problem is to make sure that the producer won’t try to add data into the buffer if it’s full and that the consumer won’t try to remove data from an empty buffer. </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/4/6 13:03</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 生产者消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Container container = <span class="keyword">new</span> Container();</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executor.execute(() -&gt; container.produce());</span><br><span class="line">        executor.execute(() -&gt; container.consume());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_SIZE = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (list.size() &gt;= MAX_SIZE) &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> i = random.nextInt();</span><br><span class="line">                    System.out.println(<span class="string">"produce..."</span> + i);</span><br><span class="line">                    list.add(i);</span><br><span class="line">                    notify();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (list.isEmpty()) &#123;</span><br><span class="line">                        wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">int</span> i = list.remove(<span class="number">0</span>);</span><br><span class="line">                    System.out.println(<span class="string">"consume..."</span> + i);</span><br><span class="line">                    notify();</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;维基百科解释：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In &lt;a href=&quot;https://en.wikipedia.org/wiki/Computing&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;computing&lt;/a&gt;, the &lt;stron
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.cuzz.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="ProducerConsumer" scheme="http://blog.cuzz.site/tags/ProducerConsumer/"/>
    
  </entry>
  
  <entry>
    <title>LRUCache</title>
    <link href="http://blog.cuzz.site/2019/03/16/LRUCache/"/>
    <id>http://blog.cuzz.site/2019/03/16/LRUCache/</id>
    <published>2019-03-16T14:56:12.000Z</published>
    <updated>2019-04-24T12:09:05.759Z</updated>
    
    <content type="html"><![CDATA[<p>LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高” 。</p><p><img src="LRUCache/搜狗截图20190316173426.png" alt="搜狗截图20190316173426"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/3/16 15:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: LRU cache</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, DLinkedList&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> DLinkedList head, tail;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DLinkedList();</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DLinkedList();</span><br><span class="line"></span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        DLinkedList node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        DLinkedList node = cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            node = <span class="keyword">new</span> DLinkedList(key, value);</span><br><span class="line">            addHead(node);</span><br><span class="line">            cache.put(key, node);</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; capacity) &#123;</span><br><span class="line">                DLinkedList preTail = tail.pre;</span><br><span class="line">                removeNode(preTail);</span><br><span class="line">                cache.remove(preTail.key);</span><br><span class="line">                count--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.value = value;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            addHead(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除给定的结点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeNode</span><span class="params">(DLinkedList node)</span> </span>&#123;</span><br><span class="line">        DLinkedList pre = node.pre;</span><br><span class="line">        DLinkedList next = node.next;</span><br><span class="line">        pre.next = next;</span><br><span class="line">        next.pre = pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把结点添加头节点</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addHead</span><span class="params">(DLinkedList node)</span> </span>&#123;</span><br><span class="line">        DLinkedList next = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.next = next;</span><br><span class="line">        next.pre = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);                    </span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>));   <span class="comment">// 返回 1</span></span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);                    <span class="comment">// 使 2 作废</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">2</span>));   <span class="comment">// 返回 -1</span></span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);                    <span class="comment">// 使 1 作废</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>));   <span class="comment">// 返回 -1 未找到</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>));   <span class="comment">// 返回 3</span></span><br><span class="line">        System.out.println(cache.get(<span class="number">4</span>));   <span class="comment">// 返回 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLinkedList</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> key;</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    DLinkedList pre;</span><br><span class="line">    DLinkedList next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DLinkedList</span><span class="params">()</span> </span>&#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DLinkedList</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高” 。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;LRUCache/搜狗截图20190316173426.png&quot; 
      
    
    </summary>
    
      <category term="算法" scheme="http://blog.cuzz.site/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="LRUCache" scheme="http://blog.cuzz.site/tags/LRUCache/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机（四）</title>
    <link href="http://blog.cuzz.site/2019/03/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://blog.cuzz.site/2019/03/04/深入理解Java虚拟机（四）/</id>
    <published>2019-03-04T15:59:59.000Z</published>
    <updated>2019-10-19T16:46:20.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="synchronized-字节码分析"><a href="#synchronized-字节码分析" class="headerlink" title="synchronized 字节码分析"></a>synchronized 字节码分析</h2><p>我们先来看一下一个简单的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/3/4 13:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>javap -v com.cuzz.jvm.bytecode.MyTest02</code> 命令，找到 <code>setX</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public void setX(int);</span><br><span class="line">  descriptor: (I)V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=2, args_size=2</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: iload_1</span><br><span class="line">       2: putfield      #2                  // Field x:I</span><br><span class="line">       5: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 12: 0</span><br><span class="line">      line 13: 5</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       6     0  this   Lcom/cuzz/jvm/bytecode/MyTest02;</span><br><span class="line">          0       6     1     x   I</span><br></pre></td></tr></table></figure><a id="more"></a><p>如果我们在方法中添加 <code>synchronzied</code> 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再反编译一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public synchronized void setX(int);</span><br><span class="line">  descriptor: (I)V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=2, args_size=2</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: iload_1</span><br><span class="line">       2: putfield      #2                  // Field x:I</span><br><span class="line">       5: return</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 12: 0</span><br><span class="line">      line 13: 5</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0       6     0  this   Lcom/cuzz/jvm/bytecode/MyTest02;</span><br><span class="line">          0       6     1     x   I</span><br></pre></td></tr></table></figure><p>对比这两个反编译的结果，我们发现在 flags 中多了 <code>ACC_SYNCHRONIZED</code>，不会出现 monitorenter 和 monitorexit。</p><p>如果我们是在方法体重添加 <code>synchronized</code> 关键字</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest02</span> </span>&#123;</span><br><span class="line">    String lock = <span class="string">"lock"</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们反编译一下 找到 <code>getX</code> 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public int getX();</span><br><span class="line">  descriptor: ()I</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">    stack=2, locals=3, args_size=1</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #3                  // Field lock:Ljava/lang/String;</span><br><span class="line">       4: dup</span><br><span class="line">       5: astore_1</span><br><span class="line">       6: monitorenter</span><br><span class="line">       7: aload_0</span><br><span class="line">       8: getfield      #4                  // Field x:I</span><br><span class="line">      11: aload_1</span><br><span class="line">      12: monitorexit</span><br><span class="line">      13: ireturn</span><br><span class="line">      14: astore_2</span><br><span class="line">      15: aload_1</span><br><span class="line">      16: monitorexit</span><br><span class="line">      17: aload_2</span><br><span class="line">      18: athrow</span><br><span class="line">    Exception table:</span><br><span class="line">       from    to  target type</span><br><span class="line">           7    13    14   any</span><br><span class="line">          14    17    14   any</span><br><span class="line">    LineNumberTable:</span><br><span class="line">      line 17: 0</span><br><span class="line">      line 18: 7</span><br><span class="line">      line 19: 14</span><br><span class="line">    LocalVariableTable:</span><br><span class="line">      Start  Length  Slot  Name   Signature</span><br><span class="line">          0      19     0  this   Lcom/cuzz/jvm/bytecode/MyTest02;</span><br><span class="line">    StackMapTable: number_of_entries = 1</span><br><span class="line">      frame_type = 255 /* full_frame */</span><br><span class="line">        offset_delta = 14</span><br><span class="line">        locals = [ class com/cuzz/jvm/bytecode/MyTest02, class java/lang/Object ]</span><br><span class="line">        stack = [ class java/lang/Throwable ]</span><br></pre></td></tr></table></figure><p>在 6 中出现 monitorenter，在 16 中出现 moniterexit</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;synchronized-字节码分析&quot;&gt;&lt;a href=&quot;#synchronized-字节码分析&quot; class=&quot;headerlink&quot; title=&quot;synchronized 字节码分析&quot;&gt;&lt;/a&gt;synchronized 字节码分析&lt;/h2&gt;&lt;p&gt;我们先来看一下一个简单的方法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@Author&lt;/span&gt;: cuzz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@Date&lt;/span&gt;: 2019/3/4 13:34&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * &lt;span class=&quot;doctag&quot;&gt;@Description&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyTest02&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;setX&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.x = x;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;使用 &lt;code&gt;javap -v com.cuzz.jvm.bytecode.MyTest02&lt;/code&gt; 命令，找到 &lt;code&gt;setX&lt;/code&gt; 方法&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;public void setX(int);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  descriptor: (I)V&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  flags: ACC_PUBLIC&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Code:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    stack=2, locals=2, args_size=2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       0: aload_0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       1: iload_1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       2: putfield      #2                  // Field x:I&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       5: return&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LineNumberTable:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      line 12: 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      line 13: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    LocalVariableTable:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      Start  Length  Slot  Name   Signature&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          0       6     0  this   Lcom/cuzz/jvm/bytecode/MyTest02;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          0       6     1     x   I&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://blog.cuzz.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://blog.cuzz.site/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Redis</title>
    <link href="http://blog.cuzz.site/2019/02/23/Redis/"/>
    <id>http://blog.cuzz.site/2019/02/23/Redis/</id>
    <published>2019-02-23T15:59:59.000Z</published>
    <updated>2019-10-19T16:46:20.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是-Redis-？"><a href="#什么是-Redis-？" class="headerlink" title="什么是 Redis ？"></a>什么是 Redis ？</h2><p>Redis，全称 Remote Dictionary Server，是一个基于内存的高性能 Key-Value 数据库。</p><p>另外，Redis 已经成为互联网公司在缓存组件选择的唯一，更多的关注点是，如何使用好 Redis 。</p><a id="more"></a><h3 id="Redis-有什么优点？"><a href="#Redis-有什么优点？" class="headerlink" title="Redis 有什么优点？"></a>Redis 有什么优点？</h3><p><strong>1、速度快</strong></p><p>因为数据存在内存中，类似于 HashMap ，HashMap 的优势就是查找和操作的时间复杂度都是O (1) 。</p><blockquote><p>Redis 本质上是一个 Key-Value 类型的内存数据库，很像Memcached ，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据 flush 到硬盘上进行保存。</p><p>因为是纯内存操作，Redis 的性能非常出色，每秒可以处理超过 10 万次读写操作，是已知性能最快的 Key-Value 数据库。</p></blockquote><ul><li>如果我们查看在<a href="https://help.aliyun.com/document_detail/26350.html" target="_blank" rel="noopener">阿里云销售的 Redis 规格</a>，最低的也是 8W QPS 。</li></ul><p><strong>2、支持丰富数据类型</strong></p><p>支持 String ，List，Set，Sorted Set，Hash 。</p><blockquote><p>Redis 的出色之处不仅仅是性能，Redis 最大的魅力是支持保存多种数据结构，此外单个 Value 的最大限制是1GB，不像 Memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。比方说：</p><ul><li>用他的 List 来做 FIFO 双向链表，实现一个轻量级的高性能消息队列服务。</li><li>用他的 Set 可以做高性能的 tag 系统等等。</li></ul></blockquote><p><strong>3、丰富的特性</strong></p><ul><li>订阅发布 Pub / Sub 功能</li><li>Key 过期策略</li><li>事务</li><li>支持多个 DB</li><li>计数</li><li>…</li></ul><p>并且在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p><p><strong>4、持久化存储</strong></p><p>Redis 提供 RDB 和 AOF 两种数据的持久化存储方案，解决内存数据库最担心的万一 Redis 挂掉，数据会消失掉。</p><h3 id="Redis-有什么缺点？"><a href="#Redis-有什么缺点？" class="headerlink" title="Redis 有什么缺点？"></a>Redis 有什么缺点？</h3><ul><li><p>由于 Redis 是内存数据库，所以，单台机器，存储的数据量，跟机器本身的内存大小。虽然 Redis 本身有 Key 过期策略，但是还是需要提前预估和节约内存。如果内存增长过快，需要定期删除数据。</p><blockquote><p>另外，可使用 Redis Cluster、Codis 等方案，对 Redis 进行分区，从单机 Redis 变成集群 Redis 。</p></blockquote></li><li><p>如果进行完整重同步，由于需要生成 RDB 文件，并进行传输，会占用主机的 CPU ，并会消耗现网的带宽。不过 Redis2.8 版本，已经有部分重同步的功能，但是还是有可能有完整重同步的。比如，新上线的备机。</p></li><li><p>修改配置文件，进行重启，将硬盘中的数据加载进内存，时间比较久。在这个过程中，Redis 不能提供服务。</p></li></ul><h2 id="Redis-和-Memcached-的区别有哪些？"><a href="#Redis-和-Memcached-的区别有哪些？" class="headerlink" title="Redis 和 Memcached 的区别有哪些？"></a>Redis 和 Memcached 的区别有哪些？</h2><p><strong>1、Redis 支持复杂的数据结构</strong></p><ul><li>Memcached 仅提供简单的字符串。</li><li>Redis 提供复杂的数据结构，丰富的数据操作。</li></ul><p>也因为 Redis 支持复杂的数据结构，Redis 即使往于 Memcached 推出，却获得更多开发者的青睐。</p><p>Redis 相比 Memcached 来说，拥有更多的数据结构，能支持更丰富的数据操作。如果需要缓存能够支持更复杂的结构和操作，Redis 会是不错的选择。</p><p><strong>2、Redis 原生支持集群模式</strong></p><ul><li>在 Redis3.x 版本中，官方便能支持 Cluster 模式。</li><li>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据。</li></ul><p><strong>3、性能对比</strong></p><ul><li>Redis 只使用单核，而 Memcached 可以使用多核，所以平均每一个核上 Redis在存储小数据时比 Memcached 性能更高。</li><li>在 100k 以上的数据中，Memcached 性能要高于 Redis 。虽然 Redis 最近也在存储大数据的性能上进行优化，但是比起 Memcached，还是稍有逊色。</li></ul><p>更多关于性能的对比，可以看看 <a href="https://www.jianshu.com/p/34f90813d7c9" target="_blank" rel="noopener">《Memcached 与 Redis 的关键性能指标比较》</a> 。</p><p><strong>4、内存使用效率对比</strong></p><ul><li>简单的 Key-Value 存储的话，Memcached 的内存利用率更高，可以使用类似内存池。</li><li><p>如果 Redis 采用 hash 结构来做 key-value 存储，由于其组合式的压缩， 其内存利用率会高于 Memcached 。</p></li><li><p>Redis 和 Memcached 的内存管理方法不同，Redis 采用的是包装的 malloc/free ， 相较于 Memcached 的内存管理方法 tcmalloc / jmalloc 来说，要简单很多 。</p></li></ul><p><strong>5、网络 IO 模型</strong></p><ul><li>Memcached 是多线程，非阻塞 IO 复用的网络模型，原型上接近 Nignx 。</li><li>Redis 使用单线程的 IO 复用模型，自己封装了一个简单的 AeEvent 事件处理框架，主要实现了 epoll, kqueue 和 select ，更接近 Apache 早期的模式。</li></ul><p>TODO 有点看不懂，找亚普表弟确认中。</p><p><strong>6、持久化存储</strong></p><ul><li>Memcached 不支持持久化存储，重启时，数据被清空。</li><li>Redis 支持持久化存储，重启时，可以恢复已持久化的数据。</li></ul><p>也推荐阅读下 <a href="https://www.imooc.com/article/23549" target="_blank" rel="noopener">《脚踏两只船的困惑 - Memcached 与 Redis》</a> 。</p><h2 id="请说说-Redis-的线程模型？"><a href="#请说说-Redis-的线程模型？" class="headerlink" title="请说说 Redis 的线程模型？"></a>请说说 Redis 的线程模型？</h2><blockquote><p>艿艿：这个是我从网络上找的资料，讲的灰常不错。</p></blockquote><p>redis 内部使用文件事件处理器 <code>file event handler</code>，这个文件事件处理器是单线程的，所以 redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。</p><p>文件事件处理器的结构包含 4 个部分：</p><ul><li>多个 socket</li><li>IO 多路复用程序</li><li>文件事件分派器</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。</p><p>来看客户端与 redis 的一次通信过程：</p><p><img src="Redis\01.png" alt="redis-single-thread-model"></p><ul><li>客户端 socket01 向 redis 的 server socket 请求建立连接，此时 server socket 会产生一个 <code>AE_READABLE</code> 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该事件压入队列中。文件事件分派器从队列中获取该事件，交给<strong>连接应答处理器</strong>。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 <code>AE_READABLE</code> 事件与命令请求处理器关联。</li><li>假设此时客户端发送了一个 <code>set key value</code> 请求，此时 redis 中的 socket01 会产生 <code>AE_READABLE</code> 事件，IO 多路复用程序将事件压入队列，此时事件分派器从队列中获取到该事件，由于前面 socket01 的 <code>AE_READABLE</code> 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 <code>key value</code> 并在自己内存中完成 <code>key value</code> 的设置。操作完成后，它会将 socket01 的 <code>AE_WRITABLE</code> 事件与令回复处理器关联。</li><li>如果此时客户端准备好接收返回结果了，那么 redis 中的 socket01 会产生一个 <code>AE_WRITABLE</code> 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 <code>ok</code>，之后解除 socket01 的 <code>AE_WRITABLE</code> 事件与命令回复处理器的关联。</li></ul><p>这样便完成了一次通信。😈 耐心理解一下，灰常重要。如果还是不能理解，可以在网络上搜一些资料，在理解理解。</p><h2 id="为什么-Redis-单线程模型也能效率这么高？"><a href="#为什么-Redis-单线程模型也能效率这么高？" class="headerlink" title="为什么 Redis 单线程模型也能效率这么高？"></a>为什么 Redis 单线程模型也能效率这么高？</h2><ul><li><p>1、纯内存操作。</p><blockquote><p>Redis 为了达到最快的读写速度，将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以 Redis 具有快速和数据持久化的特征。</p><p>如果不将数据放在内存中，磁盘 I/O 速度为严重影响 Redis 的性能。</p></blockquote></li><li><p>2、核心是基于非阻塞的 IO 多路复用机制。</p></li><li><p>3、单线程反而避免了多线程的频繁上下文切换问题。</p><blockquote><p>Redis 利用队列技术，将并发访问变为串行访问，消除了传统数据库串行控制的开销</p></blockquote></li><li><p>4、Redis 全程使用 hash 结构，读取速度快，还有一些特殊的数据结构，对数据存储进行了优化，如压缩表，对短数据进行压缩存储，再如，跳表，使用有序的数据结构加快读取的速度。</p></li></ul><h2 id="Redis-有几种持久化方式？"><a href="#Redis-有几种持久化方式？" class="headerlink" title="Redis 有几种持久化方式？"></a>Redis 有几种持久化方式？</h2><h3 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h3><p>Redis 提供了两种方式，实现数据的持久化到硬盘。</p><ul><li>【全量】RDB 持久化，是指在指定的时间间隔内将内存中的<strong>数据集快照</strong>写入磁盘。实际操作过程是，fork 一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</li><li>【增量】AOF持久化，以日志的形式记录服务器所处理的每一个<strong>写、删除操作</strong>，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</li></ul><h3 id="二者的区别"><a href="#二者的区别" class="headerlink" title="二者的区别"></a>二者的区别</h3><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。</p><p><img src="Redis\388326-20170726161552843-904424952.png" alt="img"></p><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><p><img src="Redis\388326-20170726161604968-371688235.png" alt="img"></p><h3 id="二者优缺点"><a href="#二者优缺点" class="headerlink" title="二者优缺点"></a>二者优缺点</h3><p><strong>RDB存在哪些优势呢？</strong></p><ul><li>一旦采用该方式，那么你的整个Redis数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</li><li>对于灾难恢复而言，RDB是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</li><li>性能最大化。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。</li><li>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</li></ul><p><strong>RDB又存在哪些劣势呢？</strong></p><ul><li>.如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</li><li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</li></ul><p><strong>AOF的优势有哪些呢？</strong></p><ul><li>该机制可以带来更高的数据安全性，即数据持久性。Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</li><li>由于该机制对日志文件的写入操作采用的是append模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操作只是写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，我们可以通过redis-check-aof工具来帮助我们解决数据一致性的问题。</li><li>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li><li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</li></ul><p><strong>AOF的劣势有哪些呢？</strong></p><ul><li>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。</li><li>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和RDB一样高效。</li></ul><p>二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（aof），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）。rdb这个就更有些 eventually consistent 的意思了。</p><h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><strong>RDB持久化配置</strong></p><p>Redis会将数据集的快照dump到dump.rdb文件中。此外，我们也可以通过配置文件来修改Redis服务器dump快照的频率，在打开6379.conf文件之后，我们搜索save，可以看到下面的配置信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1         # 在900秒(15分钟)之后，如果至少有1个key发生变化，则dump内存快照。</span><br><span class="line">save 300 10        # 在300秒(5分钟)之后，如果至少有10个key发生变化，则dump内存快照。</span><br><span class="line">save 60 10000      # 在60秒(1分钟)之后，如果至少有10000个key发生变化，则dump内存快照。</span><br></pre></td></tr></table></figure><p><strong>AOF持久化配置</strong></p><p>在Redis的配置文件中存在三种同步方式，它们分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always     # 每次有数据修改发生时都会写入AOF文件。</span><br><span class="line">appendfsync everysec   # 每秒钟同步一次，该策略为AOF的缺省策略。</span><br><span class="line">appendfsync no         # 从不同步。高效但是数据不会被持久化。</span><br></pre></td></tr></table></figure><h3 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h3><ul><li><p>不要仅仅使用 RDB，因为那样会导致你丢失很多数据</p></li><li><p>也不要仅仅使用 AOF，因为那样有两个问题，第一，你通过 AOF 做冷备，没有 RDB 做冷备，来的恢复速度更快; 第二，RDB 每次简单粗暴生成数据快照，更加健壮，可以避免 AOF 这种复杂的备份和恢复机制的 bug 。</p></li><li><p>Redis 支持同时开启开启两种持久化方式，我们可以综合使用 AOF 和 RDB 两种持久化机制，用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。</p><ul><li><p>如果同时使用 RDB 和 AOF 两种持久化机制，那么在 Redis 重启的时候，会使用 <strong>AOF</strong> 来重新构建数据，因为 AOF 中的<strong>数据更加完整</strong>。</p><blockquote><p>一般来说， 如果想达到足以媲美 PostgreSQL 的数据安全性， 你应该同时使用两种持久化功能。如果你非常关心你的数据， 但仍然可以承受数分钟以内的数据丢失，那么你可以只使用 RDB 持久化。</p><p>有很多用户都只使用 AOF 持久化，但并不推荐这种方式：因为定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比AOF恢复的速度要快，除此之外，使用 RDB 还可以避免之前提到的 AOF 程序的 bug。</p></blockquote></li></ul></li></ul><p>在 Redis4.0 版本开始，允许你使用 RDB-AOF 混合持久化方式，详细可见 <a href="https://yq.aliyun.com/articles/193034" target="_blank" rel="noopener">《Redis4.0 之 RDB-AOF 混合持久化》</a> 。也因此，RDB 和 AOF 同时使用，是希望达到安全的持久化的推荐方式。</p><h3 id="自动化触发-RDB-持久化的方式"><a href="#自动化触发-RDB-持久化的方式" class="headerlink" title="自动化触发 RDB 持久化的方式"></a>自动化触发 RDB 持久化的方式</h3><ul><li>根据 redis.conf 配置中 SAVE m n 定时触发（使用的BGSAVE）</li><li>主从复制时，主节点自动触发</li><li>执行 Debug Reload</li><li>执行 Shutdown 且没有开启 AOF 持久化</li></ul><p>BGSAVE 原理：</p><p><img src="Redis\timg.jpg" alt="timg"></p><p><strong>重要知识：</strong></p><ul><li>bgsave 做镜像全量持久化，AOF 做增量持久化。因为 bgsave 会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要 AOF 来配合使用。在 Redis 实例重启时，会使用 bgsave 持久化文件重新构建内存，再使用 AOF 重放近期的操作指令来实现完整恢复重启之前的状态。</li><li>对方追问那如果突然机器掉电会怎样？取决于 AOF 日志 sync 属性的配置，如果不要求性能，在每条写指令时都 sync 一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync 是不现实的，一般都使用定时 sync ，比如 1 秒 1 次，这个时候最多就会丢失 1 秒的数据。</li><li>对方追问 bgsave 的原理是什么？你给出两个词汇就可以了，fork 和 cow 。fork 是指 Redis 通过创建子进程来进行 bgsave 操作。cow 指的是 copy on write ，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</li></ul><h2 id="Redis-有几种数据“过期”策略？"><a href="#Redis-有几种数据“过期”策略？" class="headerlink" title="Redis 有几种数据“过期”策略？"></a>Redis 有几种数据“过期”策略？</h2><p>Redis 的过期策略，就是指当 Redis 中缓存的 key 过期了，Redis 如何处理。</p><p>Redis 提供了 3 种数据过期策略：</p><ul><li>被动删除：当读/写一个已经过期的 key 时，会触发惰性删除策略，直接删除掉这个过期 key 。</li><li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以 Redis 会定期主动淘汰一批已过期的 key 。</li><li>主动删除：当前已用内存超过 maxmemory 限定时，触发主动清理策略，即 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「数据“淘汰”策略」</a> 。</li></ul><p>在 Redis 中，同时使用了上述 3 种策略，即它们<strong>非互斥</strong>的。</p><p>想要进一步了解，可以看看 <a href="https://www.cnblogs.com/chenpingzhao/p/5022467.html" target="_blank" rel="noopener">《关于 Redis 数据过期策略》</a> 文章。</p><h2 id="Redis-有哪几种数据“淘汰”策略？"><a href="#Redis-有哪几种数据“淘汰”策略？" class="headerlink" title="Redis 有哪几种数据“淘汰”策略？"></a>Redis 有哪几种数据“淘汰”策略？</h2><p>Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。</p><p>Redis 提供了 6 种数据淘汰策略：</p><ol><li>volatile-lru</li><li>volatile-ttl</li><li>volatile-random</li><li>allkeys-lru</li><li>allkeys-random</li><li>no-enviction</li></ol><p>具体的 <strong>每种数据淘汰策略的定义</strong>，和 <strong>如何选择讨论策略</strong>，可见 <a href="http://blog.720ui.com/2016/redis_action_02_maxmemory_policy/" target="_blank" rel="noopener">《Redis实战（二） 内存淘汰机制》</a> 。</p><p> <strong>Redis LRU 算法</strong></p><p>另外，Redis 的 LRU 算法，<strong>并不是一个严格的 LRU 实现</strong>。这意味着 Redis 不能选择最佳候选键来回收，也就是最久未被访问的那些键。相反，Redis 会尝试执行一个近似的 LRU 算法，通过采样一小部分键，然后在采样键中回收最适合(拥有最久未被访问时间)的那个。</p><ul><li><p>具体的可以看看 <a href="http://ifeve.com/lru-cache/" target="_blank" rel="noopener">《使用 Redis 作为一个 LRU 缓存》</a> 文章。</p><p><strong>MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据？</strong></p></li></ul><blockquote><p>艿艿：这个是从网络上找到的一个神奇的问题，并且看了答案之后，觉得有点莫名的对不上。</p><p>所以，感觉这个问题的目的是，如何保证热点数据不要被淘汰。</p></blockquote><p>在 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 有哪几种数据“淘汰”策略？」</a> 问题中，我们已经看到，“Redis 内存数据集大小上升到一定大小的时候，就会进行数据淘汰策略。” 。</p><p>那么，如果我们此时要保证热点数据不被淘汰，那么需要选择 volatile-lru 或 allkeys-lru 这两个基于 LRU 算法的淘汰策略。</p><p>相比较来说，最终会选择 allkeys-lru 淘汰策略。原因是，如果我们的应用对缓存的访问符合幂律分布，也就是存在相对热点数据，或者我们不太清楚我们应用的缓存访问分布状况，我们可以选择 allkeys-lru 策略。</p><p> <strong>Redis 回收进程如何工作的？</strong></p><p>理解回收进程如何工作是非常重要的：</p><ul><li>一个客户端运行了新的命令，添加了新的数据</li><li>Redis 检查内存使用情况，如果大于 maxmemory 的限制, 则根据设定好的策略进行回收。</li><li>Redis 执行新命令……</li></ul><p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下（跌宕起伏）。</p><h2 id="如果有大量的-key-需要设置同一时间过期，一般需要注意什么？"><a href="#如果有大量的-key-需要设置同一时间过期，一般需要注意什么？" class="headerlink" title="如果有大量的 key 需要设置同一时间过期，一般需要注意什么？"></a>如果有大量的 key 需要设置同一时间过期，一般需要注意什么？</h2><p>如果大量的 key 过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。</p><p>一般需要在时间上加一个随机值，使得过期时间分散一些。</p><h2 id="Redis-有哪些数据结构？"><a href="#Redis-有哪些数据结构？" class="headerlink" title="Redis 有哪些数据结构？"></a>Redis 有哪些数据结构？</h2><p>如果你是 Redis 普通玩家，可能你的回答是如下五种数据结构：</p><ul><li>字符串 String</li><li>字典Hash</li><li>列表List</li><li>集合Set</li><li>有序集合 SortedSet</li></ul><p>如果你是 Redis 中级玩家，还需要加上下面几种数据结构：</p><ul><li>HyperLogLog</li><li>Geo</li><li>Pub / Sub</li></ul><p>如果你是 Redis 高端玩家，你可能玩过 Redis Module ，可以再加上下面几种数据结构：</p><ul><li>BloomFilter</li><li>RedisSearch</li><li>Redis-ML</li><li>JSON</li></ul><p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。😈 默默跟面试官在装一波。</p><h2 id="聊聊-Redis-使用场景"><a href="#聊聊-Redis-使用场景" class="headerlink" title="聊聊 Redis 使用场景"></a>聊聊 Redis 使用场景</h2><p>Redis 可用的场景非常之多：</p><ul><li>数据缓存</li><li>会话缓存</li><li>时效性数据</li><li>访问频率</li><li>计数器</li><li>社交列表</li><li>记录用户判定信息</li><li>交集、并集和差集</li><li>热门列表与排行榜</li><li>最新动态</li><li>消息队列</li><li>分布式锁</li></ul><p>详细的介绍，可以看看如下文章：</p><ul><li><a href="http://blog.720ui.com/2017/redis_core_use/" target="_blank" rel="noopener">《聊聊 Redis 使用场景》</a></li><li><a href="https://www.jianshu.com/p/af277c77b1c9" target="_blank" rel="noopener">《Redis 应用场景及实例》</a></li><li><a href="https://zhuanlan.zhihu.com/p/29665317" target="_blank" rel="noopener">《Redis 常见的应用场景解析》</a></li><li><a href="https://www.zhihu.com/question/19829601" target="_blank" rel="noopener">《Redis 和 Memcached 各有什么优缺点，主要的应用场景是什么样的？》</a></li></ul><p><strong>请用 Redis 和任意语言实现一段恶意登录保护的代码，限制 1 小时内每用户 Id 最多只能登录 5 次。</strong></p><p>用列表实现，列表中每个元素代表登陆时间，只要最后的第 5 次登陆时间和现在时间差不超过 1 小时就禁止登陆。</p><p>具体的代码实现，可以看看 <a href="https://www.jianshu.com/p/e3abbfc59d77" target="_blank" rel="noopener">《一道 Redis 面试题》</a> 。</p><h2 id="Redis-支持的-Java-客户端都有哪些？"><a href="#Redis-支持的-Java-客户端都有哪些？" class="headerlink" title="Redis 支持的 Java 客户端都有哪些？"></a>Redis 支持的 Java 客户端都有哪些？</h2><p>使用比较广泛的有三个 Java 客户端：</p><ul><li><p>Redisson</p><blockquote><p>Redisson ，是一个高级的分布式协调 Redis 客服端，能帮助用户在分布式环境中轻松实现一些 Java 的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p></blockquote></li><li><p>Jedis</p><blockquote><p>Jedis 是 Redis 的 Java 实现的客户端，其 API 提供了比较全面的 Redis 命令的支持。</p><p>Redisson 实现了分布式和可扩展的 Java 数据结构，和 Jedis 相比，Jedis 功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等 Redis 特性。</p><p>Redisson 的宗旨是促进使用者对 Redis 的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p></blockquote></li><li><p>Lettuce</p><blockquote><p>Lettuce 是一个可伸缩线程安全的 Redis 客户端。多个线程可以共享同一个 RedisConnection 。它利用优秀 Netty NIO 框架来高效地管理多个连接。</p></blockquote></li></ul><p>Redis 官方推荐使用 Redisson 或 Jedis 。</p><p>Spring Boot 2.x 内置使用 Lettuce 。</p><h2 id="如何使用-Redis-实现分布式锁？"><a href="#如何使用-Redis-实现分布式锁？" class="headerlink" title="如何使用 Redis 实现分布式锁？"></a>如何使用 Redis 实现分布式锁？</h2><p> <strong>方案一：set 指令</strong></p><p>先拿 setnx 来争抢锁，抢到之后，再用 expire 给锁加一个过期时间防止锁忘记了释放。</p><ul><li>这时候对方会告诉你说你回答得不错，然后接着问如果在 setnx 之后执行 expire 之前进程意外 crash 或者要重启维护了，那会怎么样？</li><li>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得 set 指令有非常复杂的参数，这个应该是可以同时把 setnx 和 expire 合成一条指令来用的！对方这时会显露笑容，心里开始默念：摁，这小子还不错。</li></ul><p>所以，我们可以使用 <strong>set</strong> 指令，实现分布式锁。指令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET key value [EX seconds] [PX milliseconds] [NX|XX]</span><br></pre></td></tr></table></figure><ul><li>可以使用 <code>SET key value EX seconds NX</code> 命令，尝试获得锁。</li><li>具体的实现，可以参考 <a href="https://wudashan.cn/2017/10/23/Redis-Distributed-Lock-Implement/" target="_blank" rel="noopener">《Redis 分布式锁的正确实现方式（Java版）》</a> 文章。</li></ul><p><strong>方案二：redlock</strong></p><p>set 指令的方案，适合用于在单机 Redis 节点的场景下，在多 Redis 节点的场景下，会存在分布式锁丢失的问题。所以，Redis 作者 Antirez 基于分布式环境下提出了一种更高级的分布式锁的实现方式：Redlock 。</p><p>具体的方案，胖友可以看看老友飞哥的两篇博客：</p><ul><li><a href="https://mp.weixin.qq.com/s/JLEzNqQsx-Lec03eAsXFOQ" target="_blank" rel="noopener">《Redlock：Redis分布式锁最牛逼的实现》</a></li><li><a href="https://www.jianshu.com/p/f302aa345ca8" target="_blank" rel="noopener">《Redisson 实现 Redis 分布式锁的 N 种姿势》</a></li></ul><p> <strong>对比 Zookeeper 分布式锁</strong></p><ul><li>从可靠性上来说，Zookeeper 分布式锁好于 Redis 分布式锁。</li><li>从性能上来说，Redis 分布式锁好于 Zookeeper 分布式锁。</li></ul><p>所以，没有绝对的好坏，可以根据自己的业务来具体选择。</p><h2 id="如何使用-Redis-实现消息队列？"><a href="#如何使用-Redis-实现消息队列？" class="headerlink" title="如何使用 Redis 实现消息队列？"></a>如何使用 Redis 实现消息队列？</h2><p>一般使用 list 结构作为队列，rpush 生产消息，lpop 消费消息。当 lpop 没有消息的时候，要适当 sleep 一会再重试。</p><ul><li>如果对方追问可不可以不用 sleep 呢？list 还有个指令叫 blpop ，在没有消息的时候，它会阻塞住直到消息到来。</li><li>如果对方追问能不能生产一次消费多次呢？使用 pub / sub 主题订阅者模式，可以实现 1:N 的消息队列。</li><li>如果对方追问 pub / sub 有什么缺点？在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如 rabbitmq 等。</li><li>如果对方追问 redis 如何实现延时队列？我估计现在你很想把面试官一棒打死如果你手上有一根棒球棍的话，怎么问的这么详细。但是你很克制，然后神态自若的回答道：使用 sortedset ，拿时间戳作为 score ，消息内容作为 key 调用 zadd 来生产消息，消费者用 zrangebyscore 指令获取 N 秒之前的数据轮询进行处理。</li></ul><p>到这里，面试官暗地里已经对你竖起了大拇指。但是他不知道的是此刻你却竖起了中指，在椅子背后。</p><p>当然，实际上 Redis 真的真的真的不推荐作为消息队列使用，它最多只是消息队列的存储层，上层的逻辑，还需要做大量的封装和支持。</p><p>另外，在 Redis 5.0 增加了 Stream 功能，一个新的强大的支持多播的可持久化的消息队列，提供类似 Kafka 的功能。</p><h2 id="什么是-Redis-Pipelining-？"><a href="#什么是-Redis-Pipelining-？" class="headerlink" title="什么是 Redis Pipelining ？"></a>什么是 Redis Pipelining ？</h2><p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p><p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多 POP3 协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p><p>Redis 很早就支持管道（<a href="http://redis.cn/topics/pipelining.html" target="_blank" rel="noopener">pipelining</a>）技术，因此无论你运行的是什么版本，你都可以使用管道（pipelining）操作 Redis。</p><p> <strong>Redis 如何做大量数据插入？</strong></p><p>Redis2.6 开始，Redis-cli 支持一种新的被称之为 pipe mode 的新模式用于执行大量数据插入工作。</p><p>具体可见 <a href="http://www.redis.cn/topics/mass-insert.html" target="_blank" rel="noopener">《Redis 大量数据插入》</a> 文章。</p><h2 id="什么是-Redis-事务？"><a href="#什么是-Redis-事务？" class="headerlink" title="什么是 Redis 事务？"></a>什么是 Redis 事务？</h2><p>和众多其它数据库一样，Redis 作为 NoSQL 数据库也同样提供了事务机制。在Redis中，MULTI / EXEC / DISCARD / WATCH 这四个命令是我们实现事务的基石。相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出 Redis 中事务的实现特征：</p><ul><li><p>1、在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</p></li><li><p>2、和关系型数据库中的事务相比，在 Redis 事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</p></li><li><p>3、我们可以通过 MULTI 命令开启一个事务，有关系型数据库开发经验的人可以将其理解为 <code>&quot;BEGIN TRANSACTION&quot;</code> 语句。在该语句之后执行的命令都，将被视为事务之内的操作，最后我们可以通过执行 EXEC / DISCARD 命令来提交 / 回滚该事务内的所有操作。这两个 Redis 命令，可被视为等同于关系型数据库中的 COMMIT / ROLLBACK 语句。</p></li><li><p>4、在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行 EXEC 命令之后，那么该事务中的所有命令都会被服务器执行。</p></li><li><p>5、当使用 Append-Only 模式时，Redis 会通过调用系统函数 write 将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</p><blockquote><p>Redis 服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。此时，我们就要充分利用 Redis 工具包中提供的 redis-check-aof 工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p></blockquote></li></ul><p><strong>如何实现 Redis CAS 操作？</strong></p><p>在 Redis 的事务中，WATCH 命令可用于提供CAS(check-and-set)功能。</p><p>假设我们通过 WATCH 命令在事务执行之前监控了多个 keys ，倘若在 WATCH 之后有任何 Key 的值发生了变化，EXEC 命令执行的事务都将被放弃，同时返回 <code>nil</code> 应答以通知调用者事务执行失败。</p><p>具体的示例，可以看看 <a href="https://www.jianshu.com/p/0244a875aa26" target="_blank" rel="noopener">《Redis 事务锁 CAS 实现以及深入误区》</a> 。</p><h2 id="Redis-集群都有哪些方案？"><a href="#Redis-集群都有哪些方案？" class="headerlink" title="Redis 集群都有哪些方案？"></a>Redis 集群都有哪些方案？</h2><p>Redis 集群方案如下：</p><ul><li>1、Redis Sentinel</li><li>2、Redis Cluster</li><li>3、Twemproxy</li><li>4、Codis</li><li>5、客户端分片</li></ul><p>关于前四种，可以看看 <a href="http://blog.720ui.com/2016/redis_action_04_cluster/" target="_blank" rel="noopener">《Redis 实战（四）集群机制》</a> 这篇文章。</p><p>关于最后一种，客户端分片，在 Redis Cluster 出现之前使用较多，目前已经使用比较少了。实现方式如下：</p><blockquote><p>在业务代码层实现，起几个毫无关联的 Redis 实例，在代码层，对 Key 进行 hash 计算，然后去对应的 Redis 实例操作数据。</p><p>这种方式对 hash 层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p></blockquote><p><strong>选择</strong></p><p>目前一般在选型上来说：</p><ul><li>体量较小时，选择 Redis Sentinel ，单主 Redis 足以支撑业务。</li><li><p>体量较大时，选择 Redis Cluster ，通过分片，使用更多内存。</p><p><strong>Redis 集群如何扩容？</strong></p></li></ul><blockquote><p>这个问题，艿艿了解的也不是很多，建议在搜索有什么方案。</p></blockquote><ul><li>如果 Redis 被当做<strong>缓存</strong>使用，使用一致性哈希实现动态扩容缩容。</li><li>如果 Redis 被当做一个<strong>持久化存</strong>储使用，必须使用固定的 keys-to-nodes 映射关系，节点的数量一旦确定不能变化。否则的话(即Redis 节点需要动态变化的情况），必须使用可以在运行时进行数据再平衡的一套系统，而当前只有 Redis Cluster、Codis 可以做到这样。</li></ul><h2 id="什么是-Redis-主从同步？"><a href="#什么是-Redis-主从同步？" class="headerlink" title="什么是 Redis 主从同步？"></a>什么是 Redis 主从同步？</h2><p><strong>Redis 主从同步</strong></p><p>Redis 的主从同步(replication)机制，允许 Slave 从 Master 那里，通过网络传输拷贝到完整的数据备份，从而达到主从机制。</p><ul><li>主数据库可以进行读写操作，当发生写操作的时候自动将数据同步到从数据库，而从数据库一般是只读的，并接收主数据库同步过来的数据。</li><li>一个主数据库可以有多个从数据库，而一个从数据库只能有一个主数据库。</li><li>第一次同步时，主节点做一次 bgsave 操作，并同时将后续修改操作记录到内存 buffer ，待完成后将 RDB 文件全量同步到复制节点，复制节点接受完成后将 RDB 镜像加载到内存。加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ul><p><strong>好处</strong></p><p>通过 Redis 的复制功，能可以很好的实现数据库的读写分离，提高服务器的负载能力。主数据库主要进行写操作，而从数据库负责读操作。</p><p>Redis 主从同步，是很多 Redis 集群方案的基础，例如 Redis Sentinel、Redis Cluster 等等。</p><p>更多详细，可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-master-slave.md" target="_blank" rel="noopener">《Redis 主从架构》</a> 。</p><h2 id="如何使用-Redis-Sentinel-实现高可用？"><a href="#如何使用-Redis-Sentinel-实现高可用？" class="headerlink" title="如何使用 Redis Sentinel 实现高可用？"></a>如何使用 Redis Sentinel 实现高可用？</h2><p>可以看看 <a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-sentinel.md" target="_blank" rel="noopener">《Redis 哨兵集群实现高可用》</a> 。</p><h2 id="如果使用-Redis-Cluster-实现高可用？"><a href="#如果使用-Redis-Cluster-实现高可用？" class="headerlink" title="如果使用 Redis Cluster 实现高可用？"></a>如果使用 Redis Cluster 实现高可用？</h2><p>可以看看</p><ul><li><a href="http://redis.cn/topics/cluster-tutorial.html" target="_blank" rel="noopener">《Redis 集群教程》</a> 完整版</li><li><a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/redis-cluster.md" target="_blank" rel="noopener">《Redis 集群模式的工作原理能说一下么？》</a> 精简版</li></ul><p><strong>说说 Redis 哈希槽的概念？</strong></p><p>Redis Cluster 没有使用一致性 hash ，而是引入了哈希槽的概念。</p><p>Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p><p>因为最大是 16384 个哈希槽，所以考虑 Redis 集群中的每个节点都能分配到一个哈希槽，所以最多支持 16384 个 Redis 节点。</p><p> <strong>Redis Cluster 的主从复制模型是怎样的？</strong></p><p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了<strong>主从复制</strong>模型，每个节点都会有 N-1 个复制节点。</p><p>所以，Redis Cluster 可以说是 Redis Sentinel 带分片的加强版。也可以说：</p><ul><li>Redis Sentinel 着眼于高可用，在 master 宕机时会自动将 slave 提升为 master ，继续提供服务。</li><li>Redis Cluster 着眼于扩展性，在单个 Redis 内存不足时，使用Cluster 进行分片存储。</li></ul><p><strong>Redis Cluster 方案什么情况下会导致整个集群不可用？</strong></p><p>有 A，B，C 三个节点的集群，在没有复制模型的情况下，如果节点 B 宕机了，那么整个集群就会以为缺少 5501-11000 这个范围的槽而不可用。</p><p> <strong>Redis Cluster 会有写操作丢失吗？为什么？</strong></p><p>Redis 并不能保证数据的强一致性，而是【异步复制】，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p><p><strong>Redis 集群如何选择数据库？</strong></p><p>Redis 集群目前无法做数据库选择，默认在 0 数据库。</p><p><strong>请说说生产环境中的 Redis 是怎么部署的？</strong></p><blockquote><p>重点问题，仔细理解。</p></blockquote><ul><li>Redis Cluster，10 台机器，5 台机器部署了 redis 主实例，另外 5 台机器部署了 redis 的从实例，每个主实例挂了一个从实例，5 个节点对外提供读写服务，每个节点的读写高峰 qps 可能可以达到每秒 5 万，5 台机器最多是 25 万读写请求每秒。</li><li>机器是什么配置？32G 内存 + 8 核 CPU + 1T 磁盘，但是分配给 Redis 进程的是 10g 内存，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。那么，5 台机器对外提供读写，一共有 50g 内存。</li><li>因为每个主实例都挂了一个从实例，所以是高可用的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例会自动变成主实例继续提供读写服务。</li><li>你往内存里写的是什么数据？每条数据的大小是多少？商品数据，每条数据是 10kb 。100 条数据是 1mb ，10 万条数据是 1g 。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</li><li>其实大型的公司，会有基础架构的 team 负责缓存集群的运维。</li></ul><h2 id="什么是-Redis-分区？"><a href="#什么是-Redis-分区？" class="headerlink" title="什么是 Redis 分区？"></a>什么是 Redis 分区？</h2><blockquote><p>这个问题，和 <a href="http://svip.iocoder.cn/Redis/Interview/#" target="_blank" rel="noopener">「Redis 集群都有哪些方案？」</a> 是同类问题。</p></blockquote><p> 关于如下四个问题，直接看 <a href="http://www.runoob.com/redis/redis-partitioning.html" target="_blank" rel="noopener">《Redis 分区》</a> 文章。</p><ul><li>Redis 分区是什么？</li><li>分区的优势？</li><li>分区的不足？</li><li>分区类型？</li></ul><p>可能有胖友会懵逼，又是 Redis 主从复制，又是 Redis 分区，又是 Redis 集群。傻傻分不清啊！</p><ul><li>Redis 分区是一种模式，将数据分区到不同的 Redis 节点上，而 Redis 集群的 Redis Cluster、Twemproxy、Codis、客户端分片( 不包括 Redis Sentinel ) 这四种方案，是 Redis 分区的具体实现。</li><li>Redis 每个分区，如果想要实现高可用，需要使用到 Redis 主从复制。</li></ul><p><strong>你知道有哪些 Redis 分区实现方案</strong>？</p><p>Redis 分区方案，主要分成两种类型：</p><ul><li>客户端分区，就是在客户端就已经决定数据会被存储到哪个 Redis 节点或者从哪个 Redis 节点读取。大多数客户端已经实现了客户端分区。<ul><li>案例：Redis Cluster 和客户端分区。</li></ul></li><li>代理分区，意味着客户端将请求发送给代理，然后代理决定去哪个节点写数据或者读数据。代理根据分区规则决定请求哪些 Redis 实例，然后根据 Redis 的响应结果返回给客户端。 <ul><li>案例：Twemproxy 和 Codis 。</li></ul></li></ul><p>查询路由(Query routing)的意思，是客户端随机地请求任意一个 Redis 实例，然后由 Redis 将请求转发给正确的 Redis 节点。Redis Cluster 实现了一种混合形式的查询路由，但并不是直接将请求从一个Redis 节点转发到另一个 Redis 节点，而是在客户端的帮助下直接 redirect 到正确的 Redis 节点。</p><p><strong>分布式 Redis 是前期做还是后期规模上来了再做好？为什么？？</strong></p><p>如下是网络上的一个大答案：</p><blockquote><p>既然 Redis 是如此的轻量（单实例只使用1M内存），为防止以后的扩容，最好的办法就是一开始就启动较多实例。即便你只有一台服务器，你也可以一开始就让 Redis 以分布式的方式运行，使用分区，在同一台服务器上启动多个实例。</p><p>一开始就多设置几个 Redis 实例，例如 32 或者 64 个实例，对大多数用户来说这操作起来可能比较麻烦，但是从长久来看做这点牺牲是值得的。</p><p>这样的话，当你的数据不断增长，需要更多的 Redis 服务器时，你需要做的就是仅仅将 Redis 实例从一台服务迁移到另外一台服务器而已（而不用考虑重新分区的问题）。一旦你添加了另一台服务器，你需要将你一半的 Redis 实例从第一台机器迁移到第二台机器。</p></blockquote><ul><li>和飞哥沟通了下，这个操作不是很合理。</li><li>无论怎么说，建议，需要搭建下 Redis Sentinel 高可用，至于拓展性，根据自己的情况，是否使用 Redis Cluster 集群</li></ul><h2 id="Redis-有哪些重要的健康指标？"><a href="#Redis-有哪些重要的健康指标？" class="headerlink" title="Redis 有哪些重要的健康指标？"></a>Redis 有哪些重要的健康指标？</h2><p>推荐阅读 <a href="https://mp.weixin.qq.com/s/D_khsApGkRckEoV75pYpDA" target="_blank" rel="noopener">《Redis 几个重要的健康指标》</a></p><ul><li>存活情况</li><li>连接数</li><li>阻塞客户端数量</li><li>使用内存峰值</li><li>内存碎片率</li><li>缓存命中率</li><li>OPS</li><li>持久化</li><li>失效KEY</li><li>慢日志</li></ul><p><strong>如何提高 Redis 命中率？</strong></p><p>推荐阅读 <a href="http://www.cnblogs.com/shamo89/p/8383915.html" target="_blank" rel="noopener">《如何提高缓存命中率（Redis）》</a> 。</p><h2 id="怎么优化-Redis-的内存占用"><a href="#怎么优化-Redis-的内存占用" class="headerlink" title="怎么优化 Redis 的内存占用"></a>怎么优化 Redis 的内存占用</h2><p>推荐阅读 <a href="https://www.jianshu.com/p/8677603d3865" target="_blank" rel="noopener">《Redis 的内存优化》</a></p><ul><li>redisObject 对象</li><li>缩减键值对象</li><li>共享对象池</li><li>字符串优化</li><li>编码优化</li><li><p>控制 key 的数量</p><p><strong>一个 Redis 实例最多能存放多少的 keys？List、Set、Sorted Set 他们最多能存放多少元素？</strong></p></li></ul><p>一个 Redis 实例，最多能存放多少的 keys ，List、Set、Sorted Set 他们最多能存放多少元素。</p><p>理论上，Redis 可以处理多达 2^32 的 keys ，并且在实际中进行了测试，每个实例至少存放了 2 亿 5 千万的 keys。</p><p>任何 list、set、和 sorted set 都可以放 2^32 个元素。</p><p><strong>假如 Redis 里面有 1 亿个 key，其中有 10w 个 key 是以某个固定的已知的前缀开头的，如果将它们全部找出来？</strong></p><p>使用 keys 指令可以扫出指定模式的 key 列表。</p><ul><li>对方接着追问：如果这个 Redis 正在给线上的业务提供服务，那使用keys指令会有什么问题？</li><li>这个时候你要回答 Redis 关键的一个特性：Redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用 scan 指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用 keys 指令长。</li></ul><h2 id="Redis-常见的性能问题都有哪些？如何解决？"><a href="#Redis-常见的性能问题都有哪些？如何解决？" class="headerlink" title="Redis 常见的性能问题都有哪些？如何解决？"></a>Redis 常见的性能问题都有哪些？如何解决？</h2><p><strong>1、Master 最好不要做任何持久化工作，如 RDB 内存快照和 AOF 日志文件。</strong></p><ul><li>Master 写内存快照，save 命令调度 rdbSave 函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master 最好不要写内存快照。</li><li>Master AOF 持久化，如果不重写 AOF 文件，这个持久化方式对性能的影响是最小的，但是 AOF 文件会不断增大，AOF 文件过大会影响 Master 重启的恢复速度。</li><li>所以，Master 最好不要做任何持久化工作，包括内存快照和 AOF 日志文件，特别是不要启用内存快照做持久化。如果数据比较关键，某个 Slave 开启AOF备份数据，策略为每秒同步一次</li></ul><p><strong>2、Master 调用 BGREWRITEAOF 重写 AOF 文件，AOF 在重写的时候会占大量的 CPU 和内存资源，导致服务 load 过高，出现短暂服务暂停现象。</strong> </p><p><strong>3、尽量避免在压力很大的主库上增加从库。</strong> </p><p><strong>4、主从复制不要用图状结构，用单向链表结构更为稳定，即：<code>Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3...</code> 。</strong> </p><ul><li>这样的结构，也方便解决单点故障问题，实现 Slave 对 Master 的替换。如果 Master挂了，可以立刻启用 Slave1 做 Master ，其他不变。</li></ul><p><strong>5、Redis 主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave 和 Master 最好在同一个局域网内。</strong></p><hr><p>和飞哥沟通过后，他们主节点开启 AOF ，从节点开启 AOF + RDB 。</p><p>和晓峰沟通后，他们主节点开启 AOF ，从节点开启 RDB 居多，也有开启 AOF + RDB 的。</p><h2 id="修改配置不重启-Redis-会实时生效吗？"><a href="#修改配置不重启-Redis-会实时生效吗？" class="headerlink" title="修改配置不重启 Redis 会实时生效吗？"></a>修改配置不重启 Redis 会实时生效吗？</h2><p>针对运行实例，有许多配置选项可以通过 <code>CONFIG SET</code> 命令进行修改，而无需执行任何形式的重启。</p><p>从 Redis 2.2 开始，可以从 AOF 切换到 RDB 的快照持久性或其他方式而不需要重启 Redis。检索 <code>CONFIG GET *</code> 命令获取更多信息。</p><p>但偶尔重新启动是必须的，如为升级 Redis 程序到新的版本，或者当你需要修改某些目前 CONFIG 命令还不支持的配置参数的时候。</p><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>有些比较凶残的面试官，可能会问我们一些 Redis 数据结构的问题，例如：</p><ul><li><p>Skiplist 插入和查询原理？</p></li><li><p>压缩列表的原理？</p></li><li><p>Redis 底层为什么使用跳跃表而不是红黑树？</p><blockquote><p>跳跃表在范围查找的时候性能比较高。</p></blockquote></li></ul><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="http://svip.iocoder.cn/Redis/Interview/" target="_blank" rel="noopener">精尽 Redis 面试题 </a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是-Redis-？&quot;&gt;&lt;a href=&quot;#什么是-Redis-？&quot; class=&quot;headerlink&quot; title=&quot;什么是 Redis ？&quot;&gt;&lt;/a&gt;什么是 Redis ？&lt;/h2&gt;&lt;p&gt;Redis，全称 Remote Dictionary Server，是一个基于内存的高性能 Key-Value 数据库。&lt;/p&gt;
&lt;p&gt;另外，Redis 已经成为互联网公司在缓存组件选择的唯一，更多的关注点是，如何使用好 Redis 。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="http://blog.cuzz.site/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="转载" scheme="http://blog.cuzz.site/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="Redis" scheme="http://blog.cuzz.site/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Java后端核心知识</title>
    <link href="http://blog.cuzz.site/2019/02/23/Java%E5%90%8E%E7%AB%AF%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86/"/>
    <id>http://blog.cuzz.site/2019/02/23/Java后端核心知识/</id>
    <published>2019-02-23T15:59:59.000Z</published>
    <updated>2019-04-21T15:15:47.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="剑指-Offer-题解"><a href="#剑指-Offer-题解" class="headerlink" title="剑指 Offer 题解"></a>剑指 Offer 题解</h3><h3 id="Leetcode-题解"><a href="#Leetcode-题解" class="headerlink" title="Leetcode 题解"></a>Leetcode 题解</h3><h3 id="算法-1"><a href="#算法-1" class="headerlink" title="算法"></a>算法</h3><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="计算机操作系统"><a href="#计算机操作系统" class="headerlink" title="计算机操作系统"></a>计算机操作系统</h3><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><ul><li><a href="https://hpbn.co/brief-history-of-http/" target="_blank" rel="noopener">Brief History of HTTP</a></li></ul><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><h3 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h3><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="数据库系统原理"><a href="#数据库系统原理" class="headerlink" title="数据库系统原理"></a>数据库系统原理</h3><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><h3 id="Leetcode-Database-题解"><a href="#Leetcode-Database-题解" class="headerlink" title="Leetcode-Database 题解"></a>Leetcode-Database 题解</h3><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li><a href="https://www.cnblogs.com/xdyixia/p/9066489.html" target="_blank" rel="noopener">MySQL数据类型及后面小括号的意义</a></li></ul><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><h3 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h3><ul><li><a href="https://github.com/javagrowing/JGrowing/blob/master/Java%E5%9F%BA%E7%A1%80/%E8%81%8A%E8%81%8A%E5%BC%95%E7%94%A8%E5%92%8CThreadlocal%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B.md" target="_blank" rel="noopener">聊聊引用和Threadlocal的那些事 </a></li></ul><h3 id="Java-容器"><a href="#Java-容器" class="headerlink" title="Java 容器"></a>Java 容器</h3><h3 id="Java-并发"><a href="#Java-并发" class="headerlink" title="Java 并发"></a>Java 并发</h3><ul><li><p><a href="http://www.importnew.com/18126.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></p></li><li><p><a href="https://juejin.im/post/5c0528fcf265da610f637b7d" target="_blank" rel="noopener">大白话聊聊Java并发面试问题之volatile到底是什么？</a></p></li><li><p><a href="https://juejin.im/post/5c062c87e51d451dbc21801b" target="_blank" rel="noopener">大白话聊聊Java并发面试问题之Java 8如何优化CAS性能？</a></p></li><li><p><a href="https://juejin.im/post/5c07e59cf265da617464a09c" target="_blank" rel="noopener">大白话聊聊Java并发面试问题之谈谈你对AQS的理解？</a></p></li><li><p><a href="https://juejin.im/post/5c091259f265da61171c86b4" target="_blank" rel="noopener">大白话聊聊Java并发面试问题之公平锁与非公平锁是啥？</a></p></li><li><p><a href="https://juejin.im/post/5c0c8540e51d451dbe4fdd83" target="_blank" rel="noopener">大白话聊聊Java并发面试问题之微服务注册中心的读写锁优化</a> </p></li></ul><h3 id="Java-虚拟机"><a href="#Java-虚拟机" class="headerlink" title="Java 虚拟机"></a>Java 虚拟机</h3><ul><li><a href="https://blog.csdn.net/jisuanjiguoba/article/details/80156781" target="_blank" rel="noopener"> JVM中的新生代和老年代（Eden空间、两个Survior空间） </a></li><li><a href="https://blog.csdn.net/scdn_cp/article/details/86491792" target="_blank" rel="noopener">Java对象结构与锁实现原理及MarkWord详解</a></li></ul><h3 id="Java-I-O"><a href="#Java-I-O" class="headerlink" title="Java I/O"></a>Java I/O</h3><ul><li><a href="https://www.ibm.com/developerworks/cn/education/java/j-nio/j-nio.html" target="_blank" rel="noopener">NIO 入门</a></li></ul><h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul><li><a href="https://segmentfault.com/a/1190000013341344" target="_blank" rel="noopener">Spring事务传播行为详解</a></li></ul><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><h3 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h3><ul><li><p><a href="https://medium.com/@xunnan.xu/its-all-about-buffers-zero-copy-mmap-and-java-nio-50f2a1bfc05c" target="_blank" rel="noopener">It’s all about buffers: zero-copy, mmap and Java NIO</a></p></li><li><p><a href="https://developer.ibm.com/articles/j-zerocopy/" target="_blank" rel="noopener">Efficient data transfer through zero copy</a></p></li><li><p><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">Scalable IO in Java </a></p></li><li><a href="https://www.jianshu.com/p/1ccbc6a348db" target="_blank" rel="noopener">Netty 那些事儿 ——— Reactor模式详解</a></li></ul><h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><h3 id="系统设计基础"><a href="#系统设计基础" class="headerlink" title="系统设计基础"></a>系统设计基础</h3><h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><h3 id="攻击技术"><a href="#攻击技术" class="headerlink" title="攻击技术"></a>攻击技术</h3><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;h3 id=&quot;剑指-Offer-题解&quot;&gt;&lt;a href=&quot;#剑指-Offer-题解&quot; class=&quot;headerlink&quot; title=&quot;剑指 
      
    
    </summary>
    
      <category term="知识图谱" scheme="http://blog.cuzz.site/categories/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/"/>
    
    
      <category term="博客" scheme="http://blog.cuzz.site/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>数据库</title>
    <link href="http://blog.cuzz.site/2019/02/22/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://blog.cuzz.site/2019/02/22/数据库/</id>
    <published>2019-02-22T15:59:59.000Z</published>
    <updated>2019-04-21T15:15:47.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库架构"><a href="#数据库架构" class="headerlink" title="数据库架构"></a>数据库架构</h2><p>数据库架构可以分为存储文件系统和程序实例两大块，而程序实例根据不同的功能又可以分为如下小模块。</p><p><img src="数据库\1550644570798.png" alt="1550644570798"></p><h2 id="索引模块"><a href="#索引模块" class="headerlink" title="索引模块"></a>索引模块</h2><p>常见的问题有：</p><ul><li>为什么要使用索引</li><li>什么样的信息能成为索引</li><li>索引的数据结构</li><li>密集索引和稀疏索引的区别</li></ul><h3 id="为什么要使用索引"><a href="#为什么要使用索引" class="headerlink" title="为什么要使用索引"></a>为什么要使用索引</h3><p>使用索引就像查字典一样，可以快速查询数据</p><h3 id="什么样的信息能成为索引"><a href="#什么样的信息能成为索引" class="headerlink" title="什么样的信息能成为索引"></a>什么样的信息能成为索引</h3><p>主键、唯一键以及普通键等</p><h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><ul><li>生成索引，建立二叉查找树进行二分查找</li><li>生成索引，建立 B Tree 结构结构进行查找</li><li>生成索引，建立 B+ Tree 结构进行查找</li><li>生成索引，建立 Hash 结构进行查找</li></ul><h4 id="什么是-B-Tree-索引？"><a href="#什么是-B-Tree-索引？" class="headerlink" title="什么是 B Tree 索引？"></a>什么是 B Tree 索引？</h4><p>B-Tree 是为磁盘等外存储设备设计的一种平衡查找树。因此在讲 B-Tree 之前先了解下磁盘的相关知识。</p><ul><li><p>系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</p></li><li><p>InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB 存储引擎中默认每个页的大小为 16 KB，可通过参数 innodb_page_size 将页的大小设置为 4K、8K、16K ，在 MySQL 中可通过如下命令查看页的大小：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like 'innodb_page_size';</span><br></pre></td></tr></table></figure></li><li><p>而系统一个磁盘块的存储空间往往没有这么大，因此 InnoDB 每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小 16KB 。InnoDB 在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘 I/O 次数，提高查询效率。</p></li></ul><p>B-Tree 结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组 [key, data] ，key 为记录的键值，对应表中的主键值，data 为一行记录中除主键外的数据。对于不同的记录，key值互不相同。</p><p>一棵 m 阶的 B-Tree 有如下特性：</p><ul><li>每个节点最多有 m 个孩子<ul><li>除了根节点和叶子节点外，其它每个节点至少有 Ceil(m/2) 个孩子</li><li>若根节点不是叶子节点，则至少有 2 个孩子</li></ul></li><li>所有叶子节点都在同一层，且不包含其它关键字信息</li><li>每个非叶子节点包含 n 个关键字信息（P0,P1,…Pn, k1,…kn）<ul><li>关键字的个数 n 满足：ceil(m/2)-1 &lt;= n &lt;= m-1</li><li>ki(i=1,…n) 为关键字，且关键字升序排序</li><li>Pi(i=0,…n) 为指向子树根节点的指针。P(i-1) 指向的子树的所有节点关键字均小于 ki ，但都大于 k(i-1) </li></ul></li></ul><p>B-Tree 中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个 3 阶的 B-Tree：</p><p><img src="数据库\84ea509fa091a10add4e7614e6cb37db" alt="B-Tree 的结构"></p><ul><li>每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的 key 和三个指向子树根节点的 point ，point 存储的是子节点所在磁盘块的地址。两个 key 划分成的三个范围域，对应三个 point 指向的子树的数据的范围域。</li><li>以根节点为例，key 为 17 和 35 ，P1 指针指向的子树的数据范围为小于 17 ，P2 指针指向的子树的数据范围为 [17~35] ，P3 指针指向的子树的数据范围为大于 35 。</li></ul><p>模拟查找 key 为 29 的过程：</p><ul><li>1、根据根节点找到磁盘块 1 ，读入内存。【磁盘I/O操作第1次】</li><li>2、比较 key 29 在区间（17,35），找到磁盘块 1 的指针 P2 。</li><li>3、根据 P2 指针找到磁盘块 3 ，读入内存。【磁盘I/O操作第2次】</li><li>4、比较 key 29 在区间（26,30），找到磁盘块3的指针P2。</li><li>5、根据 P2 指针找到磁盘块 8 ，读入内存。【磁盘I/O操作第3次】</li><li>6、在磁盘块 8 中的 key 列表中找到 eky 29 。</li></ul><p>分析上面过程，发现需要 3 次磁盘 I/O 操作，和 3 次内存查找操作。由于内存中的 key 是一个有序表结构，可以利用二分法查找提高效率。而 3 次磁盘 I/O 操作是影响整个 B-Tree 查找效率的决定因素。B-Tree 相对于 AVLTree 缩减了节点个数，使每次磁盘 I/O 取到内存的数据都发挥了作用，从而提高了查询效率。</p><h4 id="什么是-B-Tree-索引？-1"><a href="#什么是-B-Tree-索引？-1" class="headerlink" title="什么是 B+Tree 索引？"></a>什么是 B+Tree 索引？</h4><p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用 B+Tree 实现其索引结构。</p><p>从上一节中的 B-Tree 结构图中可以看到，每个节点中不仅包含数据的 key 值，还有 data 值。而每一个页的存储空间是有限的，如果 data 数据较大时将会导致每个节点（即一个页）能存储的 key 的数量很小，当存储的数据量很大时同样会导致 B-Tree 的深度较大，增大查询时的磁盘 I/O 次数，进而影响查询效率。在 B+Tree 中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储 key 值信息，这样可以大大加大每个节点存储的 key 值数量，降低 B+Tree 的高度。</p><p>B+Tree 相对于 B-Tree 有几点不同：</p><ul><li>非叶子节点只存储键值信息。</li><li>所有叶子节点之间都有一个链指针。</li><li>数据记录都存放在叶子节点中。</li></ul><p><strong>B+ Tree 更适合用来做存储索引</strong>：</p><ul><li>B+ 数的磁盘读写代价更低</li><li>B+ 数的查询效率更加稳定</li><li>B+ 数更有利于对数据库的扫描（范围查询）</li></ul><p>将上一节中的 B-Tree 优化，由于 B+Tree 的非叶子节点只存储键值信息，假设每个磁盘块能存储 4 个键值及指针信息，则变成 B+Tree 后其结构如下图所示：</p><p><img src="数据库\259d196856a231aff5e3cf1505848af4" alt="B+Tree 的结构"></p><blockquote><p>磁盘块4中的10数据，画错了，范围在[K[i], K[i+1])，左闭右开</p></blockquote><ul><li>通常在 B+Tree 上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对 B+Tree 进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。</li></ul><p>可能上面例子中只有 22 条数据记录，看不出 B+Tree 的优点，下面做一个推算：</p><ul><li>InnoDB 存储引擎中页的大小为 16KB，一般表的主键类型为 INT（占用4个字节） 或 BIGINT（占用8个字节），指针类型也一般为 4 或 8 个字节，也就是说一个页（B+Tree 中的一个节点）中大概存储 16KB/(8B+8B)=1K 个键值（因为是估值，为方便计算，这里的 K 取值为〖10〗^3）。也就是说一个深度为 3 的 B+Tree 索引可以维护10^3 <em>10^3</em> 10^3 = 10亿 条记录。</li><li>实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree 的高度一般都在 2~4 层。MySQL 的 InnoDB 存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要 1~3 次磁盘 I/O 操作。</li></ul><h4 id="什么是-hash-索引？"><a href="#什么是-hash-索引？" class="headerlink" title="什么是 hash 索引？"></a>什么是 hash 索引？</h4><p>基于哈希表实现，优点是查找非常快。如下图 ：</p><p><img src="数据库\20190107191452541898.png" alt="20190107191452541898"></p><p>哈希索引就是采用一定的哈希算法，将键值换算成新的哈希值，检索时不需要想B+Tree那样从根结点开始查找，而是经过计算直接定位，所以速度很快。</p><p>但是也有限制：</p><ul><li>只支持精确查找，不能用于部分查找和范围查找。无法排序和分组。因为原来有序的键值经过哈希算法很可能打乱。</li><li>如果哈希冲突很多，查找速度很慢。比如在有大量重复键值的情况下。</li><li>不能利用部分索引查询</li><li>不能</li></ul><h3 id="聚集索引与非聚集索引"><a href="#聚集索引与非聚集索引" class="headerlink" title="聚集索引与非聚集索引"></a>聚集索引与非聚集索引</h3><p><img src="数据库\1550731169166.png" alt="1550731169166"></p><h3 id="MyISAM-索引与-InnoDB-索引的区别？"><a href="#MyISAM-索引与-InnoDB-索引的区别？" class="headerlink" title="MyISAM 索引与 InnoDB 索引的区别？"></a>MyISAM 索引与 InnoDB 索引的区别？</h3><ul><li>InnoDB 索引是聚簇索引，MyISAM 索引是非聚簇索引。</li><li>InnoDB 的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li><li>MyISAM 索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li><li>InnoDB 非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效</li></ul><h3 id="如何定位并优化慢查询的-Sql"><a href="#如何定位并优化慢查询的-Sql" class="headerlink" title="如何定位并优化慢查询的 Sql"></a>如何定位并优化慢查询的 Sql</h3><p>需要具体场景具体分析，其大致思路</p><ul><li>根据慢日志定位到慢查询的 sql</li><li>使用 explain 等工具分析 sql</li><li>修改 sql 或者尽量让 sql 走索引</li></ul><h4 id="定位慢查询sql"><a href="#定位慢查询sql" class="headerlink" title="定位慢查询sql"></a>定位慢查询sql</h4><p>开启慢查询日志即可 </p><p>文件方式配置 MySQL 慢查询的方法：</p><ul><li>查询 MySQL 慢查询状态的方法： </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">'%query%'</span>;</span><br></pre></td></tr></table></figure><ul><li>在 mysql 配置文件 my.cnf 中增加： </li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log-slow-queries=/opt/data/slowquery.log</span><br><span class="line">long_query_time=2 </span><br><span class="line">log-queries-not-using-indexes</span><br></pre></td></tr></table></figure><ul><li>命令方式配置 MySQL 慢查询的方法：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="keyword">on</span>; </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log_file=‘/opt/<span class="keyword">data</span>/slow_query.log’;</span><br></pre></td></tr></table></figure><ul><li>解析 MySQL 慢查询日志的方法，按照 sql 执行时间最长的前 20 条 sql：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldumpslow -s t -t 20 -g &apos;select&apos; /opt/data/slowquery.log</span><br></pre></td></tr></table></figure><p>在 log 中就能找到慢查询的 sql。</p><h4 id="Explian-关键字"><a href="#Explian-关键字" class="headerlink" title="Explian 关键字"></a>Explian 关键字</h4><ul><li><p>Explain命令在解决数据库性能上是第一推荐使用命令，大部分的性能问题可以通过此命令来简单的解决，Explain可以用来查看SQL语句的执行效 果，可以帮助选择更好的索引和优化查询语句，写出更好的优化语句。</p><p>Explain语法：explain select … from … [where …]</p><p>例如：explain select * from news;</p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+----+-------------+-------+-------+-------------------+---------+---------+-------+------</span><br><span class="line">| id | select_type | table | type  | possible_keys | key | key_len | ref | rows | Extra |</span><br><span class="line">+----+-------------+-------+-------+-------------------+---------+---------+-------+------</span><br></pre></td></tr></table></figure><p>下面对各个属性进行了解：</p><p>1、id：这是SELECT的查询序列号</p><p>2、select_type：select_type就是select的类型，可以有以下几种：</p><blockquote><p>SIMPLE：简单SELECT(不使用UNION或子查询等)</p><p>PRIMARY：最外面的SELECT</p><p>UNION：UNION中的第二个或后面的SELECT语句</p><p>DEPENDENT UNION：UNION中的第二个或后面的SELECT语句，取决于外面的查询</p><p>UNION RESULT：UNION的结果。</p><p>SUBQUERY：子查询中的第一个SELECT</p><p>DEPENDENT SUBQUERY：子查询中的第一个SELECT，取决于外面的查询</p><p>DERIVED：导出表的SELECT(FROM子句的子查询)</p></blockquote><p>3、table：显示这一行的数据是关于哪张表的</p><p>4、type：这列最重要，显示了连接使用了哪种类别,有无使用索引，是使用Explain命令分析性能瓶颈的关键项之一。</p><blockquote><p>结果值从好到坏依次是：</p><p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p><p>一般来说，得保证查询至少达到range级别，最好能达到ref，否则就可能会出现性能问题。</p></blockquote><p>5、possible_keys：列指出MySQL能使用哪个索引在该表中找到行</p><p>6、key：显示MySQL实际决定使用的键（索引）。如果没有选择索引，键是NULL</p><p>7、key_len：显示MySQL决定使用的键长度。如果键是NULL，则长度为NULL。使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p>8、ref：显示使用哪个列或常数与key一起从表中选择行。</p><p>9、rows：显示MySQL认为它执行查询时必须检查的行数。</p><p>10、Extra：包含MySQL解决查询的详细信息，也是关键参考项之一。</p><blockquote><p>Distinct<br>一旦MYSQL找到了与行相联合匹配的行，就不再搜索了</p><p>Not exists<br>MYSQL 优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，</p><p>就不再搜索了</p><p>Range checked for each</p><p>Record（index map:#）<br>没有找到理想的索引，因此对于从前面表中来的每一 个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一</p><p>Using filesort<br>看 到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来 排序全部行</p><p>Using index<br>列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表 的全部的请求列都是同一个索引的部分的时候</p><p>Using temporary<br>看到这个的时候，查询需要优化了。这 里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上</p><p>Using where<br>使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index， 这就会发生，或者是查询有问题</p></blockquote><p>其他一些Tip：</p><p>当type 显示为 “index” 时，并且Extra显示为 “Using Index”， 表明使用了覆盖索引。</p></li></ul><h3 id="联合索引的最左匹配原则的成因"><a href="#联合索引的最左匹配原则的成因" class="headerlink" title="联合索引的最左匹配原则的成因"></a>联合索引的最左匹配原则的成因</h3><p>看看如下博客即可</p><ul><li><a href="https://www.jianshu.com/p/b7911e0394b0" target="_blank" rel="noopener">联合索引的最左前缀匹配原则</a></li><li><a href="https://www.zhihu.com/question/36996520/answer/93256153" target="_blank" rel="noopener">mysql索引最左匹配原则的理解?</a></li></ul><h3 id="索引是建立得越多越好的吗"><a href="#索引是建立得越多越好的吗" class="headerlink" title="索引是建立得越多越好的吗"></a>索引是建立得越多越好的吗</h3><ul><li>数据量小的表不需要建立索引，建立会增加额外的索引开销</li><li>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</li><li>更多的索引意味着也需要更多的空间</li></ul><h2 id="锁模块"><a href="#锁模块" class="headerlink" title="锁模块"></a>锁模块</h2><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>MyISAM 与 InnoDB 关于锁方面的区别是什么</li><li>数据库事务的四大特性</li><li>事务隔离级别以及各级别下的并发访问问题</li><li>InnoDB 可重复读隔离级别下如何避免幻读</li><li>RC、RR 级别下的 InnoDB 的非堵塞如果实现</li></ul><h3 id="MyISAM-与-InnoDB-关于锁方面的区别是什么"><a href="#MyISAM-与-InnoDB-关于锁方面的区别是什么" class="headerlink" title="MyISAM 与 InnoDB 关于锁方面的区别是什么"></a>MyISAM 与 InnoDB 关于锁方面的区别是什么</h3><ul><li>MyISAM 默认用的是表级锁，不支持行级锁</li><li>InnoDB 默认用的是行级锁，也支持表级锁</li></ul><h3 id="数据库锁的分类"><a href="#数据库锁的分类" class="headerlink" title="数据库锁的分类"></a>数据库锁的分类</h3><ul><li>按锁的粒度划分，可分为表级锁、行级锁和页级锁</li><li>按锁的级别划分，可分为共享锁和排他锁</li><li>按加锁的方式划分，可分为自动锁和显示锁</li><li>按操作划分，可分为 DML 锁和 DDL 锁</li><li>按使用方式划分，可分为乐观锁和悲观锁</li></ul><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><h4 id="1-原子性（Atomicity）"><a href="#1-原子性（Atomicity）" class="headerlink" title="1. 原子性（Atomicity）"></a>1. 原子性（Atomicity）</h4><p>事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。</p><p>回滚可以用回滚日志来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</p><h4 id="2-一致性（Consistency）"><a href="#2-一致性（Consistency）" class="headerlink" title="2. 一致性（Consistency）"></a>2. 一致性（Consistency）</h4><p>数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</p><h4 id="3-隔离性（Isolation）"><a href="#3-隔离性（Isolation）" class="headerlink" title="3. 隔离性（Isolation）"></a>3. 隔离性（Isolation）</h4><p>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</p><h4 id="4-持久性（Durability）"><a href="#4-持久性（Durability）" class="headerlink" title="4. 持久性（Durability）"></a>4. 持久性（Durability）</h4><p>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</p><p>使用重做日志来保证持久性。</p><h3 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h3><p>在并发环境下，事务的隔离性很难保证，因此会出现很多并发一致性问题。</p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。</p><p><img src="数据库\26a7c9df-22f6-4df4-845a-745c053ab2e5.jpg" alt="26a7c9df-22f6-4df4-845a-745c053ab2e5"></p><h4 id="读脏数据"><a href="#读脏数据" class="headerlink" title="读脏数据"></a>读脏数据</h4><p>T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是脏数据。</p><p><img src="数据库\bab0fba6-38e4-45f7-b34d-3edaad43810f.jpg" alt="bab0fba6-38e4-45f7-b34d-3edaad43810f"></p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><p><img src="数据库\43bf0957-0386-4c09-9ad7-e163c5b62559.jpg" alt="43bf0957-0386-4c09-9ad7-e163c5b62559"></p><h4 id="幻影读"><a href="#幻影读" class="headerlink" title="幻影读"></a>幻影读</h4><p>T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><p><img src="数据库\2959e455-e6cb-4461-aeb3-e319fe5c41db.jpg" alt="2959e455-e6cb-4461-aeb3-e319fe5c41db"></p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><h4 id="未提交读（READ-UNCOMMITTED）"><a href="#未提交读（READ-UNCOMMITTED）" class="headerlink" title="未提交读（READ UNCOMMITTED）"></a>未提交读（READ UNCOMMITTED）</h4><p>事务中的修改，即使没有提交，对其它事务也是可见的。</p><h4 id="提交读（READ-COMMITTED）"><a href="#提交读（READ-COMMITTED）" class="headerlink" title="提交读（READ COMMITTED）"></a>提交读（READ COMMITTED）</h4><p>一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。</p><h4 id="可重复读（REPEATABLE-READ）"><a href="#可重复读（REPEATABLE-READ）" class="headerlink" title="可重复读（REPEATABLE READ）"></a>可重复读（REPEATABLE READ）</h4><p>保证在同一个事务中多次读取同样数据的结果是一样的。</p><h4 id="可串行化（SERIALIZABLE）"><a href="#可串行化（SERIALIZABLE）" class="headerlink" title="可串行化（SERIALIZABLE）"></a>可串行化（SERIALIZABLE）</h4><p>强制事务串行执行。</p><hr><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻影读</th><th style="text-align:center">加锁读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">提交读</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">可重复读</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">×</td></tr><tr><td style="text-align:center">可串行化</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr></tbody></table><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener">数据库系统原理 </a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据库架构&quot;&gt;&lt;a href=&quot;#数据库架构&quot; class=&quot;headerlink&quot; title=&quot;数据库架构&quot;&gt;&lt;/a&gt;数据库架构&lt;/h2&gt;&lt;p&gt;数据库架构可以分为存储文件系统和程序实例两大块，而程序实例根据不同的功能又可以分为如下小模块。&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
      <category term="面试" scheme="http://blog.cuzz.site/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="数据库" scheme="http://blog.cuzz.site/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="http://blog.cuzz.site/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://blog.cuzz.site/2019/02/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    <id>http://blog.cuzz.site/2019/02/19/计算机网络/</id>
    <published>2019-02-19T15:59:59.000Z</published>
    <updated>2019-04-21T15:15:47.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><p><img src="计算机网络\7fa66f48-bc42-4b98-93c2-56b20feaa990.png" alt="img"></p><h3 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h3><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h3 id="五层协议"><a href="#五层协议" class="headerlink" title="五层协议"></a>五层协议</h3><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li><strong>传输层</strong> ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><img src="计算机网络\7048a730-a2d0-43d1-99ce-f774e4ef1b27.png" alt="img"></p><p>TCP/IP 是 Internet上的标准通信协议集，该协议集由数十个具有层次结构的协议组成，其中 TCP 和 IP 是该协议集中的两个最重要的核心协议。TCP/IP协议族按层次可分为以下四层：应用层、传输层、网络层和网络接口层，各层对应的 PDU 数据单元的名称如下图所示。 </p><p><img src="计算机网络\TCPIP与PSU.png" alt="TCPIP与PSU"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>OSI 七层体系结构具有概念清楚、理论完整的特点，是一个理论上的国际标准，但却不是事实上的国际标准；而具有简单易用特点的 TCP/IP 四层体系结构则是事实上的标准。 需要指出的是，五层体系结构虽然综合了 OSI 和 TCP/IP 的优点，但其只是为了学术学习研究而提出的，没有具体的实际意义。</p><h2 id="说说-TCP-的三次握手"><a href="#说说-TCP-的三次握手" class="headerlink" title="说说 TCP 的三次握手"></a>说说 TCP 的三次握手</h2><p>这一到很常见的面试题。</p><h3 id="传输控制协议-TCP-简介"><a href="#传输控制协议-TCP-简介" class="headerlink" title="传输控制协议 TCP 简介"></a>传输控制协议 TCP 简介</h3><ul><li>面向连接的、可靠的基于字节流的传输层通信协议</li><li>将应用层的数据流分割成报文段并发送给目标节点的 TCP 层</li><li>数据包都是由序号，对方收到则发送 ACK 确认，未收到则重传</li><li>使用校验和来检验数据在传输过程中是否有误</li></ul><h3 id="TCP-报文头"><a href="#TCP-报文头" class="headerlink" title="TCP 报文头"></a>TCP 报文头</h3><p><img src="计算机网络\MJB-TCP-Header-800x564.png" alt="MJB-TCP-Header-800x564"></p><ul><li><strong>源端口、目的端口</strong> ：标记进程。</li><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>连接标志（TCP Flags）</strong>：表示控制功能，下面是常见的连接标志。<ul><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=a1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li></ul></li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ul><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p><img src="计算机网络\timg.jpg" alt="timg"></p><p>在 TCP/IP 协议中， TCP 协议提供可靠的连接服务，采用三次握手建立一个连接。</p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><h3 id="对于建链接的3次握手"><a href="#对于建链接的3次握手" class="headerlink" title="对于建链接的3次握手"></a>对于建链接的3次握手</h3><p>主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p><h3 id="关于建连接时SYN超时"><a href="#关于建连接时SYN超时" class="headerlink" title="关于建连接时SYN超时"></a>关于建连接时SYN超时</h3><p>试想一下，如果server端接到了 client 发的 SYN 后回了 SYN-ACK 后 client 掉线了，server 端没有收到 client 回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server 端如果在一定时间内没有收到的TCP会重发 SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从 1s 开始每次都翻售，5 次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</p><h3 id="关于SYN-Flood攻击"><a href="#关于SYN-Flood攻击" class="headerlink" title="关于SYN Flood攻击"></a>关于SYN Flood攻击</h3><p>一些恶意的人就为此制造了SYN Flood攻击，给服务器发了一个SYN后，就下线了，于是服务器需要默认等 63s 才会断开连接，这样，攻击者就可以把服务器的 syn 连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫 <strong>tcp_syncookies</strong> 的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。</p><p>请注意，<strong>请先千万别用 tcp_syncookies 来处理正常的大负载的连接的情况</strong>。因为，synccookies 是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择。</p><ul><li>第一个是：tcp_synack_retries 可以用他来减少重试次数；</li><li>第二个是：tcp_max_syn_backlog，可以增大SYN连接数；</li><li>第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了 ；</li></ul><h3 id="保活机制"><a href="#保活机制" class="headerlink" title="保活机制"></a>保活机制</h3><ul><li>向对方发送保活探测报文，如果未收到响应则继续发送</li><li>尝试次数达到保活探测数仍然未收到响应则中断连接</li></ul><h2 id="谈谈四次挥手"><a href="#谈谈四次挥手" class="headerlink" title="谈谈四次挥手"></a>谈谈四次挥手</h2><p><img src="计算机网络\tisfsmg.jpg" alt="tisfsmg"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放报文，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h3 id="四次挥手的原因"><a href="#四次挥手的原因" class="headerlink" title="四次挥手的原因"></a>四次挥手的原因</h3><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><p>TCP连接是全双工的，服务端可以发送数据到客户端，客户端也可以发送数据到服务端，发送方和接收方都需要两次挥手才能关闭 。</p><h3 id="TIME-WAIT"><a href="#TIME-WAIT" class="headerlink" title="TIME_WAIT"></a>TIME_WAIT</h3><p>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li>确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</li></ul><h2 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h2><p>前面我们说了 TCP 现在我们来认识一下 UDP。</p><h3 id="UPD-的特点"><a href="#UPD-的特点" class="headerlink" title="UPD 的特点"></a>UPD 的特点</h3><ul><li>面向非连接的</li><li>不维护连接状态，支持同时向多个客户端传输相同的消息</li><li>数据包报头只有 8 个字节，额外开销较小</li><li>吞吐量只受限于数据生成率、传输速率以及机器性能</li><li>尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表</li><li>面向报文，不对应用程序提交的报文信息进行拆分或则合并</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li>TCP 是面向连接的；UDP 是无连接的。</li><li>TCP 是可靠的；UDP 是不可靠的。</li><li>TCP 只支持点对点通信；UDP 支持一对一、一对多、多对一、多对多的通信模式。</li><li>TCP 是面向字节流的；UDP 是面向报文的。</li><li>TCP 有拥塞控制机制；UDP 没有拥塞控制，适合媒体通信。</li><li>TCP 首部开销(20 个字节)，比 UDP 的首部开销(8 个字节)要大。</li></ul><h2 id="TCP-的滑动窗口"><a href="#TCP-的滑动窗口" class="headerlink" title="TCP 的滑动窗口"></a>TCP 的滑动窗口</h2><p>首先明确：</p><p>TCP滑动窗口分为接受窗口，发送窗口。</p><p>滑动窗口协议是<strong>传输层进行流控</strong>的一种措施，<strong>接收方通过通告发送方自己的窗口大小</strong>，从而控制发送方的发送速度，从而达到防止发送方发送速度过快而导致自己被淹没的目的。</p><h3 id="重要概念"><a href="#重要概念" class="headerlink" title="重要概念"></a>重要概念</h3><p>对ACK的再认识，ack通常被理解为收到数据后给出的一个确认ACK，ACK包含两个非常重要的信息：</p><ul><li>一是期望接收到的下一字节的序号n，该n代表接收方已经接收到了前n-1字节数据，此时如果接收方收到第n+1字节数据而不是第n字节数据，接收方是不会发送序号为n+2的ACK的。举个例子，假如接收端收到1-1024字节，它会发送一个确认号为1025的ACK,但是接下来收到的是2049-3072，它是不会发送确认号为3072的ACK,而依旧发送1025的ACK。</li><li>二是当前的窗口大小m，如此发送方在接收到ACK包含的这两个数据后就可以计算出还可以发送多少字节的数据给对方，假定当前发送方已发送到第x字节，则可以发送的字节数就是y=m-(x-n).这就是滑动窗口控制流量的基本原理</li></ul><p><strong>重点：发送方根据收到ACK当中的期望收到的下一个字节的序号n以及窗口m，还有当前已经发送的字节序号x，算出还可以发送的字节数。</strong></p><p>发送端窗口的第一个字节序号一定是ACK中期望收到的下一个字节序号，比如下图：</p><p><img src="计算机网络\9c21786770459afa47bfa2e4606cc454_hd.jpg" alt="img">  </p><p>上图52 53 54 55 字节都是可以新发送的字节序。   </p><p>接受端窗口的第一个字节序之前一定是已经完全接收的，后面窗口里面的数据都是希望接受的，窗口后面的数据都是不希望接受的。 </p><p>TCP的滑动窗口分为接收窗口和发送窗口 不分析这两种窗口就讨论是不妥当的。  TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。TCP 段中窗口的相关字段。 </p><p><img src="计算机网络\d6b970fb6d44aafeeec4a4c9d61a9225_hd.jpg" alt="img"></p><p>TCP的Window是一个16bit位字段，它代表的是窗口的字节容量，也就是TCP的标准窗口最大为2^16-1=65535个字节。</p><p>另外在TCP的选项字段中还包含了一个TCP窗口扩大因子，option-kind为3，option-length为3个字节，option-data取值范围0-14。窗口扩大因子用来扩大TCP窗口，可把原来16bit的窗口，扩大为31bit。</p><h3 id="滑动窗口基本原理"><a href="#滑动窗口基本原理" class="headerlink" title="滑动窗口基本原理"></a>滑动窗口基本原理</h3><p>对于TCP会话的发送方，任何时候在其发送缓存内的数据都可以分为4类，“已经发送并得到对端ACK的”，“已经发送但还未收到对端ACK的”，“未发送但对端允许发送的”，“未发送且对端不允许发送”。“已经发送但还未收到对端ACK的”和“未发送但对端允许发送的”这两部分数据称之为发送窗口。</p><p><img src="计算机网络\a1d5c050ad957880094a5f003b1ccd24_hd.jpg" alt="img"></p><p> 当收到接收方新的ACK对于发送窗口中后续字节的确认是，窗口滑动，滑动原理如下图。 </p><p><img src="计算机网络\9c21786770459afa47bfa2e4606cc454_hd.jpg" alt="img"></p><p>当收到ACK=36时窗口滑动。</p><p>2）对于TCP的接收方，在某一时刻在它的接收缓存内存在3种。“已接收”，“未接收准备接收”，“未接收并未准备接收”（由于ACK直接由TCP协议栈回复，默认无应用延迟，不存在“已接收未回复ACK”）。其中“未接收准备接收”称之为接收窗口。</p><h3 id="发送窗口与接收窗口关系"><a href="#发送窗口与接收窗口关系" class="headerlink" title="发送窗口与接收窗口关系"></a>发送窗口与接收窗口关系</h3><p>TCP是双工的协议，会话的双方都可以同时接收、发送数据。TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的“发送窗口”则要求取决于对端通告的“接收窗口”，要求相同。</p><p><img src="计算机网络\c798dd393fcf7c03b1db78f5bcf0304b_hd.jpg" alt="img"></p><h3 id="滑动窗口实现面向流的可靠性"><a href="#滑动窗口实现面向流的可靠性" class="headerlink" title="滑动窗口实现面向流的可靠性"></a>滑动窗口实现面向流的可靠性</h3><ul><li>最基本的传输可靠性来源于“确认重传”机制。</li><li>TCP的滑动窗口的可靠性也是建立在“确认重传”基础上的。</li><li>发送窗口只有收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。</li><li>接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。</li></ul><h3 id="滑动窗口的流控特性"><a href="#滑动窗口的流控特性" class="headerlink" title="滑动窗口的流控特性"></a>滑动窗口的流控特性</h3><p>TCP的滑动窗口是动态的，我们可以想象成小学常见的一个数学题，一个水池，体积V，每小时进水量V1，出水量V2。当水池满了就不允许再注入了，如果有个液压系统控制水池大小，那么就可以控制水的注入速率和量。这样的水池就类似TCP的窗口。应用根据自身的处理能力变化，通过本端TCP接收窗口大小控制来对对对端的发送窗口流量限制。</p><p>应用程序在需要（如内存不足）时，通过API通知TCP协议栈缩小TCP的接收窗口。然后TCP协议栈在下个段发送时包含新的窗口大小通知给对端，对端按通知的窗口来改变发送窗口，以此达到减缓发送速率的目的。</p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>HTTP 协议，是 Hyper Text Transfer Protocol（超文本传输协议）的缩写，是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>主要特点如下：</p><ul><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有 GET、HEAD、POST 等等。每种方法规定了客户与服务器联系的类型不同。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li><li>数据格式灵活：HTTP 允许传输任意类型的数据对象。正在传输的类型由Content-Type 加以标记。</li><li>无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP 协议是无状态协议。无状态，是指协议对于事务处理没有记忆能力。无状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li><li>支持 B/S 及 C/S 模式。</li></ul><h3 id="GET-和-POST-区别"><a href="#GET-和-POST-区别" class="headerlink" title="GET 和 POST 区别"></a>GET 和 POST 区别</h3><p>从三个层面来解答：</p><ul><li>Http 报文层面：GET 将请求信息放在 URL中，POST 方法报文中</li><li>数据库层面：GET 符合幂等性和安全性，POST 不符合</li><li>其他层面：GET 可以被缓存、被存储（书签），而 POST 不行</li></ul><h3 id="Cookie-和-Session-的区别"><a href="#Cookie-和-Session-的区别" class="headerlink" title="Cookie 和 Session 的区别"></a>Cookie 和 Session 的区别</h3><p><strong>Cookie 简介：</strong></p><ul><li>是由服务器发给客户端的特殊信息，以文本的形式存放在客户端</li><li>客户端再次请求的时候，会把 Cookie 回发给服务端</li><li>服务器接收到后，会解析 Cookie 生成与客户端相对的内容</li></ul><p><strong>Cookiet 的设置以及发送过程：</strong></p><p><img src="计算机网络\tisdfsdfrgremg.jpg" alt="tisdfsdfrgremg"></p><p><strong>Session 简介：</strong></p><ul><li>服务端的机制，在服务端保存的信息</li><li>解析客户端请求并操作 Session id ，按需保存状态信息</li></ul><p><strong>Session 的实现方式：</strong></p><ul><li>使用 Cookie 来实现</li><li>使用 URL 回写来实现，每次在 URL 添加 Session id 信息</li></ul><p><strong>区别</strong>：</p><ul><li>Cookie 数据存放在客户端的浏览器上，Session 数据存放在服务器上</li><li>Session 相对于 Cookie 更安全</li><li>若考虑减轻服务器负担，应当使用 Cookie</li></ul><h3 id="HTTP-和-HTTPs-的区别"><a href="#HTTP-和-HTTPs-的区别" class="headerlink" title="HTTP 和 HTTPs 的区别"></a>HTTP 和 HTTPs 的区别</h3><p><img src="计算机网络\1550579240583.png" alt="1550579240583"></p><h4 id="SSL-Security-Sockets-Layer-安全套接层"><a href="#SSL-Security-Sockets-Layer-安全套接层" class="headerlink" title="SSL (Security Sockets Layer) 安全套接层"></a>SSL (Security Sockets Layer) 安全套接层</h4><ul><li>为网络通信提供安全及数据完整性的一种安全协议</li><li>是操作系统对外的 API，SSL 3.0 更名为 TLS</li><li>采用身份验证和数据加密来保证网络的通信的安全和数据的完整性</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>HTTPS 需要到 CA 申请证书，HTTP 不需要</li><li>HTTPS 密文传输，HTTP 明文传输</li><li>连接方式不同，HTTPS 默认使用 443 端口，HTTP 使用 80 端口</li><li>HTTPS = HTTP + 加密 + 认证 + 完整性保护，较 HTTP 安全</li></ul><h3 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h3><ul><li>一 、基础概念<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#uri" target="_blank" rel="noopener">URI</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87" target="_blank" rel="noopener">请求和响应报文</a></li></ul></li><li>二、HTTP 方法<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#get" target="_blank" rel="noopener">GET</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#head" target="_blank" rel="noopener">HEAD</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#post" target="_blank" rel="noopener">POST</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#put" target="_blank" rel="noopener">PUT</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#patch" target="_blank" rel="noopener">PATCH</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#delete" target="_blank" rel="noopener">DELETE</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#options" target="_blank" rel="noopener">OPTIONS</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#connect" target="_blank" rel="noopener">CONNECT</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#trace" target="_blank" rel="noopener">TRACE</a></li></ul></li><li>三、HTTP 状态码<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#1xx-%E4%BF%A1%E6%81%AF" target="_blank" rel="noopener">1XX 信息</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#2xx-%E6%88%90%E5%8A%9F" target="_blank" rel="noopener">2XX 成功</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#3xx-%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">3XX 重定向</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#4xx-%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%94%99%E8%AF%AF" target="_blank" rel="noopener">4XX 客户端错误</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#5xx-%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%94%99%E8%AF%AF" target="_blank" rel="noopener">5XX 服务器错误</a></li></ul></li><li>四、HTTP 首部<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E9%80%9A%E7%94%A8%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">通用首部字段</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E8%AF%B7%E6%B1%82%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">请求首部字段</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%93%8D%E5%BA%94%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">响应首部字段</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%AE%9E%E4%BD%93%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener">实体首部字段</a></li></ul></li><li>五、具体应用<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">连接管理</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#cookie" target="_blank" rel="noopener">Cookie</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">缓存</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%86%85%E5%AE%B9%E5%8D%8F%E5%95%86" target="_blank" rel="noopener">内容协商</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%86%85%E5%AE%B9%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">内容编码</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E8%8C%83%E5%9B%B4%E8%AF%B7%E6%B1%82" target="_blank" rel="noopener">范围请求</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E7%BC%96%E7%A0%81" target="_blank" rel="noopener">分块传输编码</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%A4%9A%E9%83%A8%E5%88%86%E5%AF%B9%E8%B1%A1%E9%9B%86%E5%90%88" target="_blank" rel="noopener">多部分对象集合</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA" target="_blank" rel="noopener">虚拟主机</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E9%80%9A%E4%BF%A1%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91" target="_blank" rel="noopener">通信数据转发</a></li></ul></li><li>六、HTTPs<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%8A%A0%E5%AF%86" target="_blank" rel="noopener">加密</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E8%AE%A4%E8%AF%81" target="_blank" rel="noopener">认证</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%AE%8C%E6%95%B4%E6%80%A7%E4%BF%9D%E6%8A%A4" target="_blank" rel="noopener">完整性保护</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#https-%E7%9A%84%E7%BC%BA%E7%82%B9" target="_blank" rel="noopener">HTTPs 的缺点</a></li></ul></li><li>七、HTTP/2.0<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#http1x-%E7%BC%BA%E9%99%B7" target="_blank" rel="noopener">HTTP/1.x 缺陷</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7%E5%B1%82" target="_blank" rel="noopener">二进制分帧层</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%8E%A8%E9%80%81" target="_blank" rel="noopener">服务端推送</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E9%A6%96%E9%83%A8%E5%8E%8B%E7%BC%A9" target="_blank" rel="noopener">首部压缩</a></li></ul></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%85%ABhttp11-%E6%96%B0%E7%89%B9%E6%80%A7" target="_blank" rel="noopener">八、HTTP/1.1 新特性</a></li><li>九、GET 和 POST 比较<ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener">作用</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%8F%82%E6%95%B0" target="_blank" rel="noopener">参数</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%AE%89%E5%85%A8" target="_blank" rel="noopener">安全</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%B9%82%E7%AD%89%E6%80%A7" target="_blank" rel="noopener">幂等性</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#%E5%8F%AF%E7%BC%93%E5%AD%98" target="_blank" rel="noopener">可缓存</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/HTTP.md#xmlhttprequest" target="_blank" rel="noopener">XMLHttpRequest</a></li></ul></li></ul><h2 id="浏览器输入地址回车后发生的事情"><a href="#浏览器输入地址回车后发生的事情" class="headerlink" title="浏览器输入地址回车后发生的事情"></a>浏览器输入地址回车后发生的事情</h2><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><h2 id="Socket-通信"><a href="#Socket-通信" class="headerlink" title="Socket 通信"></a>Socket 通信</h2><p>TCP/IP（Transmission Control Protocol/Internet Protocol）即传输控制协议/网间协议，是一个工业标准的协议集，它是为广域网（WANs）设计的。UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是属于 TCP/IP 协议族中的一种。 这里有一张图，表明了这些协议的关系。 </p><p><img src="计算机网络\socket1.jpg" alt="img"><br>TCP/IP协议族包括运输层、网络层、链路层。现在你知道TCP/IP与UDP的关系了吧。</p><p><strong>Socket在哪里呢？ </strong></p><p>上图我们没有看到 Socket 的影子，那么它到底在哪里呢？还是用图来说话，一目了然。</p><p><img src="计算机网络\socket2.jpg" alt="img"></p><p><strong>Socket 是什么呢？</strong></p><p>Socket 是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket 其实就是一个门面模式，它把复杂的 TCP/IP 协议族隐藏在 Socket 接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。</p><h3 id="Socket-通信原理"><a href="#Socket-通信原理" class="headerlink" title="Socket 通信原理"></a>Socket 通信原理</h3><p><img src="计算机网络\socket3.jpg" alt="img"></p><p>先从服务器端说起。服务器端先初始化Socket，然后与端口绑定(bind)，对端口进行监听(listen)，调用accept阻塞，等待客户端连接。在这时如果有个客户端初始化一个Socket，然后连接服务器(connect)，如果连接成功，这时客户端与服务器端的连接就建立了。客户端发送数据请求，服务器端接收请求并处理请求，然后把回应数据发送给客户端，客户端读取数据，最后关闭连接，一次交互结束。  </p><h3 id="TCP-实现"><a href="#TCP-实现" class="headerlink" title="TCP 实现"></a>TCP 实现</h3><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/2/19 22:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建socket，并将socket绑定到65000端口</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">65000</span>);</span><br><span class="line">        <span class="comment">// 死循环，使socket一直等待并处理客户端发过来的请求</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 监听6500端口，直到客户端返回连接信息后才返回</span></span><br><span class="line">            Socket socket = serverSocket.accept();</span><br><span class="line">            <span class="comment">// 获取客户端请求信息后，执行相关逻辑</span></span><br><span class="line">            <span class="keyword">new</span> LengthCalculator(socket).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LengthCalculator</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Socket socket;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LengthCalculator</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.socket = socket;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取socket的输出流</span></span><br><span class="line">            OutputStream os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">// 获取socket的输入流</span></span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">            StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">while</span> ((len = is.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                os.write(bytes, <span class="number">0</span> , len);</span><br><span class="line">                System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span> , len));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 不要忘记关闭输入输出流</span></span><br><span class="line">            os.close();</span><br><span class="line">            is.close();</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客服端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClinet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建socket，并指定连接的是ip和端口号</span></span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">65000</span>);</span><br><span class="line">        <span class="comment">// 获取输出流</span></span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">// 获取输入流</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        os.write(<span class="string">"hello world"</span>.getBytes());</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        len = is.read(bytes);</span><br><span class="line">        String content = <span class="keyword">new</span> String(bytes, <span class="number">0</span>, len);</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        is.close();</span><br><span class="line">        os.close();</span><br><span class="line">        socket.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP-实现"><a href="#UDP-实现" class="headerlink" title="UDP 实现"></a>UDP 实现</h3><p>服务端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 服务端接受客户端发送的数据报</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">65001</span>); <span class="comment">//监听的端口号</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>]; <span class="comment">//存储从客户端接受到的内容</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buff, buff.length);</span><br><span class="line">        <span class="comment">//接受客户端发送过来的内容，并将内容封装进DatagramPacket对象中</span></span><br><span class="line">        socket.receive(packet);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] data = packet.getData(); <span class="comment">//从DatagramPacket对象中获取到真正存储的数据</span></span><br><span class="line">        <span class="comment">//将数据从二进制转换成字符串形式</span></span><br><span class="line">        String content = <span class="keyword">new</span> String(data, <span class="number">0</span>, packet.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">        <span class="comment">//将要发送给客户端的数据转换成二进制</span></span><br><span class="line">        <span class="keyword">byte</span>[] sendedContent = String.valueOf(content.length()).getBytes();</span><br><span class="line">        <span class="comment">// 服务端给客户端发送数据报</span></span><br><span class="line">        <span class="comment">//从DatagramPacket对象中获取到数据的来源地址与端口号</span></span><br><span class="line">        DatagramPacket packetToClient = <span class="keyword">new</span> DatagramPacket(sendedContent,</span><br><span class="line">                sendedContent.length, packet.getAddress(), packet.getPort());</span><br><span class="line">        socket.send(packetToClient); <span class="comment">//发送数据给客户端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客服端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 客户端发数据报给服务端</span></span><br><span class="line">        DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">// 要发送给服务端的数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="string">"Hello World"</span>.getBytes();</span><br><span class="line">        <span class="comment">// 将IP地址封装成InetAddress对象</span></span><br><span class="line">        InetAddress address = InetAddress.getByName(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        <span class="comment">// 将要发送给服务端的数据封装成DatagramPacket对象 需要填写上ip地址与端口号</span></span><br><span class="line">        DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buf, buf.length, address,</span><br><span class="line">                <span class="number">65001</span>);</span><br><span class="line">        <span class="comment">// 发送数据给服务端</span></span><br><span class="line">        socket.send(packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 客户端接受服务端发送过来的数据报</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">        <span class="comment">// 创建DatagramPacket对象用来存储服务端发送过来的数据</span></span><br><span class="line">        DatagramPacket receivedPacket = <span class="keyword">new</span> DatagramPacket(data, data.length);</span><br><span class="line">        <span class="comment">// 将接受到的数据存储到DatagramPacket对象中</span></span><br><span class="line">        socket.receive(receivedPacket);</span><br><span class="line">        <span class="comment">// 将服务器端发送过来的数据取出来并打印到控制台</span></span><br><span class="line">        String content = <span class="keyword">new</span> String(receivedPacket.getData(), <span class="number">0</span>,</span><br><span class="line">                receivedPacket.getLength());</span><br><span class="line">        System.out.println(content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.md" target="_blank" rel="noopener">计算机网络</a></li><li><a href="https://blog.csdn.net/justloveyou_/article/details/69612153" target="_blank" rel="noopener">计算机网络体系结构综述（下）</a></li><li><a href="https://coolshell.cn/articles/11564.html" target="_blank" rel="noopener">TCP 的那些事儿</a></li><li><a href="https://www.zhihu.com/question/32255109/answer/68558623" target="_blank" rel="noopener">TCP协议的滑动窗口具体是怎样控制流量的？</a></li><li><a href="https://www.cnblogs.com/wangcq/p/3520400.html" target="_blank" rel="noopener">Socket通信原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算机网络体系结构&quot;&gt;&lt;a href=&quot;#计算机网络体系结构&quot; class=&quot;headerlink&quot; title=&quot;计算机网络体系结构&quot;&gt;&lt;/a&gt;计算机网络体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;计算机网络\7fa66f48-bc42-4b98-93c2-56
      
    
    </summary>
    
      <category term="面试" scheme="http://blog.cuzz.site/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="网络" scheme="http://blog.cuzz.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="TCP/IP" scheme="http://blog.cuzz.site/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Java 中是如何实现线程通信？</title>
    <link href="http://blog.cuzz.site/2019/02/14/Java%20%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%9F/"/>
    <id>http://blog.cuzz.site/2019/02/14/Java 中是如何实现线程通信？/</id>
    <published>2019-02-14T15:59:59.000Z</published>
    <updated>2019-04-24T12:41:55.932Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。</p><p>本文涉及到的知识点：<code>thread.join()</code>, <code>object.wait()</code>, <code>object.notify()</code>, <code>CountdownLatch</code>, <code>CyclicBarrier</code>, <code>FutureTask</code>, <code>Callable</code> 等。</p><p>原文链接：<a href="http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/" target="_blank" rel="noopener">Java 中是如何实现线程通信？</a></p><p>本文涉及代码：<a href="https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java" target="_blank" rel="noopener">https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java</a></p></blockquote><a id="more"></a><p>下面我从几个例子作为切入点来讲解下 Java 里有哪些方法来实现线程间通信。</p><ul><li>如何让两个线程依次执行？</li><li>那如何让两个线程按照指定方式有序交叉运行呢？</li><li>四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的</li><li>三个运动员各自准备，等到三个人都准备好后，再一起跑</li><li>子线程完成某件任务后，把得到的结果回传给主线程</li></ul><h2 id="如何让两个线程依次执行？"><a href="#如何让两个线程依次执行？" class="headerlink" title="如何让两个线程依次执行？"></a>如何让两个线程依次执行？</h2><p>假设有两个线程，一个是线程 A，另一个是线程 B，两个线程分别依次打印 1-3 三个数字即可。我们来看下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            printNumber(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            printNumber(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    A.start();</span><br><span class="line">    B.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>printNumber(String)</code> 实现如下，用来依次打印 <code>1</code>, <code>2</code>, <code>3</code> 三个数字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNumber</span><span class="params">(String threadName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i++ &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(threadName + <span class="string">" print: "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时我们得到的结果是：</p><blockquote><p>B print: 1<br>A print: 1<br>B print: 2<br>A print: 2<br>B print: 3<br>A print: 3</p></blockquote><p>可以看到 A 和 B 是同时打印的。</p><p>那么，如果我们希望 B 在 A <code>全部打印</code>完后再开始打印呢？我们可以利用 <code>thread.join()</code> 方法，代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            printNumber(<span class="string">"A"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 开始等待 A"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                A.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            printNumber(<span class="string">"B"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    B.start();</span><br><span class="line">    A.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到的结果如下：</p><blockquote><p>B 开始等待 A<br>A print: 1<br>A print: 2<br>A print: 3</p><p>B print: 1<br>B print: 2<br>B print: 3</p></blockquote><p><code>A.join</code> 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的 join() 方法，直到线程A执行完毕后，才会继续执行线程B。</p><ul><li>t.join();  调用 join 方法，等待线程 t 执行完毕</li><li>t.join(1000);  等待 t 线程，等待时间是1000毫秒。</li></ul><p>所以我们能看到 <code>A.join()</code> 方法会让 B 一直等待直到 A 运行完毕。</p><h2 id="那如何让两个线程按照指定方式有序交叉运行呢？"><a href="#那如何让两个线程按照指定方式有序交叉运行呢？" class="headerlink" title="那如何让两个线程按照指定方式有序交叉运行呢？"></a>那如何让两个线程按照指定方式有序交叉运行呢？</h2><p>还是上面那个例子，我现在希望 A 在打印完 <code>1</code> 后，再让 B 打印 <code>1</code>, <code>2</code>, <code>3</code>，最后再回到 A 继续打印 <code>2</code>, <code>3</code>。这种需求下，显然 <code>Thread.join()</code> 已经不能满足了。我们需要更细粒度的锁来控制执行顺序。</p><p>这里，我们可以利用 <code>object.wait()</code> 和 <code>object.notify()</code> 两个方法来实现。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A 1, B 1, B 2, B 3, A 2, A 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"A 1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"A 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A 3"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"B 1"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 3"</span>);</span><br><span class="line"></span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    A.start();</span><br><span class="line">    B.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><blockquote><p>A 1<br>A waiting…</p><p>B 1<br>B 2<br>B 3<br>A 2<br>A 3</p></blockquote><p>正是我们要的结果。</p><p>那么，这个过程发生了什么呢？</p><ol><li>首先创建一个 A 和 B 共享的对象锁 lock = new Object();</li><li>当 A 得到锁后，先打印 1，然后调用 <code>lock.wait()</code> 方法，交出锁的控制权，进入 <code>wait</code> 状态；</li><li>对 B 而言，由于 A 最开始得到了锁，导致 B 无法执行；直到 A 调用 <code>lock.wait()</code> 释放控制权后， B 才得到了锁；</li><li>B 在得到锁后打印 1， 2， 3；然后调用 <code>lock.notify()</code> 方法，唤醒正在 <code>wait</code> 的 A;</li><li>A 被唤醒后，继续打印剩下的 2，3。</li></ol><p>为了更好理解，我在上面的代码里加上 log 方便读者查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    Thread A = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"INFO: A 等待锁 "</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"INFO: A 得到了锁 lock"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A 1"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"INFO: A 准备进入等待状态，放弃锁 lock 的控制权 "</span>);</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"INFO: 有人唤醒了 A, A 重新获得锁 lock"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"A 3"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    Thread B = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"INFO: B 等待锁 "</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                System.out.println(<span class="string">"INFO: B 得到了锁 lock"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 1"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 2"</span>);</span><br><span class="line">                System.out.println(<span class="string">"B 3"</span>);</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"INFO: B 打印完毕，调用 notify 方法 "</span>);</span><br><span class="line">                lock.notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    A.start();</span><br><span class="line">    B.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下:</p><blockquote><p>INFO: A 等待锁<br>INFO: A 得到了锁 lock<br>A 1<br>INFO: A 准备进入等待状态，调用 lock.wait() 放弃锁 lock 的控制权<br>INFO: B 等待锁<br>INFO: B 得到了锁 lock<br>B 1<br>B 2<br>B 3<br>INFO: B 打印完毕，调用 lock.notify() 方法<br>INFO: 有人唤醒了 A, A 重新获得锁 lock<br>A 2<br>A 3</p></blockquote><h2 id="四个线程-A-B-C-D，其中-D-要等到-A-B-C-全执行完毕后才执行，而且-A-B-C-是同步运行的"><a href="#四个线程-A-B-C-D，其中-D-要等到-A-B-C-全执行完毕后才执行，而且-A-B-C-是同步运行的" class="headerlink" title="四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的"></a>四个线程 A B C D，其中 D 要等到 A B C 全执行完毕后才执行，而且 A B C 是同步运行的</h2><p>最开始我们介绍了 <code>thread.join()</code>，可以让一个线程等另一个线程运行完毕后再继续执行，那我们可以在 D 线程里依次 join A B C，不过这也就使得 A B C 必须依次执行，而我们要的是这三者能同步运行。</p><p>或者说，我们希望达到的目的是：A B C 三个线程同时运行，各自独立运行完后通知 D；对 D 而言，只要 A B C 都运行完了，D 再开始运行。针对这种情况，我们可以利用 <code>CountdownLatch</code> 来实现这类通信方式。它的基本用法是：</p><ol><li>创建一个计数器，设置初始值，CountdownLatch countDownLatch = new CountDownLatch(2);</li><li>在 <code>等待线程</code>里调用 <code>countDownLatch.await()</code> 方法，进入等待状态，直到计数值变成 0；</li><li>在 <code>其他线程</code>里，调用 <code>countDownLatch.countDown()</code> 方法，该方法会将计数值减小 1；</li><li>当 <code>其他线程</code>的 <code>countDown()</code> 方法把计数值变成 0 时，<code>等待线程</code> 里的 <code>countDownLatch.await()</code> 立即退出，继续执行下面的代码。</li></ol><p>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runDAfterABC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> worker = <span class="number">3</span>;</span><br><span class="line">    CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(worker);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"D is waiting for other three threads"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                countDownLatch.await();</span><br><span class="line">                System.out.println(<span class="string">"All done, D starts working"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> threadName=<span class="string">'A'</span>; threadName &lt;= <span class="string">'C'</span>; threadName++) &#123;</span><br><span class="line">        <span class="keyword">final</span> String tN = String.valueOf(threadName);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(tN + <span class="string">" is working"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(tN + <span class="string">" finished"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是运行结果：</p><blockquote><p>D is waiting for other three threads<br>A is working<br>B is working<br>C is working</p><p>A finished<br>C finished<br>B finished<br>All done, D starts working</p></blockquote><p>其实简单点来说，<code>CountDownLatch</code> 就是一个倒计数器，我们把初始计数值设置为<code>3</code>，当 <code>D</code> 运行时，先调用 <code>countDownLatch.await()</code> 检查计数器值是否为 <code>0</code>，若不为 <code>0</code> 则保持等待状态；当<code>A</code> <code>B</code> <code>C</code> 各自运行完后都会利用<code>countDownLatch.countDown()</code>，将倒计数器减 <code>1</code>，当三个都运行完后，计数器被减至 <code>0</code>；此时立即触发 <code>D</code>的 <code>await()</code> 运行结束，继续向下执行。</p><p>因此，<code>CountDownLatch</code> 适用于一个线程去等待多个线程的情况。</p><h2 id="三个运动员各自准备，等到三个人都准备好后，再一起跑"><a href="#三个运动员各自准备，等到三个人都准备好后，再一起跑" class="headerlink" title="三个运动员各自准备，等到三个人都准备好后，再一起跑"></a>三个运动员各自准备，等到三个人都准备好后，再一起跑</h2><p>上面是一个形象的比喻，针对 <code>线程 A B C 各自开始准备，直到三者都准备完毕，然后再同时运行</code>。也就是要实现一种<code>线程之间互相等待</code>的效果，那应该怎么来实现呢？</p><p>上面的 <code>CountDownLatch</code> 可以用来倒计数，但当计数完毕，只有一个线程的 <code>await()</code> 会得到响应，无法让多个线程同时触发。</p><p>为了实现线程间互相等待这种需求，我们可以利用 <code>CyclicBarrier</code> 数据结构，它的基本用法是：</p><ol><li>先创建一个公共 <code>CyclicBarrier</code> 对象，设置 <code>同时等待</code>的线程数，CyclicBarrier cyclicBarrier = new CyclicBarrier(3);</li><li>这些线程同时开始自己做准备，自身准备完毕后，需要等待别人准备完毕，这时调用 <code>cyclicBarrier.await();</code> 即可开始等待别人；</li><li>当指定的 <code>同时等待</code>的线程数都调用了 <code>cyclicBarrier.await();</code>时，意味着这些线程都准备完毕好，然后这些线程才 <code>同时继续执行</code>。</li></ol><p>实现代码如下，设想有三个跑步运动员，各自准备好后等待其他人，全部准备好后才开始跑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runABCWhenAllReady</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runner = <span class="number">3</span>;</span><br><span class="line">    CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(runner);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> runnerName=<span class="string">'A'</span>; runnerName &lt;= <span class="string">'C'</span>; runnerName++) &#123;</span><br><span class="line">        <span class="keyword">final</span> String rN = String.valueOf(runnerName);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">long</span> prepareTime = random.nextInt(<span class="number">10000</span>) + <span class="number">100</span>;</span><br><span class="line">                System.out.println(rN + <span class="string">" is preparing for time: "</span> + prepareTime);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(prepareTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(rN + <span class="string">" is prepared, waiting for others"</span>);</span><br><span class="line">                    cyclicBarrier.await(); <span class="comment">// 当前运动员准备完毕，等待别人准备好</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                System.out.println(rN + <span class="string">" starts running"</span>); <span class="comment">// 所有运动员都准备好了，一起开始跑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印的结果如下：</p><blockquote><p>A is preparing for time: 4131<br>B is preparing for time: 6349<br>C is preparing for time: 8206</p><p>A is prepared, waiting for others</p><p>B is prepared, waiting for others</p><p>C is prepared, waiting for others</p><p>C starts running<br>A starts running<br>B starts running</p></blockquote><h2 id="子线程完成某件任务后，把得到的结果回传给主线程"><a href="#子线程完成某件任务后，把得到的结果回传给主线程" class="headerlink" title="子线程完成某件任务后，把得到的结果回传给主线程"></a>子线程完成某件任务后，把得到的结果回传给主线程</h2><p>实际的开发中，我们经常要创建子线程来做一些耗时任务，然后把任务执行结果回传给主线程使用，这种情况在 Java 里要如何实现呢？</p><p>回顾线程的创建，我们一般会把 <code>Runnable</code> 对象传给 Thread 去执行。<code>Runnable</code>定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 <code>run()</code> 在执行完后不会返回任何结果。那如果希望返回结果呢？这里可以利用另一个类似的接口类 <code>Callable</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>Callable</code> 最大区别就是返回范型 <code>V</code> 结果。</p><p>那么下一个问题就是，如何把子线程的结果回传回来呢？在 Java 里，有一个类是配合 Callable 使用的：<code>FutureTask</code>，不过注意，它获取结果的 <code>get</code> 方法会阻塞主线程。</p><p>举例，我们想让子线程去计算从 1 加到 100，并把算出的结果返回到主线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doTaskWithResultInWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Callable&lt;Integer&gt; callable = <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Task starts"</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">100</span>; i++) &#123;</span><br><span class="line">                result += i;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Task finished and return result"</span>);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(callable);</span><br><span class="line">    <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"Before futureTask.get()"</span>);</span><br><span class="line">        System.out.println(<span class="string">"Result: "</span> + futureTask.get());</span><br><span class="line">        System.out.println(<span class="string">"After futureTask.get()"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下：</p><blockquote><p>Before futureTask.get()</p><p>Task starts<br>Task finished and return result</p><p>Result: 5050<br>After futureTask.get()</p></blockquote><p>可以看到，主线程调用 <code>futureTask.get()</code> 方法时阻塞主线程；然后 <code>Callable</code> 内部开始执行，并返回运算结果；此时 <code>futureTask.get()</code> 得到结果，主线程恢复运行。</p><p>这里我们可以学到，通过 <code>FutureTask</code> 和 <code>Callable</code> 可以直接在主线程获得子线程的运算结果，只不过需要阻塞主线程。当然，如果不希望阻塞主线程，可以考虑利用 <code>ExecutorService</code>，把 <code>FutureTask</code> 放到线程池去管理执行。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>多线程是现代语言的共同特性，而线程间通信、线程同步、线程安全是很重要的话题。本文针对 Java 的线程间通信进行了大致的讲解，后续还会对线程同步、线程安全进行讲解。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;正常情况下，每个子线程完成各自的任务就可以结束了。不过有的时候，我们希望多个线程协同工作来完成某个任务，这时就涉及到了线程间通信了。&lt;/p&gt;
&lt;p&gt;本文涉及到的知识点：&lt;code&gt;thread.join()&lt;/code&gt;, &lt;code&gt;object.wait()&lt;/code&gt;, &lt;code&gt;object.notify()&lt;/code&gt;, &lt;code&gt;CountdownLatch&lt;/code&gt;, &lt;code&gt;CyclicBarrier&lt;/code&gt;, &lt;code&gt;FutureTask&lt;/code&gt;, &lt;code&gt;Callable&lt;/code&gt; 等。&lt;/p&gt;
&lt;p&gt;原文链接：&lt;a href=&quot;http://wingjay.com/2017/04/09/Java%E9%87%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%9F/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Java 中是如何实现线程通信？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文涉及代码：&lt;a href=&quot;https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/wingjay/HelloJava/blob/master/multi-thread/src/ForArticle.java&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="http://blog.cuzz.site/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="转载" scheme="http://blog.cuzz.site/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="多线程" scheme="http://blog.cuzz.site/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="线程通信" scheme="http://blog.cuzz.site/tags/%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的锁</title>
    <link href="http://blog.cuzz.site/2019/02/13/Java%20%E4%B8%AD%E7%9A%84%E9%94%81/"/>
    <id>http://blog.cuzz.site/2019/02/13/Java 中的锁/</id>
    <published>2019-02-13T15:59:59.000Z</published>
    <updated>2019-10-19T16:46:20.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java中的锁分类"><a href="#Java中的锁分类" class="headerlink" title="Java中的锁分类"></a>Java中的锁分类</h2><p>在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：</p><ul><li>公平锁/非公平锁</li><li>可重入锁</li><li>独享锁/共享锁</li><li>互斥锁/读写锁</li><li>乐观锁/悲观锁</li><li>分段锁</li><li>偏向锁/轻量级锁/重量级锁</li><li>自旋锁</li></ul><p>上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。</p><a id="more"></a><h2 id="公平锁-非公平锁"><a href="#公平锁-非公平锁" class="headerlink" title="公平锁/非公平锁"></a>公平锁/非公平锁</h2><p>公平锁是指多个线程按照申请锁的顺序来获取锁。<br>非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。<br>对于Java <code>ReentrantLock</code>而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。<br>对于<code>Synchronized</code>而言，也是一种非公平锁。由于其并不像<code>ReentrantLock</code>是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。</p><h2 id="可重入锁-不可重入锁"><a href="#可重入锁-不可重入锁" class="headerlink" title="可重入锁/不可重入锁"></a>可重入锁/不可重入锁</h2><p>最近正在阅读Java ReentrantLock源码，始终对可重入和不可重入概念理解不透彻，进行学习后记录在这里。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>Java多线程的 wait() 方法和 notify() 方法。<br>这两个方法是成对出现和使用的，要执行这两个方法，有一个前提就是，当前线程必须获其对象的monitor（俗称“锁”），否则会抛出 IllegalMonitorStateException 异常，所以这两个方法必须在同步块代码里面调用。</p><ul><li>wait()：阻塞当前线程</li><li>notify()：唤起被wait()阻塞的线程</li></ul><h3 id="不可重入锁"><a href="#不可重入锁" class="headerlink" title="不可重入锁"></a>不可重入锁</h3><p>所谓不可重入锁，即若当前线程执行某个方法已经获取了该锁，那么在方法中尝试再次获取锁时，就会获取不到被阻塞。我们尝试设计一个不可重入锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(isLocked)&#123;    </span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        isLocked = <span class="keyword">false</span>;</span><br><span class="line">        notify();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Count</span></span>&#123;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> Lock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        doAdd();</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前线程执行print()方法首先获取lock，接下来执行doAdd()方法就无法执行doAdd()中的逻辑，必须先释放锁。这个例子很好的说明了不可重入锁。</p><h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p>接下来，我们设计一种可重入锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">    Thread  lockedBy = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> lockedCount = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">while</span>(isLocked &amp;&amp; lockedBy != thread)&#123;</span><br><span class="line">            wait();</span><br><span class="line">        &#125;</span><br><span class="line">        isLocked = <span class="keyword">true</span>;</span><br><span class="line">        lockedCount++;</span><br><span class="line">        lockedBy = thread;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(Thread.currentThread() == <span class="keyword">this</span>.lockedBy)&#123;</span><br><span class="line">            lockedCount--;</span><br><span class="line">            <span class="keyword">if</span>(lockedCount == <span class="number">0</span>)&#123;</span><br><span class="line">                isLocked = <span class="keyword">false</span>;</span><br><span class="line">                notify();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓可重入，意味着线程可以进入它已经拥有的锁的同步代码块儿。</p><p>我们设计两个线程调用 print() 方法，第一个线程调用 print() 方法获取锁，进入 lock() 方法，由于初始 lockedBy 是 null，所以不会进入 while 而挂起当前线程，而是是增量 lockedCount 并记录 lockBy 为第一个线程。接着第一个线程进入 doAdd() 方法，由于同一进程，所以不会进入 while 而挂起，接着增量 lockedCount，当第二个线程尝试lock，由于 isLocked=true，所以他不会获取该锁，直到第一个线程调用两次 unlock() 将 lockCount 递减为0，才将标记为 isLocked 设置为 false。</p><p>可重入锁的概念和设计思想大体如此，Java 中的可重入锁 ReentrantLock 设计思路也是这样。</p><h2 id="独享锁-共享锁"><a href="#独享锁-共享锁" class="headerlink" title="独享锁/共享锁"></a>独享锁/共享锁</h2><p>独享锁是指该锁一次只能被一个线程所持有。<br>共享锁是指该锁可被多个线程所持有。</p><p>对于Java <code>ReentrantLock</code>而言，其是独享锁。但是对于Lock的另一个实现类<code>ReadWriteLock</code>，其读锁是共享锁，其写锁是独享锁。</p><ul><li>读锁的共享锁可保证并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li><li>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享。</li></ul><p>对于<code>Synchronized</code>而言，当然是独享锁。</p><h2 id="互斥锁-读写锁"><a href="#互斥锁-读写锁" class="headerlink" title="互斥锁/读写锁"></a>互斥锁/读写锁</h2><p>上面讲的独享锁/共享锁就是一种广义的说法，互斥锁/读写锁就是具体的实现。</p><ul><li>互斥锁在Java中的具体实现就是<code>ReentrantLock</code></li><li>读写锁在Java中的具体实现就是<code>ReadWriteLock</code></li></ul><h2 id="乐观锁-悲观锁"><a href="#乐观锁-悲观锁" class="headerlink" title="乐观锁/悲观锁"></a>乐观锁/悲观锁</h2><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。<br>悲观锁认为对于同一个数据的并发操作，一定是会发生修改的，哪怕没有修改，也会认为修改。因此对于同一个数据的并发操作，悲观锁采取加锁的形式。悲观的认为，不加锁的并发操作一定会出问题。<br>乐观锁则认为对于同一个数据的并发操作，是不会发生修改的。在更新数据的时候，会采用尝试更新，不断重新的方式更新数据。乐观的认为，不加锁的并发操作是没有事情的。</p><p>从上面的描述我们可以看出，悲观锁适合写操作非常多的场景，乐观锁适合读操作非常多的场景，不加锁会带来大量的性能提升。</p><ul><li>悲观锁在Java中的使用，就是利用各种锁。</li><li>乐观锁在Java中的使用，是无锁编程，常常采用的是CAS算法，典型的例子就是原子类，通过CAS自旋实现原子操作的更新。</li></ul><h2 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h2><p>分段锁其实是一种锁的设计，并不是具体的一种锁，对于<code>ConcurrentHashMap</code> 而言，其并发的实现就是通过分段锁的形式来实现高效的并发操作。</p><p>我们以<code>ConcurrentHashMap</code>来说一下分段锁的含义以及设计思想，<code>ConcurrentHashMap</code>中的分段锁称为Segment，它即类似于HashMap（JDK7与JDK8中HashMap的实现）的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表；同时又是一个ReentrantLock（Segment继承了ReentrantLock)。<br>当需要put元素的时候，并不是对整个hashmap进行加锁，而是先通过 hashcode 来知道他要放在那一个分段中，然后对这个分段进行加锁，所以当多线程put的时候，只要不是放在一个分段中，就实现了真正的并行的插入。<br>但是，在统计size的时候，可就是获取 hashmap 全局信息的时候，就需要获取所有的分段锁才能统计。<br>分段锁的设计目的是细化锁的粒度，当操作不需要更新整个数组的时候，就仅仅针对数组中的一项进行加锁操作。</p><h2 id="偏向锁-轻量级锁-重量级锁"><a href="#偏向锁-轻量级锁-重量级锁" class="headerlink" title="偏向锁/轻量级锁/重量级锁"></a>偏向锁/轻量级锁/重量级锁</h2><h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>在没有实际竞争的情况下，还能够针对部分场景继续优化。如果不仅仅没有实际竞争，自始至终，使用锁的线程都只有一个，那么，维护轻量级锁都是浪费的。<strong>偏向锁的目标是，减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁产生的性能消耗</strong>。轻量级锁每次申请、释放锁都至少需要一次CAS，但偏向锁只有初始化时需要一次CAS。</p><p>“偏向”的意思是，偏向锁假定将来只有第一个申请锁的线程会使用锁（不会有任何线程再来申请锁），因此，只需要在Mark Word中 CAS 记录owner（本质上也是更新，但初始值为空），如果记录成功，则偏向锁获取成功，记录锁状态为偏向锁，以后当前线程等于owner就可以零成本的直接获得锁；否则，说明有其他线程竞争，膨胀为轻量级锁。</p><p>偏向锁无法使用自旋锁优化，因为一旦有其他线程申请锁，就破坏了偏向锁的假定。</p><p>缺点：</p><p>同样的，如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁。</p><blockquote><p>不过这个副作用已经小的多。</p><p>如果需要，使用参数-XX:-UseBiasedLocking禁止偏向锁优化（默认打开）。</p></blockquote><h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>自旋锁的目标是降低线程切换的成本。如果锁竞争激烈，我们不得不依赖于重量级锁，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。<strong>轻量级锁的目标是，减少无实际竞争情况下，使用重量级锁产生的性能消耗</strong>，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。</p><p>顾名思义，轻量级锁是相对于重量级锁而言的。使用轻量级锁时，不需要申请互斥量，仅仅将 Mark Word 中的部分字节CAS更新指向线程栈中的Lock Record，如果更新成功，则轻量级锁获取成功，记录锁状态为轻量级锁；否则，说明已经有线程获得了轻量级锁，目前发生了锁竞争（不适合继续使用轻量级锁），接下来膨胀为重量级锁。</p><blockquote><p>Mark Word是对象头的一部分；每个线程都拥有自己的线程栈（虚拟机栈），记录线程和函数调用的基本信息。二者属于JVM的基础内容，此处不做介绍。</p></blockquote><p>当然，由于轻量级锁天然瞄准不存在锁竞争的场景，如果存在锁竞争但不激烈，仍然可以用自旋锁优化，自旋失败后再膨胀为重量级锁。</p><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>内置锁在Java中被抽象为监视器锁（monitor）。在JDK 1.6之前，监视器锁可以认为直接对应底层操作系统中的互斥量（mutex）。这种同步方式的成本非常高，包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等。因此，后来称这种锁为“重量级锁”。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><blockquote><p>偏向锁、轻量级锁、重量级锁分配和膨胀的详细过程见后。会涉及一些Mark Word与CAS的知识。</p></blockquote><p>偏向锁、轻量级锁、重量级锁适用于不同的并发场景：</p><ul><li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li><li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li><li>重量级锁：有实际竞争，且锁竞争时间长。</li></ul><p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p><p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>首先，内核态与用户态的切换上不容易优化。但<strong>通过自旋锁，可以减少线程阻塞造成的线程切换</strong>（包括挂起线程和恢复线程）。</p><p>如果锁的粒度小，那么<strong>锁的持有时间比较短</strong>（尽管具体的持有时间无法得知，但可以认为，通常有一部分锁能满足上述性质）。那么，对于竞争这些锁的而言，因为锁阻塞造成线程切换的时间与锁持有的时间相当，减少线程阻塞造成的线程切换，能得到较大的性能提升。具体如下：</p><ul><li>当前线程竞争锁失败时，打算阻塞自己</li><li>不直接阻塞自己，而是自旋（空等待，比如一个空的有限for循环）一会</li><li>在自旋的同时重新竞争锁</li><li>如果自旋结束前获得了锁，那么锁获取成功；否则，自旋结束后阻塞自己</li></ul><p>如果在自旋的时间内，锁就被旧owner释放了，那么当前线程就不需要阻塞自己（也不需要在未来锁释放时恢复），减少了一次线程切换。</p><p>“锁的持有时间比较短“这一条件可以放宽。实际上，只要锁竞争的时间比较短（比如线程1快释放锁的时候，线程2才会来竞争锁），就能够提高自旋获得锁的概率。这通常发生在<strong>锁持有时间长，但竞争不激烈</strong>的场景中。</p><p>典型的自旋锁实现的例子，可以参考<a href="http://ifeve.com/java_lock_see1/" target="_blank" rel="noopener">自旋锁的实现</a></p><h2 id="锁分配和膨胀过程"><a href="#锁分配和膨胀过程" class="headerlink" title="锁分配和膨胀过程"></a>锁分配和膨胀过程</h2><p><img src="Java 中的锁\4491294-e3bcefb2bacea224.png" alt="锁分配和膨胀过程"></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.cnblogs.com/qifengshi/p/6831055.html" target="_blank" rel="noopener">Java中的锁分类</a></li><li><a href="https://blog.csdn.net/u012545728/article/details/80843595" target="_blank" rel="noopener">Java不可重入锁和可重入锁理解</a></li><li><a href="https://www.jianshu.com/p/36eedeb3f912" target="_blank" rel="noopener">浅谈偏向锁、轻量级锁、重量级锁</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java中的锁分类&quot;&gt;&lt;a href=&quot;#Java中的锁分类&quot; class=&quot;headerlink&quot; title=&quot;Java中的锁分类&quot;&gt;&lt;/a&gt;Java中的锁分类&lt;/h2&gt;&lt;p&gt;在读很多并发文章中，会提及各种各样锁如公平锁，乐观锁等等，这篇文章介绍各种锁的分类。介绍的内容如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;公平锁/非公平锁&lt;/li&gt;
&lt;li&gt;可重入锁&lt;/li&gt;
&lt;li&gt;独享锁/共享锁&lt;/li&gt;
&lt;li&gt;互斥锁/读写锁&lt;/li&gt;
&lt;li&gt;乐观锁/悲观锁&lt;/li&gt;
&lt;li&gt;分段锁&lt;/li&gt;
&lt;li&gt;偏向锁/轻量级锁/重量级锁&lt;/li&gt;
&lt;li&gt;自旋锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面是很多锁的名词，这些分类并不是全是指锁的状态，有的指锁的特性，有的指锁的设计，下面总结的内容是对每个锁的名词进行一定的解释。&lt;/p&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="http://blog.cuzz.site/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="转载" scheme="http://blog.cuzz.site/tags/%E8%BD%AC%E8%BD%BD/"/>
    
      <category term="锁" scheme="http://blog.cuzz.site/tags/%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射</title>
    <link href="http://blog.cuzz.site/2019/02/11/Java%20%E5%8F%8D%E5%B0%84/"/>
    <id>http://blog.cuzz.site/2019/02/11/Java 反射/</id>
    <published>2019-02-11T15:59:59.000Z</published>
    <updated>2019-04-24T12:42:17.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>当程序有使用某个类时，如果该类还没有被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化</p><a id="more"></a><ul><li>加载<br>就是指将<code>class</code>文件读入内存，并为之创建一个<code>Class</code>对象，任何类被使用时系统都会建立一个<code>Class</code>对象</li><li>连接<br>验证 是否有正确的内部结构，并和其他类协调一致<br>准备 负责为类的静态成员分配内存，并设置默认初始化值<br>解析 将类的二进制数据中的符号引用替换为直接引用</li><li>初始化<br>对类的静态变量，静态代码块执行初始化操作<h3 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h3></li><li>创建类的实例</li><li>类的静态变量，或者为静态变量赋值</li><li>类的静态方法</li><li>使用反射方式来强制创建某个类或接口对应的<code>java.lang.Class</code>对象</li><li>初始化某个类的子类</li><li>直接使用<code>java.exe</code>命令来运行某个主类<h3 id="类加载器-1"><a href="#类加载器-1" class="headerlink" title="类加载器"></a>类加载器</h3></li><li>负责将<code>.class</code>文件加载到内在中，并为之生成对应的<code>Class</code>对象</li><li>虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行<h3 id="类加载器的组成"><a href="#类加载器的组成" class="headerlink" title="类加载器的组成"></a>类加载器的组成</h3></li><li><code>Bootstrap ClassLoader</code> 根类加载器<br>也被称为引导类加载器，负责Java核心类的加载<br>比如<code>System</code>，<code>String</code>等。在 JDK 中 JRE 的 lib 目录下 rt.jar 文件中</li><li><code>Extension ClassLoader</code>扩展类加载器<br>负责 JRE 的扩展目录中 jar 包的加载。<br>在 JDK 中 JRE 的 lib 目录下 ext 目录</li><li><code>System ClassLoader</code>系统类加载器<br>负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径</li></ul><p>通过这些描述就可以知道我们常用的类，都是由谁来加载完成的。</p><p>到目前为止我们已经知道把class文件加载到内存了，那么，如果我们仅仅站在这些class文件的角度，我们如何来使用这些class文件中的内容呢?</p><p>这就是我们反射要研究的内容</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。<br>要想解剖一个类,必须先要获取到该类的字节码文件对象。而解剖使用的就是Class类中的方法.所以先要获取到每一个字节码文件对应的Class类型的对象</p><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>阅读API的<code>Class</code>类得知，<code>Class</code> 没有公共构造方法。<code>Class</code> 对象是在加载类时由 Java 虚拟机以及通过调用类加载器中的 <code>defineClass</code> 方法自动构造的</p><h4 id="获取Class对象的三种方式"><a href="#获取Class对象的三种方式" class="headerlink" title="获取Class对象的三种方式"></a>获取Class对象的三种方式</h4><p>方式一: 通过<code>Object</code>类中的<code>getObject()</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">Class c = p.getClass();</span><br></pre></td></tr></table></figure></p><p>方式二: 通过 类名<code>.class</code> 获取到字节码文件对象（任意数据类型都具备一个<code>class</code>静态属性,看上去要比第一种方式简单）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c2 = Person.class;</span><br></pre></td></tr></table></figure></p><p>方式三: 通过<code>Class</code>类中的方法（将类名作为字符串传递给<code>Class</code>类中的静态方法<code>forName</code>即可）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c3 = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br></pre></td></tr></table></figure></p><p><strong>注意：第三种和前两种的区别</strong></p><p>前两种你必须明确Person类型</p><p>后面是指定这种类型的字符串就行(要包含包名)，这种扩展更强，我不需要知道你的类，我只提供字符串，按照配置文件加载就可以了</p><h4 id="Person类"><a href="#Person类" class="headerlink" title="Person类"></a>Person类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="comment">// 成员变量</span></span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"空参数构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">System.out.println(<span class="string">"带有String的构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">System.out.println(<span class="string">"带有String，int的构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String address)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.address = address;</span><br><span class="line">System.out.println(<span class="string">"带有String, int, String的构造方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员方法</span></span><br><span class="line"><span class="comment">// 没有返回值没有参数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"没有返回值没有参数的方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有返回值，有参数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"没有返回值，有参数的方法 name= "</span>+ name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有返回值，没有参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method3</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"有返回值，没有参数的方法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有返回值，有参数的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">method4</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"有返回值，有参数的方法"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"哈哈"</span> + name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">method5</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"私有方法"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", address="</span> + address+ <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射获取构造方法并使用"><a href="#通过反射获取构造方法并使用" class="headerlink" title="通过反射获取构造方法并使用"></a>通过反射获取构造方法并使用</h3><p>在反射机制中，把类中的成员（构造方法、成员方法、成员变量）都封装成了对应的类进行表示。其中，构造方法使用类<code>Constructor</code>表示。可通过<code>Class</code>类中提供的方法获取构造方法：</p><ul><li>返回一个构造方法<ul><li><code>public Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code> 获取<code>public</code>修饰, 指定参数类型所对应的构造方法</li><li><code>public Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)</code> 获取指定参数类型所对应的构造方法(包含私有的)</li></ul></li><li>返回多个构造方法<ul><li><code>public Constructor&lt;?&gt;[] getConstructors()</code>获取所有的<code>public</code> 修饰的构造方法</li><li><code>public Constructor&lt;?&gt;[] getDeclaredConstructors()</code> 获取所有的构造方法(包含私有的)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line"><span class="comment">// 获取Class对象 包名.类</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有构造方法</span></span><br><span class="line"><span class="comment">// 只包括public</span></span><br><span class="line">Constructor[] cons = c.getConstructors();</span><br><span class="line"><span class="comment">// 即包括public也包括private</span></span><br><span class="line">Constructor[] conss = c.getDeclaredConstructors();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个构造方法</span></span><br><span class="line"><span class="comment">// public Person() </span></span><br><span class="line">Constructor con1 = c.getConstructor(<span class="keyword">null</span>);</span><br><span class="line">System.out.println(con1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public Person(String name)</span></span><br><span class="line">Constructor con2 = c.getConstructor(String.class);</span><br><span class="line">System.out.println(con2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// private Person(String name, int age)</span></span><br><span class="line">Constructor con3 = c.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(con3);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public Person(String name, int age, String address)</span></span><br><span class="line">Constructor con4 = c.getDeclaredConstructor(String.class, <span class="keyword">int</span>.class, String.class);</span><br><span class="line">System.out.println(con4);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="通过反射方式，获取构造方法，创建对象"><a href="#通过反射方式，获取构造方法，创建对象" class="headerlink" title="通过反射方式，获取构造方法，创建对象"></a>通过反射方式，获取构造方法，创建对象</h3><p>获取构造方法，步骤如下：</p><ul><li>获取到Class对象</li><li>获取指定的构造方法</li><li>通过构造方法类<code>Constructor</code>中的方法，创建对象<code>public T newInstance(Object... initargs)</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定构造器</span></span><br><span class="line">Constructor con =  c.getConstructor(String.class, <span class="keyword">int</span>.class, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造方法中的Constructor的方法 创建对象</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">"cuzz"</span>, <span class="number">18</span>, <span class="string">"武汉"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(obj);  <span class="comment">// Person [name=cuzz, age=18, address=武汉]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过反射获取成员变量并使用"><a href="#通过反射获取成员变量并使用" class="headerlink" title="通过反射获取成员变量并使用"></a>通过反射获取成员变量并使用</h3><p>在反射机制中，把类中的成员变量使用类Field表示。可通过Class类中提供的方法获取成员变量：</p><ul><li>返回一个成员变量<ul><li><code>public Field getField(String name)</code> 获取指定的<code>public</code>修饰的变量</li><li><code>public Field getDeclaredField(String name)</code> 获取指定的任意变量</li></ul></li><li>返回多个成员变量<ul><li><code>public Field[] getFields()</code> 获取所有<code>public</code> 修饰的变量</li><li><code>public Field[] getDeclaredFields()</code> 获取所有的 变量 (包含私有)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取多个成员变量</span></span><br><span class="line">Field[] fields = c.getFields();</span><br><span class="line">Field[] fieldss =  c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个变量</span></span><br><span class="line"><span class="comment">// public int age</span></span><br><span class="line">Field ageField = c.getField(<span class="string">"age"</span>);</span><br><span class="line">System.out.println(ageField);       <span class="comment">// public int cn.cuzz.Person.age</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// private String address</span></span><br><span class="line">Field addressField = c.getDeclaredField(<span class="string">"address"</span>);</span><br><span class="line">System.out.println(addressField);   <span class="comment">// private java.lang.String cn.cuzz.Person.address</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="通过反射，创建对象，获取指定的成员变量，进行赋值与获取值操作"><a href="#通过反射，创建对象，获取指定的成员变量，进行赋值与获取值操作" class="headerlink" title="通过反射，创建对象，获取指定的成员变量，进行赋值与获取值操作"></a>通过反射，创建对象，获取指定的成员变量，进行赋值与获取值操作</h3><p>获取成员变量，步骤如下：</p><ul><li>获取Class对象</li><li>获取构造方法</li><li>通过构造方法，创建对象</li><li>获取指定的成员变量（私有成员变量，通过setAccessible(boolean flag)方法暴力访问）</li><li>通过方法，给指定对象的指定成员变量赋值或者获取值<br><code>public void set(Object obj, Object value)</code>在指定对象obj中，将此 Field 对象表示的成员变量设置为指定的新值<br><code>public Object get(Object obj)</code>返回指定对象obj中，此 Field 对象表示的成员变量的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IllegalAccessException, Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取构造方法</span></span><br><span class="line">Constructor con = c.getConstructor(String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造方法 创建对象</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">"cuzz"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定成员变量</span></span><br><span class="line"><span class="comment">// public String name</span></span><br><span class="line">Field nameField = c.getField(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">// public int age</span></span><br><span class="line">Field ageField = c.getField(<span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">nameField.set(obj, <span class="string">"Cuzz"</span>);</span><br><span class="line">ageField.set(obj, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"name = "</span>+ nameField.get(obj)); <span class="comment">// name = Cuzz</span></span><br><span class="line">System.out.println(<span class="string">"age = "</span>+ ageField.get(obj));   <span class="comment">// age = 23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过反射获取成员方法并使用"><a href="#通过反射获取成员方法并使用" class="headerlink" title="通过反射获取成员方法并使用"></a>通过反射获取成员方法并使用</h3><p>在反射机制中，把类中的成员方法使用类Method表示。可通过Class类中提供的方法获取成员方法：</p><ul><li><p>返回获取一个方法：</p><ul><li><code>public Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code>  获取 public 修饰的方法</li><li><code>public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)</code> 获取任意的方法，包含私有的</li></ul><p>参数1: name 要查找的方法名称； 参数2： parameterTypes 该方法的参数类型</p></li><li><p>返回获取多个方法：</p><ul><li><code>public Method[] getMethods()</code> 获取本类与父类中所有public 修饰的方法</li><li><code>public Method[] getDeclaredMethods()</code> 获取本类中所有的方法(包含私有的)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test5</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取多个方法</span></span><br><span class="line">Method[] methods = c.getMethods();</span><br><span class="line">Method[] methodss = c.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取一个方法：</span></span><br><span class="line"><span class="comment">// public void method1()</span></span><br><span class="line">Method method = c.getMethod(<span class="string">"method1"</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(method);</span><br><span class="line"></span><br><span class="line"><span class="comment">// public String method4(String name)&#123;</span></span><br><span class="line">method = c.getMethod(<span class="string">"method4"</span>, String.class);</span><br><span class="line">System.out.println(method);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 私有方法</span></span><br><span class="line"><span class="comment">// private void method5()</span></span><br><span class="line">method = c.getDeclaredMethod(<span class="string">"method5"</span>, <span class="keyword">null</span>);</span><br><span class="line">System.out.println(method);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="通过反射，创建对象，调用指定的方法"><a href="#通过反射，创建对象，调用指定的方法" class="headerlink" title="通过反射，创建对象，调用指定的方法"></a>通过反射，创建对象，调用指定的方法</h3><p>获取成员方法，步骤如下：</p><ul><li>获取Class对象</li><li>获取构造方法</li><li>通过构造方法，创建对象</li><li>获取指定的方法</li><li>执行找到的方法(如果获取的是私有方法则要开启暴力访问<code>m5.setAccessible(true)</code>)<br> <code>public Object invoke(Object obj,  Object... args)</code> 执行指定对象obj中，当前Method对象所代表的方法，方法要传入的参数通过<code>args</code>指定<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test6</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 获取Class对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"cn.cuzz.Person"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定构造器</span></span><br><span class="line">Constructor con =  c.getConstructor(String.class, <span class="keyword">int</span>.class, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过构造方法中的Constructor的方法 创建对象</span></span><br><span class="line">Object obj = con.newInstance(<span class="string">"cuzz"</span>, <span class="number">18</span>, <span class="string">"武汉"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定的方法</span></span><br><span class="line">Method m4 = c.getMethod(<span class="string">"method4"</span>, String.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行找到的方法</span></span><br><span class="line">Object result = m4.invoke(obj, <span class="string">"2018/03/19"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"result = "</span> + result); <span class="comment">// result = 哈哈2018/03/19</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="反射练习"><a href="#反射练习" class="headerlink" title="反射练习"></a>反射练习</h2><p>下面展示一下反射的利用场景。</p><h3 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h3><p>思考，将已存在的<code>ArrayList&lt;Integer&gt;</code>集合中添加一个字符串数据，如何实现呢？</p><p>我来告诉大家，其实程序编译后产生的<code>.class</code>文件中是没有泛型约束的，这种现象我们称为泛型的擦除。那么，我们可以通过反射技术，来完成向有泛型约束的集合中，添加任意类型的元素<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.cuzz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test7</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception, SecurityException </span>&#123;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">list.add(<span class="string">"cuzz"</span>);</span><br><span class="line"><span class="comment">// list.add(23);  报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过反射技术，实现添加任意类型的元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字节码文件对象</span></span><br><span class="line">Class c = Class.forName(<span class="string">"java.util.ArrayList"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到add()方法</span></span><br><span class="line">Method addMethod = c.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行add()方法</span></span><br><span class="line">addMethod.invoke(list, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(list); <span class="comment">//[cuzz, 23]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="反射配置文件"><a href="#反射配置文件" class="headerlink" title="反射配置文件"></a>反射配置文件</h3><p>通过配置文件得到类名和要运行的方法名,用反射的操作类名得到对象和调用方法</p><p> 实现步骤:</p><ul><li>准备配置文件,键值对</li><li>IO流读取配置文件  Reader</li><li>文件中的键值对存储到集合中 Properties<br>集合保存的键值对,就是类名和方法名</li><li>反射获取指定类的class文件对象</li><li>class文件对象,获取指定的方法</li><li>运行方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test8</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"><span class="comment">// IO流读取配置文件</span></span><br><span class="line">FileReader r = <span class="keyword">new</span> FileReader(<span class="string">"config.properties"</span>);</span><br><span class="line"><span class="comment">// 创建集合对象</span></span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line"><span class="comment">// 调用集合方法load,传递流对象</span></span><br><span class="line">pro.load(r);</span><br><span class="line">r.close();</span><br><span class="line"><span class="comment">// 通过键获取值</span></span><br><span class="line">String className = pro.getProperty(<span class="string">"className"</span>);</span><br><span class="line">String methodName = pro.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line"><span class="comment">// 反射获取指定类的class文件对象</span></span><br><span class="line">Class c = Class.forName(className);</span><br><span class="line">Object obj = c.newInstance();</span><br><span class="line"><span class="comment">// 获取指定的方法名</span></span><br><span class="line">Method method = c.getMethod(methodName);</span><br><span class="line">method.invoke(obj);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>配置文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># className=cn.cuzz.Student</span><br><span class="line"># methodName=study</span><br><span class="line">className=cn.cuzz.Teacher</span><br><span class="line">methodName=teach</span><br><span class="line"># className=cn.cuzz.Worker</span><br><span class="line"># methodName=work</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;类加载器&quot;&gt;&lt;a href=&quot;#类加载器&quot; class=&quot;headerlink&quot; title=&quot;类加载器&quot;&gt;&lt;/a&gt;类加载器&lt;/h2&gt;&lt;p&gt;当程序有使用某个类时，如果该类还没有被加载到内存中，则系统会通过加载，连接，初始化三步来实现对这个类进行初始化&lt;/p&gt;
    
    </summary>
    
      <category term="Java 基础" scheme="http://blog.cuzz.site/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="反射" scheme="http://blog.cuzz.site/tags/%E5%8F%8D%E5%B0%84/"/>
    
  </entry>
  
  <entry>
    <title>Spring注解驱动开发（四）</title>
    <link href="http://blog.cuzz.site/2019/02/10/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://blog.cuzz.site/2019/02/10/Spring注解驱动开发（四）/</id>
    <published>2019-02-10T14:14:29.000Z</published>
    <updated>2019-04-21T15:15:47.539Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AOP面向切面编程"><a href="#AOP面向切面编程" class="headerlink" title="AOP面向切面编程"></a>AOP面向切面编程</h2><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p><a id="more"></a><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>Spring 的 AOP 的底层用到两种代理机制：</p><ul><li>JDK 的动态代理 ：类必须实现接口，所以是针对实现了接口的类产生代理.</li><li>Cglib 的动态代理：针对没有实现接口的类产生代理，应用的是底层的字节码增强的技术生成当前类的子类对象</li></ul><h3 id="JDK-的动态代理"><a href="#JDK-的动态代理" class="headerlink" title="JDK 的动态代理"></a>JDK 的动态代理</h3><ul><li><code>UserService</code>接口，实现增删改查的功能</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cuzz.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>UserService</code>接口的实现的类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"添加一个user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"删除一个user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"更新一个user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"查询一个user"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实现动态代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cuzz.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxyFactory</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserService us;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxyFactory</span><span class="params">(UserService us)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.us = us;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获得动态代理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">getUserServiceProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成动态代理</span></span><br><span class="line">        UserService usProxy = (UserService) Proxy.newProxyInstance(UserServiceProxyFactory.class.getClassLoader(),</span><br><span class="line">                UserServiceImpl.class.getInterfaces(), </span><br><span class="line">                <span class="keyword">this</span>); <span class="comment">// 这个 this 就是实现 InvocationHandler 的对象</span></span><br><span class="line">        <span class="keyword">return</span> usProxy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0, Method method, Object[] arg2)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开事务!"</span>);</span><br><span class="line">        Object invoke = method.invoke(us, arg2);</span><br><span class="line">        System.out.println(<span class="string">"提交事务!"</span>);</span><br><span class="line">        <span class="keyword">return</span> invoke;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDemo</span> </span>&#123;    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        UserService us = <span class="keyword">new</span> UserServiceImpl();       </span><br><span class="line">        UserServiceProxyFactory factory = <span class="keyword">new</span> UserServiceProxyFactory(us);        </span><br><span class="line">        UserService usProxy = factory.getUserServiceProxy();     </span><br><span class="line">        usProxy.add();   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打开事务!</span><br><span class="line">添加一个user</span><br><span class="line">提交事务!</span><br></pre></td></tr></table></figure><h3 id="Cglib-的动态代理"><a href="#Cglib-的动态代理" class="headerlink" title="Cglib 的动态代理"></a>Cglib 的动态代理</h3><ul><li>Cglib 的动态代理的代码实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cuzz.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cglib.proxy.MethodProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxyFactory2</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">getUserServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 帮我们生成代理对象</span></span><br><span class="line">        Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置对谁进行代理</span></span><br><span class="line">        en.setSuperclass(UserServiceImpl.class);</span><br><span class="line">        <span class="comment">// 代理要做什么</span></span><br><span class="line">        en.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 创建代理对象</span></span><br><span class="line">        UserService us = (UserService) en.create();</span><br><span class="line">        <span class="keyword">return</span> us;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object prxoyobj, Method method, Object[] arg, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 打开事务</span></span><br><span class="line">        System.out.println(<span class="string">"打开事务!"</span>);</span><br><span class="line">        <span class="comment">// 调用原有方法</span></span><br><span class="line">        Object returnValue = methodProxy.invokeSuper(prxoyobj, arg);</span><br><span class="line">        <span class="comment">// 提交事务</span></span><br><span class="line">        System.out.println(<span class="string">"提交事务!"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;    </span><br><span class="line">    UserServiceProxyFactory2 factory = <span class="keyword">new</span> UserServiceProxyFactory2();  </span><br><span class="line">    UserService usProxy = factory.getUserServiceProxy();</span><br><span class="line">    usProxy.add();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spring的AOP开发-基于AspectJ"><a href="#Spring的AOP开发-基于AspectJ" class="headerlink" title="Spring的AOP开发(基于AspectJ)"></a>Spring的AOP开发(基于AspectJ)</h3><h4 id="AOP的开发中的相关术语："><a href="#AOP的开发中的相关术语：" class="headerlink" title="AOP的开发中的相关术语："></a>AOP的开发中的相关术语：</h4><ul><li><code>Joinpoint</code>(连接点)：所谓连接点是指那些被拦截到的点，在 spring 中这些点指的是方法，因为 spring 只支持方法类型的连接点</li><li><code>Pointcut</code>(切入点)：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义</li><li><code>Advice</code>(通知/增强)：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知.通知分为前置通知,后置通知,异常通知,最终通知,环绕通知(切面要完成的功能)</li><li><code>Introduction</code>(引介)：引介是一种特殊的通知在不修改类代码的前提下, Introduction 可以在运行期为类动态地添加一些方法或 Field</li><li><code>Target</code>(目标对象)：代理的目标对象</li><li><code>Weaving</code>(织入)：是指把增强应用到目标对象来创建新的代理对象的过程，spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装在期织入</li><li><code>Proxy</code>（代理）：一个类被 AOP 织入增强后，就产生一个结果代理类</li><li><code>Aspect</code>(切面)：是切入点和通知（引介）的结合</li></ul><h4 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h4><ul><li>前置通知 ：在目标方法执行之前执行</li><li>后置通知 ：在目标方法执行之后执行</li><li>环绕通知 ：在目标方法执行前和执行后执行</li><li>异常抛出通知：在目标方法执行出现异常的时候执行</li><li>最终通知 ：无论目标方法是否出现异常 最终通知都会执行</li></ul><h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><p>通知类，给切面的目标方法标注何时地运行，必须告诉 Spring 哪个类是切面类，添加注解 @Aspect</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span>  <span class="comment">// 表示该类是一个通知类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAdvice</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* com.cuzz.service..*ServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是前置通知!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(* com.cuzz.service..*ServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是后置通知(如果出现异常不会调用)!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"execution(* com.cuzz.service..*ServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是环绕通知之前的部分!!"</span>);</span><br><span class="line">        <span class="comment">// 调用目标方法</span></span><br><span class="line">        Object proceed = pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">"这是环绕通知之后的部分!!"</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(* com.cuzz.service..*ServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterException</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"出事啦!出现异常了!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置通知</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* com.cuzz.service..*ServiceImpl.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是后置通知(出现异常也会调用)!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置类，将切面类和业务逻辑类都加入到容器中，给配置类加 @EnableAspectJAutoProxy  注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: cuzz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>: 2019/2/10 20:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainConfigOfAOP</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserService <span class="title">userService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyAdvice <span class="title">myAdvice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyAdvice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    AnnotationConfigApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(MainConfigOfAOP.class);</span><br><span class="line"></span><br><span class="line">    UserService userService = (UserService) applicationContext.getBean(<span class="string">"userService"</span>);</span><br><span class="line">    userService.add();</span><br><span class="line">    userService.delete();</span><br><span class="line">    userService.update();</span><br><span class="line">    userService.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果报错添加依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.aspectj&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.8.4&lt;/version&gt;</span><br><span class="line"> &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AOP面向切面编程&quot;&gt;&lt;a href=&quot;#AOP面向切面编程&quot; class=&quot;headerlink&quot; title=&quot;AOP面向切面编程&quot;&gt;&lt;/a&gt;AOP面向切面编程&lt;/h2&gt;&lt;p&gt;AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。&lt;/p&gt;
    
    </summary>
    
      <category term="Spring" scheme="http://blog.cuzz.site/categories/Spring/"/>
    
    
      <category term="源码" scheme="http://blog.cuzz.site/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="Spring" scheme="http://blog.cuzz.site/tags/Spring/"/>
    
      <category term="注解" scheme="http://blog.cuzz.site/tags/%E6%B3%A8%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Java虚拟机（三）</title>
    <link href="http://blog.cuzz.site/2019/02/06/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://blog.cuzz.site/2019/02/06/深入理解Java虚拟机（三）/</id>
    <published>2019-02-06T15:59:59.000Z</published>
    <updated>2019-04-21T15:15:47.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java-字节码"><a href="#Java-字节码" class="headerlink" title="Java 字节码"></a>Java 字节码</h3><p>代码编译结果从本地机器码转变为字节码，是存储格式发展的一小步，确是编程语言发展的一大步。</p><a id="more"></a><h3 id="字节码文件剖析"><a href="#字节码文件剖析" class="headerlink" title="字节码文件剖析"></a>字节码文件剖析</h3><p>我们从一段简单的代码来入手</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class MyTest01 &#123;</span><br><span class="line"></span><br><span class="line">    private int a = 0;</span><br><span class="line"></span><br><span class="line">    public int getA() &#123;</span><br><span class="line">        return a;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setA(int a) &#123;</span><br><span class="line">        this.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我要要看一下 java 文件对应的 class 文件的结构，定位到工程的 out\production\classes 下边执行： </p><p>javap -c com.cuzz.jvm.bytecode.Mytest01</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">警告: 二进制文件com.cuzz.jvm.bytecode.Mytest01包含com.cuzz.jvm.bytecode.MyTest01</span><br><span class="line">Compiled from &quot;MyTest01.java&quot;</span><br><span class="line">public class com.cuzz.jvm.bytecode.MyTest01 &#123;</span><br><span class="line">  public com.cuzz.jvm.bytecode.MyTest01();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">       4: aload_0</span><br><span class="line">       5: iconst_0</span><br><span class="line">       6: putfield      #2                  // Field a:I</span><br><span class="line">       9: return</span><br><span class="line"></span><br><span class="line">  public int getA();</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: getfield      #2                  // Field a:I</span><br><span class="line">       4: ireturn</span><br><span class="line"></span><br><span class="line">  public void setA(int);</span><br><span class="line">    Code:</span><br><span class="line">       0: aload_0</span><br><span class="line">       1: iload_1</span><br><span class="line">       2: putfield      #2                  // Field a:I</span><br><span class="line">       5: return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们如果需要获得更多信息可以使用如下命令：</p><p>javap -verbose com.cuzz.jvm.bytecode.Mytest01</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">警告: 二进制文件com.cuzz.jvm.bytecode.Mytest01包含com.cuzz.jvm.bytecode.MyTest01</span><br><span class="line">Classfile /E:/project/learn-demo/demo-10-jvm-lecture/out/production/classes/com/cuzz/jvm/bytecode/Mytest01.class</span><br><span class="line">  Last modified 2019-2-3; size 492 bytes</span><br><span class="line">  MD5 checksum cceeac51ae7b6fc46c60faf834de5932</span><br><span class="line">  Compiled from &quot;MyTest01.java&quot;</span><br><span class="line">public class com.cuzz.jvm.bytecode.MyTest01</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#21         // com/cuzz/jvm/bytecode/MyTest01.a:I</span><br><span class="line">   #3 = Class              #22            // com/cuzz/jvm/bytecode/MyTest01</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/cuzz/jvm/bytecode/MyTest01;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               MyTest01.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               com/cuzz/jvm/bytecode/MyTest01</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public com.cuzz.jvm.bytecode.MyTest01();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: iconst_0</span><br><span class="line">         6: putfield      #2                  // Field a:I</span><br><span class="line">         9: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">        line 10: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      10     0  this   Lcom/cuzz/jvm/bytecode/MyTest01;</span><br><span class="line"></span><br><span class="line">  public int getA();</span><br><span class="line">    descriptor: ()I</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field a:I</span><br><span class="line">         4: ireturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lcom/cuzz/jvm/bytecode/MyTest01;</span><br><span class="line"></span><br><span class="line">  public void setA(int);</span><br><span class="line">    descriptor: (I)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: iload_1</span><br><span class="line">         2: putfield      #2                  // Field a:I</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 17: 0</span><br><span class="line">        line 18: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Lcom/cuzz/jvm/bytecode/MyTest01;</span><br><span class="line">            0       6     1     a   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MyTest01.java&quot;</span><br></pre></td></tr></table></figure><p>我们也可以使用二进制文件<a href="https://www.baidu.com/s?wd=%E6%9F%A5%E7%9C%8B%E5%99%A8&amp;tn=24004469_oem_dg&amp;rsv_dl=gh_pl_sl_csd" target="_blank" rel="noopener">查看器</a>查看class文件的16进制信息（<a href="http://www.x-ways.net/winhex.zip" target="_blank" rel="noopener">winhex下载</a>）： </p><p><img src="深入理解Java虚拟机（三）\1549161558276.png" alt="1549161558276"></p><p>16文件查看器里边第一行的CA 就是一个字节的容量（8位bit）: </p><p>使用 javap -verbos 命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法信息、类变量与成员变量等信息。 </p><p>魔数：所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE (詹姆斯.高斯林设计的，蕴意：咖啡宝贝，java 的图标是咖啡。 </p><p>魔数之后的4个字节为版本信息，前2个字节表示 minor versio（次版本号），后两个字节表示 major version（主版本号）。 这里的版本号为 00 00 00 34，换算成十进制，表示次版本号为0，主版本号为52。</p><h3 id="字节常量池剖析"><a href="#字节常量池剖析" class="headerlink" title="字节常量池剖析"></a>字节常量池剖析</h3><p>常量池（constant pool）：紧接着主版本号之后的就是常量池入口。一个 Java 类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是 Class 文件的资源仓库，比如说 Java 类中定义的方法与变量信息，都是存储在常量池中。常量池中的主要储存两类常量：字面量与符号引用。字面量如文本字符串，Java 中声明为 final 的常量值等，而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。</p><p>常量池的总体结构：Java 类所对应的常量池主要由常量池数量与常量池数组（常量表）这两部分共同构成。常量池数量紧跟在主版本号后面，占据 2 个字节；常量池数组紧跟在常量池数量之后。常量池数组与一般的数组不同的是，常量池数组中不同的元素类型、结构都是不同的，长度当然也就不同；但是，每一种元素的第一个数据都是一个 u1 类型，该字节是一个标志位，占据 1 个字节。JVM 在解析常量池时，会根据这个 u1 类型来获取元素的具体类型。</p><p>值得注意的是，常量池数组中元素的个数  = 常量池数 - 1 （其中0暂时不使用）。对应的是 00 18  转化为十进制为24个常量，而我们看到只有23个。目的是满足某些常量池索引值的数据在特定情况下需要表达“不引用任何一个常量”的含义；根本原因在于，索引 0 也是一个常量（保留常量），只不过它不位于常量表中，这个常量就对应 null 值，所以，常量池的索引从 1 开始而不是 0 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #3.#21         // com/cuzz/jvm/bytecode/MyTest01.a:I</span><br><span class="line">   #3 = Class              #22            // com/cuzz/jvm/bytecode/MyTest01</span><br><span class="line">   #4 = Class              #23            // java/lang/Object</span><br><span class="line">   #5 = Utf8               a</span><br><span class="line">   #6 = Utf8               I</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lcom/cuzz/jvm/bytecode/MyTest01;</span><br><span class="line">  #14 = Utf8               getA</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               setA</span><br><span class="line">  #17 = Utf8               (I)V</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               MyTest01.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = NameAndType        #5:#6          // a:I</span><br><span class="line">  #22 = Utf8               com/cuzz/jvm/bytecode/MyTest01</span><br><span class="line">  #23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><p>Class 文件结构中常量池数据类型的结构表</p><p><img src="深入理解Java虚拟机（三）\c717816f04e3fee14c9745e06356247a.jpg" alt="c717816f04e3fee14c9745e06356247a"></p><p>在 JVM 规范中，每一个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回的 void 类型都是用一个大写字符来表示，对象类型则使用字符 L 加对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM 都只使用一个大写字母来表示，如下所示：B - byte，C - char，D - double，F  - float，I - int，J - long，S - short，Z - boolean，V - void，L - 对象类型，如 <code>Ljava/lang/String;</code>。</p><p>对于数组类型来说，没一个维度使用前置 [ 来表示，如 <code>int []</code> 被记录为 [I ，<code>String[][]</code>  被记录为 <code>[[Ljava/lang/String;</code>。</p><p>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组括号内，如方法：<code>String getRealNameByIdAndNickName(int id, String name)</code> 的描述符为：<code>(I, Ljava/lang/String;) Ljava/lang/String;</code></p><p>我们来分析前面几个常量，如图：</p><p><img src="深入理解Java虚拟机（三）\1549183205091.png" alt="1549183205091"></p><p>我反编译出来的文件对比：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Constant pool:</span><br><span class="line"> #1 = Methodref          #4.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line"> #2 = Fieldref           #3.#21         // com/cuzz/jvm/bytecode/MyTest01.a:I</span><br><span class="line"> #3 = Class              #22            // com/cuzz/jvm/bytecode/MyTest01</span><br><span class="line"> #4 = Class              #23            // java/lang/Object</span><br><span class="line"> #5 = Utf8               a</span><br><span class="line"> #6 = Utf8               I</span><br><span class="line"> #7 = Utf8               &lt;init&gt;</span><br><span class="line"> #8 = Utf8               ()V</span><br><span class="line"> #9 = Utf8               Code</span><br><span class="line">#10 = Utf8               LineNumberTable</span><br><span class="line">#11 = Utf8               LocalVariableTable</span><br><span class="line">#12 = Utf8               this</span><br><span class="line">#13 = Utf8               Lcom/cuzz/jvm/bytecode/MyTest01;</span><br><span class="line">#14 = Utf8               getA</span><br><span class="line">#15 = Utf8               ()I</span><br><span class="line">#16 = Utf8               setA</span><br><span class="line">#17 = Utf8               (I)V</span><br><span class="line">#18 = Utf8               SourceFile</span><br><span class="line">#19 = Utf8               MyTest01.java</span><br><span class="line">#20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#21 = NameAndType        #5:#6          // a:I</span><br><span class="line">#22 = Utf8               com/cuzz/jvm/bytecode/MyTest01</span><br><span class="line">#23 = Utf8               java/lang/Object</span><br></pre></td></tr></table></figure><ol><li><code>0A 00 04 00 14</code>，如图中的标注出来，0A 对应值为10，在上表的常量中 CONSTANT_Methodref_info 中，那么后边的2个字节 00 04 （十进制4）就是 U2（第一个index），即指向声明方法的类描述符 CONSTANT_Class_info 的索引项，而第二个索引（第二个index）00 14（十进制20） 指向名称及类型描述符 CONSTANT_NameAndType_info 的索引项。类描述指向 #4 ，#4 又指向 #23，所以描述为 java/lang/Object，而名称以及类型描述符指向 #20，#20 有指向 #7 和 #8，<code>&quot;&lt;init&gt;&quot;:()V</code> 表示为构造方法。</li><li><code>09 00 03 00 15</code> ，09 是标志位对用的是 CONSTANT_Fieldref_info，第一个索引指向的是声明字段的类或接口描述符，CONSTANT_Class_info 的索引项，根上面一样分析。</li><li><code>07 00 16</code> ， 00 16 十进制是22 ，07是常量 CONSTANT_CLass_info，只有一个index，指向的是指定权限定名常量项的索引， 00 16 是十进制22。</li><li><code>07 00 17</code> ，07是常量 CONSTANT_CLass_info，只有一个index，指向的是指定权限定名常量项的索引，00 17 十进制是23。</li><li><code>01 00 01 61</code>，01 是 CONSTANT_Utf8_info，后面 00 01 这两个字节表示长度，最后 61 （十进制为97）的表示 ASCII 中带索引，在 ASCII 中为字母 a。</li><li><code>01 00 01</code>  为 I。</li><li>等等</li></ol><h3 id="Java-字节码结构"><a href="#Java-字节码结构" class="headerlink" title="Java 字节码结构"></a>Java 字节码结构</h3><p><img src="深入理解Java虚拟机（三）\class-structure.jpg" alt="class-structure"></p><p>Class 字节码中有两种数据类型</p><ul><li>字节数据直接量：这是基本的数据类型，共细分为 u1、u2、u4、u8 这四种，分别代表连续的 1 个字节、2 个字节、4 个字节和8 个字节。</li><li>表（数组）：表示有多个基本数据或其他表，按照既定顺序组成的大的数据集合。表示有结构的，它的结构体现在，组成表的成分所在的位置和顺序都已经严格定义好的。</li></ul><h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>访问标志（Access_Flag）信息包括该 Class 文件是类还是接口，是否被定义成 public，是否是 abstract，如果是类，是否被声明成 final。通过上面的源代码，我们可以知道该文件是类并且是 public。</p><p><img src="深入理解Java虚拟机（三）\access-flag.jpg" alt="access-flag"></p><p>常量池之后两个字节就是访问标志，我们这个类中是 <code>0x 00 21</code> ，从上面来看并没有，原来它是 <code>0x 00 20</code> 和 <code>0x 00 01</code> 的并集，表示 ACC_PUBLIC 与 ACC_SUPER。</p><h3 id="类索引、父类索引与接口索引"><a href="#类索引、父类索引与接口索引" class="headerlink" title="类索引、父类索引与接口索引"></a>类索引、父类索引与接口索引</h3><p><img src="深入理解Java虚拟机（三）\1549250272126.png" alt="1549250272126"></p><ul><li><code>00 03</code> 是类索引，指向 #3 表示是一个类，其名字为 com/cuzz/jvm/bytecode/MyTest01</li><li><code>00 04</code> 是父亲索引，指向 #4 表示是一个类，其名字是 java/lang/Object</li><li><code>00 00</code> 是接口，表示没有接口</li></ul><h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表用于描述类和接口中声明的变量。这里的字段包含了类级别变量以及实例变量，但不包括方法内部声明的局部变量。</p><p><img src="深入理解Java虚拟机（三）\1549339719719.png" alt="1549339719719"></p><p>如下图</p><p><img src="深入理解Java虚拟机（三）\1549340431752.png" alt="1549340431752"></p><p>00 01 是成员变量的数量，后面接着就是 field_info 成员变量信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">    u2 access_flags; // 0002 表示私有 private</span><br><span class="line">    u2 name_index; // 0005 表示 a</span><br><span class="line">    u2 descriptor_index; // 0006 表示 I</span><br><span class="line">    u2 attributes_count; // 0000 没有</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h3><p>刚开始的 00 03 表示有三个方法，除了getter/setter 还有默认构造方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">methods_count &#123;</span><br><span class="line">    u2 access_flags; // 0001 表示 public</span><br><span class="line">    u2 name_index; // 0007 指向常量池中 #7 的常量为 &lt;init&gt;</span><br><span class="line">    u2 descriptor_index; // 0008 指向常量池中 #8 的常量为 ()V</span><br><span class="line">    u2 attributes_count; // 0001 表示一个属性</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中的属性结构</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">attribute_info &#123;</span><br><span class="line">    u2 attribute_name_index; // 0009 指向常量池中 #9 为 Code</span><br><span class="line">    u4 attribute_length; // 0000 0038 表示长度为 0x38 为 56 长度的字节</span><br><span class="line">    u1 info[attribute_length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code-结构"><a href="#Code-结构" class="headerlink" title="Code 结构"></a>Code 结构</h3><p>Code attribute 的作用是保存该方法的结构，如所对应的字节码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">    u2 attribute_name_index;</span><br><span class="line">    u4 attribute_length;</span><br><span class="line">    u2 max_stack;</span><br><span class="line">    u2 max_locals;</span><br><span class="line">    u4 code_length;</span><br><span class="line">    u1 code[code_length];</span><br><span class="line">    u2 exception_table_length;</span><br><span class="line">    &#123;</span><br><span class="line">        u2 start_pc;</span><br><span class="line">        u2 end_pc;</span><br><span class="line">        u2 handler_pc;</span><br><span class="line">        u2 catch_type;</span><br><span class="line">    &#125; exception_table[exception_table_length];</span><br><span class="line">    u2 attributes_count;</span><br><span class="line">    attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>attribute_length 表示 attribute 所包含的字节数，不包含 attribute_name_index 和 attribute_length 字段</li><li>max_stack 表示这个方法运行的任何时刻所能达到的操作数栈的最大深度</li><li>max_locals 表示方法执行期间创建的局部变量的数目，包含用来表示传入的参数的局部变量</li><li>code_length 表示该方法所包含的字节码的字节数以及具体的指令码，具体字节码即是该方法被调用时，虚拟机所执行的字节码</li><li>exception_table 表示存放的是处理异常的信息<ul><li>每个 exception_table 表由 start_pc，end_pc，handler_pc，catch_type 组成</li><li>start_pc 和 end_pc 表示在 code 数组中的从 start_pc 到 end_pc 处（包含 start_pc，不包含 end_pc）的指令抛出的异常会由这个表项来处理</li><li>handler_pc 表示处理异常的代码的开始处，catch_type 表示会被处理的异常类型，它指向常量池中的一个异常类，当 catch_type 为 0 时，表示处理所有的异常</li></ul></li></ul><h3 id="字节码查看工具"><a href="#字节码查看工具" class="headerlink" title="字节码查看工具"></a>字节码查看工具</h3><p><a href="https://github.com/ingokegel/jclasslib" target="_blank" rel="noopener">https://github.com/ingokegel/jclasslib</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Java-字节码&quot;&gt;&lt;a href=&quot;#Java-字节码&quot; class=&quot;headerlink&quot; title=&quot;Java 字节码&quot;&gt;&lt;/a&gt;Java 字节码&lt;/h3&gt;&lt;p&gt;代码编译结果从本地机器码转变为字节码，是存储格式发展的一小步，确是编程语言发展的一大步。&lt;/p&gt;
    
    </summary>
    
      <category term="深入理解Java虚拟机" scheme="http://blog.cuzz.site/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="JVM" scheme="http://blog.cuzz.site/tags/JVM/"/>
    
  </entry>
  
</feed>
